/**
 * GENYSYS Analytics - Google Apps Script (Hardened for Public Use)
 * 
 * SETUP INSTRUCTIONS:
 * 1. Go to https://script.google.com and create a new project
 * 2. Paste this entire code into the editor
 * 3. Click "Deploy" → "New deployment"
 * 4. Choose "Web app" as the type
 * 5. Set "Execute as" to "Me"
 * 6. Set "Who has access" to "Anyone"
 * 7. Click "Deploy" and copy the Web App URL
 * 8. Paste that URL into ANALYTICS_ENDPOINT in your index.html files
 * 
 * SHEET SETUP:
 * - Create a Google Sheet with this exact name: "GENYSYS Analytics"
 * - The script will auto-create headers on first event
 */

// Configuration
const SPREADSHEET_NAME = 'GENYSYS Analytics';
const SHEET_NAME = 'Events';
const BLOCKED_SHEET_NAME = 'Blocked';

// Security settings
const RATE_LIMIT_SECONDS = 0; // Minimum seconds between events from same user
const MAX_EVENTS_PER_DAY_PER_USER = 200;

// Allowed event names (reject anything not on this list)
const ALLOWED_EVENTS = [
  // Session & Onboarding
  'session_start',
  'onboarding_complete',
  'legacy_user_migrated',
  
  // HRV Logging
  'first_hrv_logged',
  'hrv_logged',
  'hrv_backfilled',
  
  // Commands & Observations
  'command_generated',
  'observation_shown',
  'milestone_reached',
  
  // Compliance & Energy
  'compliance_recorded',
  'energy_recorded',
  
  // Retention Milestones
  'day_3_active',
  'day_7_active',
  'day_14_active',
  'day_30_active',
  
  // Feedback (Round-specific)
  'feedback_round1_submitted',
  'feedback_round1_dismissed',
  'feedback_round2_submitted',
  'feedback_round2_dismissed',
  
  // Legacy feedback events (keep for backwards compatibility)
  'feedback_submitted',
  'feedback_dismissed',
  
  // Data Management
  'data_exported',
  'results_sent',
  'data_reset'
];

/**
 * Handle POST requests (events from the app)
 */
function doPost(e) {
  try {
    // Parse and validate
    const data = JSON.parse(e.postData.contents);
    const validation = validateEvent(data);
    
    if (!validation.valid) {
      logBlocked(data, validation.reason);
      return ContentService
        .createTextOutput(JSON.stringify({ status: 'rejected', reason: validation.reason }))
        .setMimeType(ContentService.MimeType.JSON);
    }
    
    // Check rate limit
    const rateLimitResult = checkRateLimit(data.userId);
    if (!rateLimitResult.allowed) {
      logBlocked(data, rateLimitResult.reason);
      return ContentService
        .createTextOutput(JSON.stringify({ status: 'rate_limited' }))
        .setMimeType(ContentService.MimeType.JSON);
    }
    
    // Log the event
    logEvent(data);
    
    return ContentService
      .createTextOutput(JSON.stringify({ status: 'success' }))
      .setMimeType(ContentService.MimeType.JSON);
      
  } catch (error) {
    console.error('Error processing event:', error);
    return ContentService
      .createTextOutput(JSON.stringify({ status: 'error' }))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

/**
 * Handle GET requests (for testing)
 */
function doGet(e) {
  return ContentService
    .createTextOutput(JSON.stringify({ status: 'ok', message: 'GENYSYS Analytics endpoint is running' }))
    .setMimeType(ContentService.MimeType.JSON);
}

/**
 * Validate incoming event data
 */
function validateEvent(data) {
  // Must have userId
  if (!data.userId || typeof data.userId !== 'string') {
    return { valid: false, reason: 'missing_user_id' };
  }
  
  // userId must be valid UUID v4 format (36 chars with hyphens)
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
  if (!uuidRegex.test(data.userId)) {
    return { valid: false, reason: 'invalid_user_id_format' };
  }
  
  // Must have event name
  if (!data.event || typeof data.event !== 'string') {
    return { valid: false, reason: 'missing_event' };
  }
  
  // Event must be on allowlist
  if (!ALLOWED_EVENTS.includes(data.event)) {
    return { valid: false, reason: 'unknown_event: ' + data.event };
  }
  
  // Timestamp validation (if provided, must be within 24 hours of now)
  if (data.timestamp) {
    const eventTime = new Date(data.timestamp).getTime();
    const now = Date.now();
    const twentyFourHours = 24 * 60 * 60 * 1000;
    
    if (isNaN(eventTime) || Math.abs(now - eventTime) > twentyFourHours) {
      return { valid: false, reason: 'invalid_timestamp' };
    }
  }
  
  // HRV sanity check (if provided, must be reasonable: 1-300ms)
  if (data.hrv !== undefined && data.hrv !== null && data.hrv !== '') {
    const hrv = Number(data.hrv);
    if (isNaN(hrv) || hrv < 1 || hrv > 300) {
      return { valid: false, reason: 'invalid_hrv' };
    }
  }
  
  // daysActive sanity check (if provided, must be 0-3650)
  if (data.daysActive !== undefined && data.daysActive !== null && data.daysActive !== '') {
    const days = Number(data.daysActive);
    if (isNaN(days) || days < 0 || days > 3650) {
      return { valid: false, reason: 'invalid_days_active' };
    }
  }
  
  // Payload size check (prevent giant payloads)
  const payloadSize = JSON.stringify(data).length;
  if (payloadSize > 5000) {
    return { valid: false, reason: 'payload_too_large' };
  }
  
  return { valid: true };
}

/**
 * Check rate limiting for a user
 */
function checkRateLimit(userId) {
  const cache = CacheService.getScriptCache();
  const now = Date.now();
  const today = new Date().toISOString().split('T')[0];
  
  // Check last event time
  const lastEventKey = 'last_' + userId;
  const lastEvent = cache.get(lastEventKey);
  
  if (lastEvent) {
    const timeSince = (now - parseInt(lastEvent)) / 1000;
    if (timeSince < RATE_LIMIT_SECONDS) {
      return { allowed: false, reason: 'too_fast' };
    }
  }
  
  // Check daily count
  const dailyCountKey = 'daily_' + today + '_' + userId;
  const dailyCount = parseInt(cache.get(dailyCountKey) || '0');
  
  if (dailyCount >= MAX_EVENTS_PER_DAY_PER_USER) {
    return { allowed: false, reason: 'daily_limit' };
  }
  
  // Update rate limit trackers
  cache.put(lastEventKey, now.toString(), 60); // 1 minute TTL
  cache.put(dailyCountKey, (dailyCount + 1).toString(), 86400); // 24 hour TTL
  
  return { allowed: true };
}

/**
 * Log an event to the spreadsheet
 */
function logEvent(data) {
  const ss = SpreadsheetApp.getActiveSpreadsheet() || 
             SpreadsheetApp.openByName(SPREADSHEET_NAME);
  
  let sheet = ss.getSheetByName(SHEET_NAME);
  
  // Create sheet with headers if it doesn't exist
  if (!sheet) {
    sheet = ss.insertSheet(SHEET_NAME);
    const headers = [
      'Timestamp',
      'User ID', 
      'Event',
      'Device',
      'Days Active',
      'Region',
      'HRV',
      'HRV Date',
      'Command',
      'Z Score',
      'Days Logged',
      'Is Preview',
      'Compliance Date',
      'Followed',
      'Energy',
      'Observation Type',
      'Milestone',
      'Feedback Round',
      'Useful',
      'Improvement Text',
      'User Email',
      'Returning',
      'Extra Data'
    ];
    sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
    sheet.getRange(1, 1, 1, headers.length).setFontWeight('bold');
    sheet.setFrozenRows(1);
  }
  
  // Sanitize string fields (prevent formula injection)
  const sanitize = (val) => {
    if (typeof val !== 'string') return val;
    // Prefix with single quote if starts with =, +, -, @, or tab/newline
    if (/^[=+\-@\t\r\n]/.test(val)) {
      return "'" + val;
    }
    return val.substring(0, 500); // Limit string length
  };
  
  // Build the row
  const row = [
    data.timestamp || new Date().toISOString(),
    sanitize(data.userId) || '',
    sanitize(data.event) || '',
    sanitize(data.device) || '',
    data.daysActive ?? '',
    sanitize(data.region) || '',
    data.hrv ?? '',
    sanitize(data.hrvDate) || '',
    sanitize(data.command) || '',
    data.zScore ?? '',
    data.daysLogged ?? '',
    data.isPreview ?? '',
    sanitize(data.complianceDate) || '',
    sanitize(data.followed) || '',
    sanitize(data.energy) || '',
    sanitize(data.observationType) || '',
    sanitize(data.milestone) || '',
    data.feedbackRound ?? '',
    sanitize(data.useful) || '',
    sanitize(data.improvementText) || '',
    sanitize(data.userEmail) || '',
    data.returning ?? '',
    sanitize(JSON.stringify(filterKnownFields(data))) // Capture any extra fields
  ];
  
  sheet.appendRow(row);
}

/**
 * Log blocked/rejected events for monitoring abuse
 */
function logBlocked(data, reason) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet() || 
               SpreadsheetApp.openByName(SPREADSHEET_NAME);
    
    let sheet = ss.getSheetByName(BLOCKED_SHEET_NAME);
    
    if (!sheet) {
      sheet = ss.insertSheet(BLOCKED_SHEET_NAME);
      sheet.getRange(1, 1, 1, 4).setValues([['Timestamp', 'Reason', 'User ID', 'Raw Data']]);
      sheet.getRange(1, 1, 1, 4).setFontWeight('bold');
      sheet.setFrozenRows(1);
    }
    
    // Truncate data to prevent abuse
    const truncatedData = JSON.stringify(data).substring(0, 1000);
    
    sheet.appendRow([
      new Date().toISOString(),
      reason,
      (data.userId || 'unknown').substring(0, 50),
      truncatedData
    ]);
  } catch (e) {
    console.error('Error logging blocked event:', e);
  }
}

/**
 * Filter out known fields to capture extras
 */
function filterKnownFields(data) {
  const knownFields = [
    'timestamp', 'userId', 'event', 'device', 'daysActive', 'region',
    'hrv', 'hrvDate', 'command', 'zScore', 'daysLogged', 'isPreview', 
    'complianceDate', 'followed', 'energy', 'observationType', 'milestone',
    'feedbackRound', 'useful', 'improvementText', 'userEmail', 'returning'
  ];
  
  const extras = {};
  for (const key in data) {
    if (!knownFields.includes(key)) {
      extras[key] = data[key];
    }
  }
  return Object.keys(extras).length > 0 ? extras : null;
}

/**
 * Create a summary dashboard (run manually or on schedule)
 */
function createDashboard() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const eventsSheet = ss.getSheetByName(SHEET_NAME);
  
  if (!eventsSheet) {
    console.log('No events sheet found');
    return;
  }
  
  let dashSheet = ss.getSheetByName('Dashboard');
  if (!dashSheet) {
    dashSheet = ss.insertSheet('Dashboard');
  }
  
  const data = eventsSheet.getDataRange().getValues();
  const headers = data[0];
  const events = data.slice(1);
  
  // Get column indices
  const cols = {
    userId: headers.indexOf('User ID'),
    event: headers.indexOf('Event'),
    device: headers.indexOf('Device'),
    region: headers.indexOf('Region'),
    daysActive: headers.indexOf('Days Active'),
    command: headers.indexOf('Command'),
    observationType: headers.indexOf('Observation Type'),
    milestone: headers.indexOf('Milestone')
  };
  
  // Calculate metrics
  const uniqueUsers = new Set(events.map(row => row[cols.userId])).size;
  const onboardingComplete = events.filter(row => row[cols.event] === 'onboarding_complete').length;
  const legacyMigrated = events.filter(row => row[cols.event] === 'legacy_user_migrated').length;
  const firstHrvLogged = events.filter(row => row[cols.event] === 'first_hrv_logged').length;
  const day3Active = events.filter(row => row[cols.event] === 'day_3_active').length;
  const day7Active = events.filter(row => row[cols.event] === 'day_7_active').length;
  const day14Active = events.filter(row => row[cols.event] === 'day_14_active').length;
  const day30Active = events.filter(row => row[cols.event] === 'day_30_active').length;
  
  // Total signups = onboarding + legacy
  const totalSignups = onboardingComplete + legacyMigrated;
  
  // Command distribution
  const commands = {};
  events.filter(row => row[cols.event] === 'command_generated')
    .forEach(row => {
      const cmd = row[cols.command] || 'unknown';
      commands[cmd] = (commands[cmd] || 0) + 1;
    });
  
  // Feedback metrics
  const feedback1Submitted = events.filter(row => row[cols.event] === 'feedback_round1_submitted').length;
  const feedback1Dismissed = events.filter(row => row[cols.event] === 'feedback_round1_dismissed').length;
  const feedback2Submitted = events.filter(row => row[cols.event] === 'feedback_round2_submitted').length;
  const feedback2Dismissed = events.filter(row => row[cols.event] === 'feedback_round2_dismissed').length;
  
  // Device breakdown
  const devices = {};
  events.filter(row => row[cols.event] === 'onboarding_complete' || row[cols.event] === 'legacy_user_migrated')
    .forEach(row => {
      const device = row[cols.device] || 'unknown';
      devices[device] = (devices[device] || 0) + 1;
    });
  
  // Region breakdown
  const regions = {};
  events.filter(row => row[cols.event] === 'onboarding_complete' || row[cols.event] === 'legacy_user_migrated')
    .forEach(row => {
      const region = row[cols.region] || 'unknown';
      regions[region] = (regions[region] || 0) + 1;
    });
  
  // Check blocked events
  const blockedSheet = ss.getSheetByName(BLOCKED_SHEET_NAME);
  const blockedCount = blockedSheet ? Math.max(0, blockedSheet.getLastRow() - 1) : 0;
  
  // Build dashboard
  dashSheet.clear();
  
  const dashData = [
    ['GENYSYS Analytics Dashboard', '', 'Last Updated:', new Date().toISOString()],
    [],
    ['FUNNEL METRICS'],
    ['Total Signups', totalSignups, '(onboarding + legacy)'],
    ['├─ New Onboarding', onboardingComplete],
    ['└─ Legacy Migrated', legacyMigrated],
    ['First HRV Logged', firstHrvLogged, 'Conv:', totalSignups > 0 ? (firstHrvLogged / totalSignups * 100).toFixed(1) + '%' : 'N/A'],
    [],
    ['RETENTION'],
    ['Day 3 Active', day3Active, 'Rate:', totalSignups > 0 ? (day3Active / totalSignups * 100).toFixed(1) + '%' : 'N/A'],
    ['Day 7 Active', day7Active, 'Rate:', totalSignups > 0 ? (day7Active / totalSignups * 100).toFixed(1) + '%' : 'N/A'],
    ['Day 14 Active', day14Active, 'Rate:', totalSignups > 0 ? (day14Active / totalSignups * 100).toFixed(1) + '%' : 'N/A'],
    ['Day 30 Active', day30Active, 'Rate:', totalSignups > 0 ? (day30Active / totalSignups * 100).toFixed(1) + '%' : 'N/A'],
    [],
    ['FEEDBACK'],
    ['Round 1 Submitted', feedback1Submitted],
    ['Round 1 Dismissed', feedback1Dismissed],
    ['Round 2 Submitted', feedback2Submitted],
    ['Round 2 Dismissed', feedback2Dismissed],
    [],
    ['COMMANDS GENERATED'],
    ...Object.entries(commands).sort((a, b) => b[1] - a[1]).map(([cmd, count]) => [cmd, count]),
    [],
    ['SECURITY'],
    ['Unique Users', uniqueUsers],
    ['Blocked Events', blockedCount, blockedCount > 10 ? '⚠️ Check Blocked sheet' : '✓'],
    [],
    ['DEVICES'],
    ...Object.entries(devices).sort((a, b) => b[1] - a[1]).map(([device, count]) => [device, count]),
    [],
    ['REGIONS (Top 10)'],
    ...Object.entries(regions).sort((a, b) => b[1] - a[1]).slice(0, 10).map(([region, count]) => [region, count])
  ];
  
  dashSheet.getRange(1, 1, dashData.length, 4).setValues(dashData.map(row => {
    while (row.length < 4) row.push('');
    return row;
  }));
  
  // Style the dashboard
  dashSheet.getRange(1, 1).setFontSize(14).setFontWeight('bold');
  dashSheet.getRange('A3').setFontWeight('bold');
  dashSheet.getRange('A9').setFontWeight('bold');
  dashSheet.getRange('A15').setFontWeight('bold');
  dashSheet.getRange('A21').setFontWeight('bold');
  
  console.log('Dashboard updated');
}

/**
 * Set up a daily trigger to update the dashboard
 */
function setupDailyDashboardUpdate() {
  // Remove existing triggers
  const triggers = ScriptApp.getProjectTriggers();
  triggers.forEach(trigger => {
    if (trigger.getHandlerFunction() === 'createDashboard') {
      ScriptApp.deleteTrigger(trigger);
    }
  });
  
  // Create new daily trigger at 6 AM
  ScriptApp.newTrigger('createDashboard')
    .timeBased()
    .atHour(6)
    .everyDays(1)
    .create();
  
  console.log('Daily dashboard trigger set up');
}

/**
 * Manual function to clear the blocked events sheet (run if needed)
 */
function clearBlockedEvents() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheet = ss.getSheetByName(BLOCKED_SHEET_NAME);
  if (sheet && sheet.getLastRow() > 1) {
    sheet.deleteRows(2, sheet.getLastRow() - 1);
    console.log('Blocked events cleared');
  }
}
