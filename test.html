<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#0A0A0A">
  <title>GENYSYS ‚Äî TEST MODE</title>
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;1,300;1,400&display=swap" rel="stylesheet">
  
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18.2.0/umd/react.production.min.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@babel/standalone@7.23.5/babel.min.js" crossorigin="anonymous"></script>
  
  <style>
    :root {
      --bg-primary: #0A0A0A;
      --bg-elevated: #111111;
      --bg-card: #141414;
      --bg-test: #1a1a0a;
      --text-primary: #F5F5F0;
      --text-secondary: #A1A1AA;
      --text-muted: #52525B;
      --text-faint: #3F3F46;
      --gold: #C9A962;
      --green: #6EE7B7;
      --rose: #FDA4AF;
      --amber: #FCD34D;
      --font-display: 'Cormorant Garamond', Georgia, serif;
      --font-body: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', Roboto, sans-serif;
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; -webkit-font-smoothing: antialiased; }
    body { font-family: var(--font-body); background: var(--bg-primary); color: var(--text-primary); min-height: 100vh; line-height: 1.6; }
    .font-display { font-family: var(--font-display); font-weight: 300; letter-spacing: 0.02em; }
    
    @keyframes fadeRise { from { opacity: 0; transform: translateY(12px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    
    .animate-rise { animation: fadeRise 400ms ease-out forwards; }
    .animate-fade { animation: fadeIn 400ms ease-out forwards; }
    .delay-100 { animation-delay: 100ms; opacity: 0; }
    .delay-200 { animation-delay: 200ms; opacity: 0; }
    .delay-300 { animation-delay: 300ms; opacity: 0; }
    .delay-1000 { animation-delay: 1000ms; opacity: 0; }
    
    .btn-primary { background: transparent; border: 1px solid var(--text-faint); color: var(--text-secondary); padding: 16px 32px; border-radius: 12px; font-size: 15px; cursor: pointer; transition: all 150ms ease; width: 100%; }
    .btn-primary:active, .btn-primary.active { background: var(--bg-elevated); border-color: var(--gold); color: var(--gold); }
    .btn-ghost { background: transparent; border: none; color: var(--text-muted); padding: 12px 24px; font-size: 13px; cursor: pointer; }
    
    .btn-test { background: var(--bg-test); border: 1px solid var(--amber); color: var(--amber); padding: 6px 10px; border-radius: 6px; font-size: 10px; cursor: pointer; transition: all 150ms ease; white-space: nowrap; }
    .btn-test:hover { background: rgba(252, 211, 77, 0.1); }
    .btn-test.active { background: var(--amber); color: #000; }
    
    .input-minimal { background: transparent; border: 1px solid var(--text-faint); border-radius: 12px; padding: 16px 20px; color: var(--text-primary); font-size: 17px; width: 100%; text-align: center; outline: none; }
    .input-minimal:focus { border-color: var(--gold); }
    .input-minimal::placeholder { color: var(--text-muted); }
    
    .divider { height: 1px; background: var(--text-faint); opacity: 0.3; margin: 24px 0; }
    
    .insight-block { border-left: 2px solid var(--gold); padding-left: 24px; margin-top: 32px; opacity: 0.85; }
    .insight-block .label { font-size: 10px; letter-spacing: 0.2em; text-transform: uppercase; color: var(--text-muted); margin-bottom: 8px; }
    .insight-block .content { font-family: var(--font-display); font-style: italic; font-size: 15px; line-height: 1.8; color: var(--text-secondary); }
    
    .test-badge { position: fixed; top: 8px; right: 8px; background: var(--amber); color: #000; font-size: 9px; font-weight: 600; padding: 4px 8px; border-radius: 4px; letter-spacing: 0.1em; z-index: 200; }
    
    .test-panel { position: fixed; bottom: 0; left: 0; right: 0; background: var(--bg-test); border-top: 1px solid var(--amber); z-index: 100; max-height: 50vh; overflow-y: auto; }
    .test-panel-header { padding: 8px 12px; display: flex; justify-content: space-between; align-items: center; border-bottom: 1px solid rgba(252,211,77,0.2); }
    .test-panel-content { padding: 12px; }
    
    .story-arc-preview { background: var(--bg-elevated); border-radius: 8px; padding: 12px; margin-top: 12px; }
    .milestone-item { display: flex; justify-content: space-between; align-items: center; padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.05); }
    .milestone-item.active { color: var(--green); }
    .milestone-item.future { color: var(--text-muted); }
    .milestone-item.past { color: var(--text-faint); }
    
    ::-webkit-scrollbar { width: 4px; }
    ::-webkit-scrollbar-track { background: var(--bg-primary); }
    ::-webkit-scrollbar-thumb { background: var(--amber); border-radius: 2px; }
    
    input[type="file"] { display: none; }
    input[type="date"]::-webkit-calendar-picker-indicator { filter: invert(0.5); }
    input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useMemo, useCallback, useRef } = React;

    // ============================================
    // UTILITIES
    // ============================================
    const getLocalDateString = (date = new Date()) => `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
    const getTodayLocal = () => getLocalDateString();
    const getYesterdayLocal = () => { const d = new Date(); d.setDate(d.getDate() - 1); return getLocalDateString(d); };
    const getDayName = (dateStr) => ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][new Date(dateStr).getDay()];
    const formatDateAnchor = (dateStr) => {
      if (!dateStr) return null;
      const date = new Date(dateStr + 'T12:00:00');
      const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
      const day = date.getDate();
      const suffix = [1,21,31].includes(day) ? 'st' : [2,22].includes(day) ? 'nd' : [3,23].includes(day) ? 'rd' : 'th';
      return `${months[date.getMonth()]} ${day}${suffix}`;
    };

    // ============================================
    // TEST DATA GENERATORS
    // ============================================
    const generateTestData = (days, baseHRV = 50, variance = 12) => {
      const history = [];
      const compliance = [];
      const today = new Date();
      
      for (let i = days - 1; i >= 0; i--) {
        const date = new Date(today);
        date.setDate(date.getDate() - i);
        const dateStr = getLocalDateString(date);
        
        const dayOfWeek = date.getDay();
        const weekendBonus = (dayOfWeek === 0 || dayOfWeek === 6) ? 6 : 0;
        const trend = Math.sin(i / 7 * Math.PI) * 5;
        const noise = (Math.random() - 0.5) * variance;
        
        // Add occasional crashes
        const crashChance = Math.random();
        const crashPenalty = crashChance < 0.1 ? -15 : 0;
        
        const value = Math.round(baseHRV + weekendBonus + trend + noise + crashPenalty);
        history.push({ date: dateStr, value: Math.max(20, Math.min(100, value)) });
        
        // Add compliance for REST days
        if (value < baseHRV - variance/2 && i > 0 && Math.random() > 0.2) {
          compliance.push({
            date: dateStr,
            command: 'REST',
            followed: Math.random() > 0.35 ? 'yes' : 'no'
          });
        }
      }
      
      return { history, compliance };
    };

    const parseCSV = (csvText) => {
      const lines = csvText.trim().split('\n');
      const headers = lines[0].split(',');
      const hrvIndex = headers.findIndex(h => h.includes('Heart rate variability') || h.includes('HRV') || h.toLowerCase().includes('hrv'));
      const dateIndex = headers.findIndex(h => h.includes('Cycle start time') || h.includes('date') || h.toLowerCase().includes('date'));
      
      if (hrvIndex === -1 || dateIndex === -1) {
        throw new Error('Could not find HRV or date columns');
      }
      
      const history = [];
      for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',');
        const hrvValue = parseFloat(values[hrvIndex]);
        const dateValue = values[dateIndex];
        
        if (!isNaN(hrvValue) && dateValue) {
          const date = new Date(dateValue);
          if (!isNaN(date.getTime())) {
            const dateStr = getLocalDateString(date);
            // Avoid duplicates - keep the first entry for each date
            if (!history.find(h => h.date === dateStr)) {
              history.push({ date: dateStr, value: Math.round(hrvValue) });
            }
          }
        }
      }
      
      return history.sort((a, b) => new Date(a.date) - new Date(b.date));
    };

    // ============================================
    // ALGORITHM (Validated)
    // ============================================
    const THRESHOLDS = { REST: -1.0, PERFORM: 0.5, MAD_FLOOR: 3.0 };

    const calculateMedian = (arr) => {
      const sorted = [...arr].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
    };

    const calculateMAD = (arr, median) => {
      const deviations = arr.map(v => Math.abs(v - median)).sort((a, b) => a - b);
      return Math.max(calculateMedian(deviations) * 1.4826, THRESHOLDS.MAD_FLOOR);
    };

    const getCommandKey = (zScore) => {
      if (zScore === null) return 'LEARNING';
      if (zScore < THRESHOLDS.REST) return 'REST';
      if (zScore >= THRESHOLDS.PERFORM) return 'PERFORM';
      return 'BUILD';
    };

    // ============================================
    // PATTERN ENGINE (Full)
    // ============================================
    const analyzePatterns = (hrvHistory, complianceLog = [], firstUseDate, simulatedDay = null) => {
      if (hrvHistory.length < 3) return null;

      // If simulating a specific day, filter history to that point
      let effectiveHistory = hrvHistory;
      let effectiveToday = getTodayLocal();
      
      if (simulatedDay !== null && simulatedDay < hrvHistory.length) {
        effectiveHistory = hrvHistory.slice(0, simulatedDay + 1);
        effectiveToday = effectiveHistory[effectiveHistory.length - 1]?.date;
      }

      const values = effectiveHistory.map(h => h.value);
      const median = calculateMedian(values);
      const mad = calculateMAD(values, median);

      const withZScores = effectiveHistory.map(h => ({
        ...h,
        zScore: (h.value - median) / mad,
        command: getCommandKey((h.value - median) / mad)
      })).sort((a, b) => new Date(a.date) - new Date(b.date));

      const patterns = {
        baseline: median,
        mad,
        totalDays: effectiveHistory.length,
        restDays: withZScores.filter(h => h.command === 'REST').length,
        buildDays: withZScores.filter(h => h.command === 'BUILD').length,
        performDays: withZScores.filter(h => h.command === 'PERFORM').length,
        crashesAfterIgnoredRest: [],
        recoveriesAfterRest: [],
        trend: null,
        consecutiveBelowBaseline: 0,
        consecutiveAboveBaseline: 0,
        consecutiveRestDays: 0,
        nearestMatch: null,
        lastPerformDate: null,
        daysSincePerform: null,
        lastRestDate: null,
        daysSinceRest: null,
        isVolatile: false,
        isStable: false,
        isTravel: false,
        weekendSplit: null,
        weakDay: null,
        strongDay: null,
        declineTrend: null,
        baselineShift: null,
        effectiveToday,
      };

      // Trend analysis
      const recent = withZScores.slice(-5);
      if (recent.length >= 3) {
        let rising = 0, falling = 0;
        for (let i = 1; i < recent.length; i++) {
          if (recent[i].zScore > recent[i-1].zScore) rising++;
          else if (recent[i].zScore < recent[i-1].zScore) falling++;
        }
        patterns.trend = rising >= 3 ? 'rising' : falling >= 3 ? 'falling' : 'stable';
      }

      // Declining trend (4+ days)
      if (recent.length >= 4) {
        let declining = true;
        for (let i = 1; i < recent.length && declining; i++) {
          if (recent[i].value >= recent[i-1].value) declining = false;
        }
        if (declining) {
          patterns.declineTrend = { days: recent.length, values: recent.map(r => r.value), drop: recent[0].value - recent[recent.length - 1].value };
        }
      }

      // Consecutive tracking
      const reversed = [...withZScores].reverse();
      for (const h of reversed) { if (h.zScore < 0) patterns.consecutiveBelowBaseline++; else break; }
      for (const h of reversed) { if (h.zScore > 0) patterns.consecutiveAboveBaseline++; else break; }
      for (const h of reversed) { if (h.command === 'REST') patterns.consecutiveRestDays++; else break; }

      // Last PERFORM/REST
      const performDays = withZScores.filter(h => h.command === 'PERFORM');
      if (performDays.length > 0) {
        const last = performDays[performDays.length - 1];
        patterns.lastPerformDate = last.date;
        patterns.daysSincePerform = Math.floor((new Date(effectiveToday) - new Date(last.date)) / (1000 * 60 * 60 * 24));
      }
      const restDaysHistory = withZScores.filter(h => h.command === 'REST');
      if (restDaysHistory.length > 0) {
        const last = restDaysHistory[restDaysHistory.length - 1];
        patterns.lastRestDate = last.date;
        patterns.daysSinceRest = Math.floor((new Date(effectiveToday) - new Date(last.date)) / (1000 * 60 * 60 * 24));
      }

      // Compliance outcomes
      complianceLog.forEach(log => {
        if (!log.command || !log.followed) return;
        const nextDate = new Date(log.date);
        nextDate.setDate(nextDate.getDate() + 1);
        const nextDateStr = getLocalDateString(nextDate);
        const nextDay = withZScores.find(h => h.date === nextDateStr);
        if (!nextDay) return;
        
        if (log.command === 'REST' && log.followed === 'no' && nextDay.zScore < THRESHOLDS.REST) {
          patterns.crashesAfterIgnoredRest.push({ ignoredDate: log.date, crashDate: nextDateStr });
        }
        if (log.command === 'REST' && log.followed === 'yes' && nextDay.zScore >= THRESHOLDS.REST) {
          patterns.recoveriesAfterRest.push({ restDate: log.date, readyDate: nextDateStr });
        }
      });

      // Volatility & Travel
      const zScoreStd = Math.sqrt(withZScores.reduce((sum, h) => sum + Math.pow(h.zScore, 2), 0) / withZScores.length);
      patterns.isVolatile = zScoreStd > 1.5;
      patterns.isStable = zScoreStd < 0.8;

      const recent3 = withZScores.slice(-3);
      if (recent3.length >= 3) {
        const recent3Zs = recent3.map(h => h.zScore);
        patterns.isTravel = Math.max(...recent3Zs) - Math.min(...recent3Zs) > 2.5;
      }

      // Day-of-week patterns
      const dayOfWeekStats = {};
      withZScores.forEach(h => {
        const dow = new Date(h.date).getDay();
        if (!dayOfWeekStats[dow]) dayOfWeekStats[dow] = { sum: 0, count: 0 };
        dayOfWeekStats[dow].sum += h.zScore;
        dayOfWeekStats[dow].count++;
      });
      
      const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      let worstDay = null, worstAvg = Infinity, bestDay = null, bestAvg = -Infinity;
      
      Object.entries(dayOfWeekStats).forEach(([dow, stats]) => {
        if (stats.count >= 2) {
          const avg = stats.sum / stats.count;
          if (avg < worstAvg) { worstAvg = avg; worstDay = parseInt(dow); }
          if (avg > bestAvg) { bestAvg = avg; bestDay = parseInt(dow); }
        }
      });
      
      if (worstDay !== null && worstAvg < -0.3) patterns.weakDay = { day: dayNames[worstDay], avgZ: worstAvg };
      if (bestDay !== null && bestAvg > 0.3) patterns.strongDay = { day: dayNames[bestDay], avgZ: bestAvg };

      // Weekend split
      const weekdayValues = withZScores.filter(h => { const d = new Date(h.date).getDay(); return d >= 1 && d <= 5; }).map(h => h.value);
      const weekendValues = withZScores.filter(h => { const d = new Date(h.date).getDay(); return d === 0 || d === 6; }).map(h => h.value);
      
      if (weekdayValues.length >= 3 && weekendValues.length >= 2) {
        const weekdayMean = weekdayValues.reduce((a, b) => a + b, 0) / weekdayValues.length;
        const weekendMean = weekendValues.reduce((a, b) => a + b, 0) / weekendValues.length;
        const spread = weekendMean - weekdayMean;
        if (Math.abs(spread) >= 3) {
          patterns.weekendSplit = { weekdayMean: Math.round(weekdayMean), weekendMean: Math.round(weekendMean), spread: Math.round(spread) };
        }
      }

      // Baseline shift
      if (effectiveHistory.length >= 60) {
        const first14 = withZScores.slice(0, 14).map(h => h.value);
        const last14 = withZScores.slice(-14).map(h => h.value);
        const firstBaseline = first14.reduce((a, b) => a + b, 0) / first14.length;
        const lastBaseline = last14.reduce((a, b) => a + b, 0) / last14.length;
        const shift = lastBaseline - firstBaseline;
        const shiftPercent = Math.round((shift / firstBaseline) * 100);
        if (Math.abs(shiftPercent) >= 5) {
          patterns.baselineShift = { from: Math.round(firstBaseline), to: Math.round(lastBaseline), percent: shiftPercent };
        }
      }

      return patterns;
    };

    // ============================================
    // CONFIDENCE & MODE
    // ============================================
    const calculateConfidence = (hrvHistory, patterns, complianceLog = []) => {
      if (!patterns || hrvHistory.length < 14) return { level: 'low', score: 30 };
      
      const todayEntry = hrvHistory.find(h => h.date === patterns.effectiveToday);
      let signalScore = todayEntry && patterns.baseline ? (Math.abs((todayEntry.value - patterns.baseline) / patterns.mad) >= 1.5 ? 45 : 30) : 15;
      let qualityScore = hrvHistory.length >= 30 ? 25 : hrvHistory.length >= 21 ? 20 : 15;
      let supportScore = patterns.nearestMatch ? 12 : 5;
      
      const totalScore = signalScore + qualityScore + supportScore;
      let level = totalScore >= 75 ? 'high' : totalScore >= 50 ? 'medium' : 'low';
      if (patterns.isVolatile && level === 'high') level = 'medium';
      if (patterns.isTravel) level = 'low';
      
      return { level, score: totalScore };
    };

    const getMode = (confidence, complianceLog, daysOnApp) => {
      if (confidence.level === 'low' || daysOnApp < 14) return 'UNCERTAIN';
      const sevenDaysAgo = new Date(); sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
      const recentOverrides = complianceLog.filter(log => new Date(log.date) >= sevenDaysAgo && log.followed === 'no').length;
      if (recentOverrides >= 2) return 'PROTECTIVE';
      return 'DIRECTIVE';
    };

    // ============================================
    // OBSERVATION GENERATOR
    // ============================================
    const generateObservation = (command, patterns, daysOnApp, hrvHistory, complianceLog = []) => {
      const seed = new Date().getDate();
      const pick = (arr) => arr[seed % arr.length];
      
      if (!patterns) {
        const daysRemaining = 4 - hrvHistory.length;
        return { text: daysRemaining > 0 ? `${daysRemaining} days until commands unlock.` : "Baseline forming.", type: 'learning' };
      }

      const confidence = calculateConfidence(hrvHistory, patterns, complianceLog);
      const mode = getMode(confidence, complianceLog, daysOnApp);
      const crashCount = patterns.crashesAfterIgnoredRest?.length || 0;
      const canPersonalize = daysOnApp >= 14 && confidence.level !== 'low';

      if (patterns.isTravel) return { text: "Signal disrupted. Timezone, travel, or major change detected.", type: 'travel' };

      if (command === 'REST') {
        if (canPersonalize && crashCount >= 2) return { text: `${crashCount} times you've pushed through REST. ${crashCount} times you paid.`, type: 'rest_proof' };
        if (patterns.consecutiveRestDays >= 2) return { text: `Day ${patterns.consecutiveRestDays}. The adaptation is deepening.`, type: 'rest_streak' };
        if (mode === 'PROTECTIVE') return pick([
          { text: "You feel fine. The trend says otherwise.", type: 'rest_protective' },
          { text: "The body doesn't send alerts. It just keeps sliding until it hands you the bill.", type: 'rest_protective' }
        ]);
        return pick([
          { text: "The work is done. Now the building happens.", type: 'rest_directive' },
          { text: "You stressed the system. Now it adapts.", type: 'rest_directive' },
          { text: "Not a setback. A setup.", type: 'rest_directive' }
        ]);
      }

      if (command === 'BUILD') {
        if (mode === 'DIRECTIVE') return pick([
          { text: "Room to work. Not room to be reckless.", type: 'build_directive' },
          { text: "Middle of your range. Solid work is available.", type: 'build_directive' },
          { text: "Enough for quality. Not enough for ego.", type: 'build_directive' }
        ]);
        return { text: "Do what's programmed. Nothing extra.", type: 'build_uncertain' };
      }

      if (command === 'PERFORM') {
        if (canPersonalize && patterns.daysSincePerform >= 7) {
          return { text: `First green light in ${patterns.daysSincePerform} days. The drought is over.`, type: 'perform_rarity' };
        }
        return pick([
          { text: "The tank is full. This is what you've been building toward.", type: 'perform_directive' },
          { text: "Green light. No caveats.", type: 'perform_directive' },
          { text: "Capacity is peaking. Use it. You can't save it.", type: 'perform_directive' }
        ]);
      }
      
      return { text: "Baseline forming.", type: 'learning' };
    };

    // ============================================
    // ACTION GENERATOR
    // ============================================
    const generateActions = (command, patterns, hrvHistory, complianceLog = [], daysOnApp = 0) => {
      if (!patterns || hrvHistory.length < 7) return null;
      
      const confidence = calculateConfidence(hrvHistory, patterns, complianceLog);
      const isWarning = patterns.trend === 'falling' || confidence.level === 'low';

      if (patterns.isTravel) {
        return {
          primaryAction: "Walk in sunlight for 20-30 minutes. That's your only job today.",
          effortBoundary: "Walking pace only. Tourist pace.",
          recoveryLever: "Hydrate aggressively. Sleep when tired.",
          guardrail: "Don't try to shake off jet lag with a workout. The bill comes in 48 hours."
        };
      }

      if (command === 'REST') {
        return isWarning ? {
          primaryAction: "10-20 minute walk. 10 minutes stretching. That's the whole day.",
          effortBoundary: "Conversation pace. If you can't speak in full sentences, slow down. RPE 2.",
          recoveryLever: "In bed 30-60 minutes earlier than usual. This is the lever.",
          guardrail: "Restlessness is a feeling, not a command."
        } : {
          primaryAction: "20-30 minutes easy movement. Walk, stretch, foam roll.",
          effortBoundary: "Nose-breath only. If you need your mouth, slow down. RPE 2-3.",
          recoveryLever: "Water before coffee. Protein at every meal. Protect an 8-hour sleep window.",
          guardrail: "No 'just a quick one.' That's how rest days become debt."
        };
      }

      if (command === 'BUILD') {
        return isWarning ? {
          primaryAction: "Same workout. Pull one lever back 20%: lighter load, fewer reps, or shorter time cap.",
          effortBoundary: "RPE 6 ceiling. When form breaks, rack it.",
          recoveryLever: "In bed 30 minutes earlier than usual.",
          guardrail: "A shortened session is a win. A crash is a week lost."
        } : {
          primaryAction: "Programmed work only. Skip the finisher. Leave 10 minutes early.",
          effortBoundary: "RPE 7 cap. Finish feeling like you could do a little more.",
          recoveryLever: "Protein within 2 hours. Protect 7-8 hours sleep.",
          guardrail: "Don't turn a BUILD day into a PERFORM day. They have different purposes."
        };
      }

      if (command === 'PERFORM') {
        return {
          primaryAction: "Your hard effort goes in the first 20 minutes. Then coast.",
          effortBoundary: "RPE 8-9 for one effort. Leave a rep in reserve. Then drop to 6-7.",
          recoveryLever: "Refuel within 60 minutes. Protect an 8-hour sleep window.",
          guardrail: "Don't turn a great day into a two-day hangover. One peak. Then done."
        };
      }

      return null;
    };

    // ============================================
    // IMPOSSIBLE INSIGHTS (Full Library)
    // ============================================
    const getImpossibleInsight = (daysOnApp, patterns, complianceLog, hrvHistory) => {
      if (!patterns) return null;

      // Day 7: Weekend Split
      if (daysOnApp === 7 && patterns.weekendSplit) {
        return {
          label: 'YOUR FIRST WEEK',
          lines: [
            `Monday through Friday: ${patterns.weekendSplit.weekdayMean}.`,
            `Saturday and Sunday: ${patterns.weekendSplit.weekendMean}.`,
            '', 'You are not the same person on weekends.', '',
            "You've never noticed this.", 'How could you?', "You can't feel a weekly average.", '',
            "But it's been true your whole life.", 'Now you know.'
          ]
        };
      }

      // Day 10-12: Declining Trend
      if (daysOnApp >= 10 && daysOnApp <= 12 && patterns.declineTrend) {
        return {
          label: 'WHAT YOU CAN\'T FEEL',
          lines: [
            ...patterns.declineTrend.values.map((v, i) => `Day ${daysOnApp - patterns.declineTrend.days + i + 1}: ${v}`),
            '', 'You felt fine on each of those days.', '',
            "The body doesn't argue.", "It doesn't complain.", 'It just keeps score.', '',
            'And then one morning it hands you the bill.'
          ]
        };
      }

      // Day 14: Day-of-Week Pattern
      if (daysOnApp === 14 && (patterns.weakDay || patterns.strongDay)) {
        const lines = [];
        if (patterns.weakDay && patterns.strongDay) {
          lines.push(`Your lowest days: ${patterns.weakDay.day}s.`, `Your highest days: ${patterns.strongDay.day}s.`);
        } else if (patterns.weakDay) {
          lines.push(`Your ${patterns.weakDay.day}s consistently drag.`);
        } else {
          lines.push(`Your ${patterns.strongDay.day}s consistently peak.`);
        }
        return {
          label: 'YOUR SECOND SECRET',
          lines: [...lines, '', 'This is not random.', 'This is your weekly rhythm.', '',
            'It was there before I started watching.', "It's been there your whole life.", '', 'You just never saw it.']
        };
      }

      // Day 21-25: First Crash Timing
      if (daysOnApp >= 21 && daysOnApp <= 25 && patterns.crashesAfterIgnoredRest?.length >= 1) {
        return {
          label: 'HOW CRASHES WORK',
          lines: ['The crash did not happen today.', 'It happened three days ago.', '',
            'Today is when your body', 'stopped hiding it from you.', '',
            'The cause is always days before the symptom.', '',
            "Now you've seen it once.", "You'll recognize the setup next time."]
        };
      }

      // Day 30: The Mirror
      if (daysOnApp === 30) {
        const restIssued = complianceLog.filter(c => c.command === 'REST').length;
        const restFollowed = complianceLog.filter(c => c.command === 'REST' && c.followed === 'yes').length;
        const daysAbove = hrvHistory.filter(h => (h.value - patterns.baseline) / patterns.mad >= 0).length;
        
        return {
          label: 'ONE MONTH',
          lines: [`REST commands: ${restIssued}`, `Followed: ${restFollowed}`, '',
            `Days above baseline: ${daysAbove}`, `Days below baseline: ${hrvHistory.length - daysAbove}`, '',
            patterns.crashesAfterIgnoredRest?.length > 0 ? 'The times REST was skipped all preceded your lowest stretches.' : '',
            patterns.recoveriesAfterRest?.length > 0 ? 'The times REST was followed all preceded climbs.' : '',
            '', 'The pattern is already clear.'].filter(l => l)
        };
      }

      // Day 45-50: Pattern Vindication
      if (daysOnApp >= 45 && daysOnApp <= 50 && patterns.recoveriesAfterRest?.length >= 2 && patterns.crashesAfterIgnoredRest?.length >= 1) {
        const recovery = patterns.recoveriesAfterRest[patterns.recoveriesAfterRest.length - 1];
        const crash = patterns.crashesAfterIgnoredRest[0];
        return {
          label: 'SAME PATTERN. DIFFERENT ENDING.',
          lines: [`This looked like ${formatDateAnchor(crash.ignoredDate)}.`, 'Same slope. Same setup.', '',
            'Last time, rest was skipped.', `${formatDateAnchor(crash.crashDate)}: crashed.`, '',
            'This time, rest happened.', `${formatDateAnchor(recovery.readyDate)}: climbing.`, '',
            'Same film. Different ending.', '', 'The ending was always a choice.']
        };
      }

      // Day 60: Baseline Shift
      if (daysOnApp === 60 && patterns.baselineShift) {
        const { from, to, percent } = patterns.baselineShift;
        const direction = percent > 0 ? 'more' : 'less';
        return {
          label: 'TWO MONTHS',
          lines: [`Your baseline when you started: ${from}.`, `Your baseline now: ${to}.`, '',
            `That's ${Math.abs(percent)}% ${direction} capacity`, 'than the person who walked in.', '',
            percent > 0 ? 'Not from training more.' : '', percent > 0 ? 'From resting better.' : '', '',
            'The capacity was never gone.', 'It was buried under fatigue', "you didn't know you were carrying."].filter(l => l)
        };
      }

      // Day 90: The Switch
      if (daysOnApp === 90) {
        const restFollowed = complianceLog.filter(c => c.command === 'REST' && c.followed === 'yes').length;
        const restSkipped = complianceLog.filter(c => c.command === 'REST' && c.followed === 'no').length;
        const recoveries = patterns.recoveriesAfterRest?.length || 0;
        const crashes = patterns.crashesAfterIgnoredRest?.length || 0;
        
        const followedRate = restFollowed > 0 ? Math.round(recoveries / restFollowed * 100) : 0;
        const skippedRate = restSkipped > 0 ? Math.round(crashes / restSkipped * 100) : 0;
        
        return {
          label: 'NINETY DAYS',
          lines: [`When REST is followed: ${followedRate}% climb the next day.`,
            `When REST is skipped: ${skippedRate}% crash within 72 hours.`, '',
            "That's not a correlation.", "That's a switch.", '',
            'The body has been running this experiment', 'your whole life.', '',
            'Rest ‚Üí rise.', 'Push through ‚Üí fall.', '',
            'You just never had a translator', 'to show you the results.', '', 'Now you do.']
        };
      }

      // Day 180: Identity Shift
      if (daysOnApp === 180) {
        return {
          label: 'SIX MONTHS',
          lines: ['You have outlasted most people', 'who start tracking recovery.', '',
            "Most quit because they couldn't rest", 'when the number said rest.', '',
            'The story was too loud.', '"I feel fine."', '"Rest is weakness."', '',
            'You heard the same story.', 'You just stopped letting it decide.', '',
            "That's the only difference."]
        };
      }

      // Day 365: The Full Translation
      if (daysOnApp === 365) {
        const lines = ['Here is what I learned about you:', ''];
        if (patterns.recoveriesAfterRest?.length > patterns.crashesAfterIgnoredRest?.length) lines.push('When you rest, you rise.');
        if (patterns.weakDay) lines.push(`Your ${patterns.weakDay.day}s need protecting.`);
        if (patterns.strongDay) lines.push(`Your ${patterns.strongDay.day}s are your peak.`);
        if (patterns.weekendSplit?.spread > 5) lines.push('Weekends restore you.');
        
        lines.push('', 'None of this was hidden.', 'It was all there, every day, for your entire life.', '',
          'You just needed someone to read it to you', 'until you learned to read it yourself.', '',
          'You can read it now.', '', 'The signal was never the treasure.', 'The treasure was learning to hear it.');
        
        return { label: 'ONE YEAR', lines };
      }

      return null;
    };

    // ============================================
    // MILESTONE DEFINITIONS FOR PREVIEW
    // ============================================
    const MILESTONES = [
      { day: 7, label: 'Weekend Split', condition: (p) => !!p?.weekendSplit },
      { day: 10, label: 'Trend Truth', condition: (p) => !!p?.declineTrend },
      { day: 14, label: 'Day-of-Week Pattern', condition: (p) => !!(p?.weakDay || p?.strongDay) },
      { day: 21, label: 'Crash Timing', condition: (p) => (p?.crashesAfterIgnoredRest?.length || 0) >= 1 },
      { day: 30, label: 'The Mirror', condition: () => true },
      { day: 45, label: 'Pattern Vindication', condition: (p) => (p?.recoveriesAfterRest?.length || 0) >= 2 && (p?.crashesAfterIgnoredRest?.length || 0) >= 1 },
      { day: 60, label: 'Baseline Shift', condition: (p) => !!p?.baselineShift },
      { day: 90, label: 'The Switch', condition: () => true },
      { day: 180, label: 'Identity Shift', condition: () => true },
      { day: 365, label: 'Full Translation', condition: () => true },
    ];

    // ============================================
    // UI COMPONENTS
    // ============================================
    const CommandWord = ({ command, onClick, isRevealed }) => {
      const colors = { REST: '#FDA4AF', BUILD: '#C9A962', PERFORM: '#6EE7B7', LEARNING: '#A1A1AA' };
      return (
        <div className={`text-center cursor-pointer transition-all duration-500 ${isRevealed ? 'pt-4' : 'pt-16'}`} onClick={onClick}>
          <h1 className={`font-display animate-rise ${isRevealed ? 'text-3xl' : 'text-6xl'}`} style={{ color: colors[command], transition: 'font-size 500ms ease' }}>
            {command}
          </h1>
          {!isRevealed && <p className="text-sm mt-6 animate-fade delay-1000" style={{ color: 'var(--text-muted)', opacity: 0.4 }}>touch to understand</p>}
        </div>
      );
    };

    const Observation = ({ text }) => (
      <div className="text-center px-6 animate-rise">
        <p className="text-sm leading-relaxed" style={{ color: 'var(--text-secondary)', lineHeight: 1.8 }}>{text}</p>
      </div>
    );

    const Prescription = ({ actions }) => {
      if (!actions) return null;
      return (
        <div className="px-6 space-y-4 animate-rise delay-200">
          <div className="divider" />
          <div className="space-y-3">
            {[actions.primaryAction, actions.effortBoundary, actions.recoveryLever].map((text, i) => (
              <div key={i} className="flex items-start gap-2">
                <span className="mt-1.5 block w-1 h-1 rounded-full flex-shrink-0" style={{ backgroundColor: 'var(--gold)' }} />
                <p className="text-xs leading-relaxed" style={{ color: i === 0 ? 'var(--text-secondary)' : 'var(--text-muted)' }}>{text}</p>
              </div>
            ))}
          </div>
          <div className="divider" />
          <div className="flex items-start gap-2">
            <span style={{ color: 'var(--rose)', fontSize: '12px' }}>‚ö†</span>
            <p className="text-xs leading-relaxed" style={{ color: 'var(--rose)', opacity: 0.8 }}>{actions.guardrail}</p>
          </div>
        </div>
      );
    };

    const InsightBlock = ({ insight }) => {
      if (!insight) return null;
      return (
        <div className="insight-block animate-rise delay-300 mt-6 mx-6">
          <div className="label">{insight.label}</div>
          <div className="content text-xs">
            {insight.lines.map((line, i) => <React.Fragment key={i}>{line || <br />}{line && i < insight.lines.length - 1 && <br />}</React.Fragment>)}
          </div>
        </div>
      );
    };

    const HRVInput = ({ value, onChange, onSubmit }) => (
      <div className="space-y-4 animate-rise">
        <div className="text-center">
          <p className="text-xs mb-2" style={{ color: 'var(--text-muted)' }}>HRV this morning</p>
        </div>
        <input type="number" value={value} onChange={(e) => onChange(e.target.value)} onKeyDown={(e) => e.key === 'Enter' && onSubmit()} placeholder="ms" className="input-minimal text-2xl font-display" autoFocus />
        <button onClick={onSubmit} disabled={!value} className="btn-primary text-sm" style={{ opacity: value ? 1 : 0.3, borderColor: value ? 'var(--gold)' : 'var(--text-faint)', color: value ? 'var(--gold)' : 'var(--text-muted)', padding: '12px 24px' }}>Log</button>
      </div>
    );

    // ============================================
    // TEST PANEL
    // ============================================
    const TestPanel = ({ hrvHistory, patterns, daysOnApp, simulatedDay, onLoadTestData, onLoadCSV, onAddTodayHRV, onClear, onSimulateDay, complianceLog }) => {
      const [expanded, setExpanded] = useState(true);
      const [testHRV, setTestHRV] = useState('50');
      const [showArc, setShowArc] = useState(false);
      const fileInputRef = useRef(null);
      
      const handleFileChange = (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              const history = parseCSV(event.target.result);
              onLoadCSV(history);
            } catch (err) {
              alert('Error parsing CSV: ' + err.message);
            }
          };
          reader.readAsText(file);
        }
      };

      const getSimulatedPatterns = (day) => {
        if (hrvHistory.length < day) return null;
        return analyzePatterns(hrvHistory, complianceLog, hrvHistory[0]?.date, day - 1);
      };

      return (
        <div className="test-panel">
          <div className="test-panel-header">
            <div className="flex items-center gap-2">
              <span className="text-xs font-semibold" style={{ color: 'var(--amber)' }}>TEST MODE</span>
              <span className="text-xs" style={{ color: 'var(--text-muted)' }}>
                {hrvHistory.length}d | Œº{Math.round(patterns?.baseline || 0)} | Day {simulatedDay || daysOnApp}
              </span>
            </div>
            <button onClick={() => setExpanded(!expanded)} className="text-xs" style={{ color: 'var(--amber)' }}>
              {expanded ? '‚ñº' : '‚ñ≤'}
            </button>
          </div>
          
          {expanded && (
            <div className="test-panel-content space-y-3">
              {/* Quick Load Buttons */}
              <div className="flex flex-wrap gap-2">
                <button onClick={() => onLoadTestData(7)} className="btn-test">7d</button>
                <button onClick={() => onLoadTestData(14)} className="btn-test">14d</button>
                <button onClick={() => onLoadTestData(30)} className="btn-test">30d</button>
                <button onClick={() => onLoadTestData(90)} className="btn-test">90d</button>
                <button onClick={() => onLoadTestData(180)} className="btn-test">180d</button>
                <button onClick={() => onLoadTestData(365)} className="btn-test">365d</button>
                <button onClick={() => fileInputRef.current?.click()} className="btn-test" style={{ borderColor: 'var(--green)', color: 'var(--green)' }}>
                  üìÅ Import CSV
                </button>
                <input ref={fileInputRef} type="file" accept=".csv" onChange={handleFileChange} />
              </div>

              {/* Manual HRV Entry */}
              <div className="flex gap-2 items-center">
                <input type="number" value={testHRV} onChange={(e) => setTestHRV(e.target.value)} className="w-16 px-2 py-1 text-xs rounded" style={{ background: 'var(--bg-elevated)', border: '1px solid var(--text-faint)', color: 'var(--text-primary)' }} />
                <button onClick={() => onAddTodayHRV(parseInt(testHRV))} className="btn-test">Add Today</button>
                <button onClick={onClear} className="btn-test" style={{ borderColor: 'var(--rose)', color: 'var(--rose)' }}>Clear All</button>
              </div>

              {/* Day Simulation Slider */}
              {hrvHistory.length > 0 && (
                <div className="space-y-2">
                  <div className="flex justify-between items-center">
                    <span className="text-xs" style={{ color: 'var(--text-muted)' }}>Simulate Day:</span>
                    <span className="text-xs font-mono" style={{ color: 'var(--amber)' }}>{simulatedDay || hrvHistory.length}</span>
                  </div>
                  <input type="range" min="1" max={hrvHistory.length} value={simulatedDay || hrvHistory.length} onChange={(e) => onSimulateDay(parseInt(e.target.value))}
                    className="w-full" style={{ accentColor: 'var(--amber)' }} />
                  <div className="flex gap-2 flex-wrap">
                    {[7, 14, 21, 30, 45, 60, 90, 180, 365].filter(d => d <= hrvHistory.length).map(day => (
                      <button key={day} onClick={() => onSimulateDay(day)} className={`btn-test ${simulatedDay === day ? 'active' : ''}`}>Day {day}</button>
                    ))}
                    <button onClick={() => onSimulateDay(null)} className={`btn-test ${!simulatedDay ? 'active' : ''}`}>Today</button>
                  </div>
                </div>
              )}

              {/* Story Arc Preview */}
              <div>
                <button onClick={() => setShowArc(!showArc)} className="btn-test w-full" style={{ borderColor: 'var(--gold)', color: 'var(--gold)' }}>
                  {showArc ? '‚ñº Hide' : '‚ñ∂ Show'} Story Arc Preview
                </button>
                
                {showArc && (
                  <div className="story-arc-preview mt-2">
                    <div className="text-xs font-semibold mb-2" style={{ color: 'var(--gold)' }}>IMPOSSIBLE INSIGHTS TIMELINE</div>
                    {MILESTONES.map(milestone => {
                      const effectiveDay = simulatedDay || daysOnApp;
                      const isActive = effectiveDay === milestone.day;
                      const isPast = effectiveDay > milestone.day;
                      const isFuture = effectiveDay < milestone.day;
                      const simPatterns = getSimulatedPatterns(milestone.day);
                      const willTrigger = milestone.day <= hrvHistory.length && milestone.condition(simPatterns);
                      
                      return (
                        <div key={milestone.day} className={`milestone-item ${isActive ? 'active' : isPast ? 'past' : 'future'}`}>
                          <div className="flex items-center gap-2">
                            <span className="text-xs font-mono w-8">D{milestone.day}</span>
                            <span className="text-xs">{milestone.label}</span>
                          </div>
                          <div className="flex items-center gap-2">
                            {willTrigger ? (
                              <span className="text-xs" style={{ color: 'var(--green)' }}>‚úì</span>
                            ) : milestone.day <= hrvHistory.length ? (
                              <span className="text-xs" style={{ color: 'var(--rose)' }}>‚úó</span>
                            ) : (
                              <span className="text-xs" style={{ color: 'var(--text-faint)' }}>‚Äî</span>
                            )}
                            <button onClick={() => onSimulateDay(milestone.day)} className="btn-test text-xs py-1 px-2" disabled={milestone.day > hrvHistory.length}>
                              Jump
                            </button>
                          </div>
                        </div>
                      );
                    })}
                  </div>
                )}
              </div>

              {/* Current Patterns Debug */}
              {patterns && (
                <div className="text-xs space-y-1 p-2 rounded" style={{ background: 'var(--bg-elevated)', color: 'var(--text-muted)' }}>
                  <div className="font-semibold" style={{ color: 'var(--amber)' }}>Current Patterns:</div>
                  <div>Baseline: {Math.round(patterns.baseline)} | MAD: {patterns.mad?.toFixed(1)}</div>
                  <div>Trend: {patterns.trend} | Volatile: {patterns.isVolatile ? 'Y' : 'N'} | Travel: {patterns.isTravel ? 'Y' : 'N'}</div>
                  <div>REST: {patterns.restDays} | BUILD: {patterns.buildDays} | PERFORM: {patterns.performDays}</div>
                  {patterns.weekendSplit && <div>Weekend Split: +{patterns.weekendSplit.spread}ms</div>}
                  {patterns.weakDay && <div>Weak Day: {patterns.weakDay.day}</div>}
                  {patterns.strongDay && <div>Strong Day: {patterns.strongDay.day}</div>}
                  {patterns.baselineShift && <div>Baseline Shift: {patterns.baselineShift.percent}%</div>}
                  <div>Crashes: {patterns.crashesAfterIgnoredRest?.length || 0} | Recoveries: {patterns.recoveriesAfterRest?.length || 0}</div>
                </div>
              )}
            </div>
          )}
        </div>
      );
    };

    // ============================================
    // MAIN APPLICATION
    // ============================================
    const App = () => {
      const [hrvHistory, setHrvHistory] = useState([]);
      const [complianceLog, setComplianceLog] = useState([]);
      const [firstUseDate, setFirstUseDate] = useState(null);
      const [isLoading, setIsLoading] = useState(true);
      
      const [todayHRV, setTodayHRV] = useState('');
      const [isRevealed, setIsRevealed] = useState(false);
      const [simulatedDay, setSimulatedDay] = useState(null);

      useEffect(() => {
        try {
          const saved = localStorage.getItem('genysys_v2_test_data');
          if (saved) {
            const data = JSON.parse(saved);
            setHrvHistory(data.hrvHistory || []);
            setComplianceLog(data.complianceLog || []);
            setFirstUseDate(data.firstUseDate);
          }
        } catch (e) { console.error(e); }
        setIsLoading(false);
      }, []);

      const saveData = useCallback((updates = {}) => {
        const data = { hrvHistory, complianceLog, firstUseDate, ...updates };
        localStorage.setItem('genysys_v2_test_data', JSON.stringify(data));
      }, [hrvHistory, complianceLog, firstUseDate]);

      const today = getTodayLocal();
      const todayEntry = hrvHistory.find(h => h.date === today);
      
      // Calculate effective day for simulation
      const effectiveDaysOnApp = simulatedDay || (firstUseDate ? Math.floor((new Date() - new Date(firstUseDate)) / (1000 * 60 * 60 * 24)) + 1 : hrvHistory.length || 1);
      
      // Get patterns for current or simulated day
      const patterns = useMemo(() => analyzePatterns(hrvHistory, complianceLog, firstUseDate, simulatedDay ? simulatedDay - 1 : null), [hrvHistory, complianceLog, firstUseDate, simulatedDay]);
      
      // Get effective today's entry (for simulation)
      const effectiveTodayEntry = simulatedDay && hrvHistory.length >= simulatedDay ? hrvHistory[simulatedDay - 1] : todayEntry;

      const result = useMemo(() => {
        if (!effectiveTodayEntry || !patterns) {
          return { commandKey: 'LEARNING', isPreview: true, daysUntilFull: Math.max(0, 7 - (simulatedDay || hrvHistory.length)) };
        }
        const zScore = (effectiveTodayEntry.value - patterns.baseline) / patterns.mad;
        return { commandKey: getCommandKey(zScore), zScore, isPreview: (simulatedDay || hrvHistory.length) < 7 };
      }, [effectiveTodayEntry, patterns, simulatedDay, hrvHistory.length]);

      const observation = useMemo(() => generateObservation(result?.commandKey, patterns, effectiveDaysOnApp, hrvHistory.slice(0, simulatedDay || hrvHistory.length), complianceLog), [result?.commandKey, patterns, effectiveDaysOnApp, hrvHistory, simulatedDay, complianceLog]);
      const actions = useMemo(() => generateActions(result?.commandKey, patterns, hrvHistory.slice(0, simulatedDay || hrvHistory.length), complianceLog, effectiveDaysOnApp), [result?.commandKey, patterns, hrvHistory, simulatedDay, complianceLog, effectiveDaysOnApp]);
      const insight = useMemo(() => getImpossibleInsight(effectiveDaysOnApp, patterns, complianceLog, hrvHistory.slice(0, simulatedDay || hrvHistory.length)), [effectiveDaysOnApp, patterns, complianceLog, hrvHistory, simulatedDay]);

      // Handlers
      const handleLoadTestData = (days) => {
        const { history, compliance } = generateTestData(days);
        const firstDate = history[0]?.date || getTodayLocal();
        setHrvHistory(history);
        setComplianceLog(compliance);
        setFirstUseDate(firstDate);
        setSimulatedDay(null);
        setIsRevealed(false);
        saveData({ hrvHistory: history, complianceLog: compliance, firstUseDate: firstDate });
      };

      const handleLoadCSV = (history) => {
        // Generate compliance data for REST days
        const compliance = [];
        const values = history.map(h => h.value);
        const median = calculateMedian(values);
        const mad = calculateMAD(values, median);
        
        history.forEach((h, i) => {
          if (i === 0) return;
          const zScore = (h.value - median) / mad;
          if (getCommandKey(zScore) === 'REST' && Math.random() > 0.2) {
            compliance.push({ date: h.date, command: 'REST', followed: Math.random() > 0.35 ? 'yes' : 'no' });
          }
        });
        
        const firstDate = history[0]?.date;
        setHrvHistory(history);
        setComplianceLog(compliance);
        setFirstUseDate(firstDate);
        setSimulatedDay(null);
        setIsRevealed(false);
        saveData({ hrvHistory: history, complianceLog: compliance, firstUseDate: firstDate });
      };

      const handleAddTodayHRV = (value) => {
        if (isNaN(value) || value < 1) return;
        const newHistory = [...hrvHistory.filter(h => h.date !== today), { date: today, value }];
        if (!firstUseDate) setFirstUseDate(today);
        setHrvHistory(newHistory);
        setIsRevealed(false);
        saveData({ hrvHistory: newHistory, firstUseDate: firstUseDate || today });
      };

      const handleClear = () => {
        setHrvHistory([]);
        setComplianceLog([]);
        setFirstUseDate(null);
        setSimulatedDay(null);
        setIsRevealed(false);
        localStorage.removeItem('genysys_v2_test_data');
      };

      const handleLogHRV = () => {
        const value = parseInt(todayHRV);
        if (isNaN(value) || value < 1) return;
        handleAddTodayHRV(value);
        setTodayHRV('');
      };

      if (isLoading) return <div className="min-h-screen flex items-center justify-center" style={{ background: 'var(--bg-primary)' }}><div style={{ color: 'var(--text-muted)' }}>...</div></div>;

      return (
        <div className="min-h-screen pb-64" style={{ background: 'var(--bg-primary)' }}>
          <div className="test-badge">TEST MODE</div>
          
          <div className="max-w-md mx-auto px-6 py-6">
            <header className="flex justify-between items-center mb-6">
              <span className="text-xs tracking-widest" style={{ color: 'var(--gold)', opacity: 0.6 }}>GENYSYS</span>
              <span className="text-xs" style={{ color: 'var(--text-muted)' }}>
                {simulatedDay ? `Simulating Day ${simulatedDay}` : new Date().toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' })}
              </span>
            </header>

            <main>
              {!effectiveTodayEntry && !simulatedDay && (
                <div className="flex items-center justify-center pt-16">
                  <div className="w-full max-w-xs">
                    <HRVInput value={todayHRV} onChange={setTodayHRV} onSubmit={handleLogHRV} />
                  </div>
                </div>
              )}

              {(effectiveTodayEntry || simulatedDay) && (
                <div>
                  <CommandWord command={result?.commandKey || 'LEARNING'} onClick={() => setIsRevealed(true)} isRevealed={isRevealed} />

                  {isRevealed && (
                    <div className="mt-6 space-y-4">
                      {observation && <Observation text={observation.text} />}
                      <Prescription actions={actions} />
                      {insight && <InsightBlock insight={insight} />}
                      {result?.isPreview && (
                        <div className="text-center mt-6">
                          <p className="text-xs" style={{ color: 'var(--text-muted)' }}>
                            {result.daysUntilFull > 0 ? `${result.daysUntilFull} days until personalized guidance.` : 'Baseline forming.'}
                          </p>
                        </div>
                      )}
                    </div>
                  )}
                </div>
              )}
            </main>
          </div>

          <TestPanel
            hrvHistory={hrvHistory}
            patterns={patterns}
            daysOnApp={effectiveDaysOnApp}
            simulatedDay={simulatedDay}
            complianceLog={complianceLog}
            onLoadTestData={handleLoadTestData}
            onLoadCSV={handleLoadCSV}
            onAddTodayHRV={handleAddTodayHRV}
            onClear={handleClear}
            onSimulateDay={setSimulatedDay}
          />
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
