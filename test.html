<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#0A0A0A">
  <title>GENYSYS — TEST MODE</title>
  
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,300;0,400;1,300;1,400&display=swap" rel="stylesheet">
  
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18.2.0/umd/react.production.min.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@babel/standalone@7.23.5/babel.min.js" crossorigin="anonymous"></script>
  
  <style>
    /* ============================================
       DESIGN SYSTEM - Ive/Dye Philosophy
       "The best design is the least design."
       TEST MODE - Additional controls visible
       ============================================ */
    
    :root {
      --bg-primary: #0A0A0A;
      --bg-elevated: #111111;
      --bg-card: #141414;
      --bg-test: #1a1a0a;
      
      --text-primary: #F5F5F0;
      --text-secondary: #A1A1AA;
      --text-muted: #52525B;
      --text-faint: #3F3F46;
      
      --gold: #C9A962;
      --gold-dim: rgba(201, 169, 98, 0.15);
      --green: #6EE7B7;
      --green-dim: rgba(110, 231, 183, 0.08);
      --rose: #FDA4AF;
      --rose-dim: rgba(253, 164, 175, 0.08);
      --amber: #FCD34D;
      
      --font-display: 'Cormorant Garamond', Georgia, serif;
      --font-body: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', Roboto, sans-serif;
      
      --space-xs: 8px;
      --space-sm: 16px;
      --space-md: 24px;
      --space-lg: 32px;
      --space-xl: 48px;
      --margin-screen: 40px;
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    
    body {
      font-family: var(--font-body);
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      min-height: 100dvh;
      line-height: 1.6;
    }
    
    .font-display {
      font-family: var(--font-display);
      font-weight: 300;
      letter-spacing: 0.02em;
    }
    
    @keyframes fadeRise {
      from { opacity: 0; transform: translateY(12px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .animate-rise { animation: fadeRise 400ms ease-out forwards; }
    .animate-fade { animation: fadeIn 400ms ease-out forwards; }
    
    .delay-100 { animation-delay: 100ms; opacity: 0; }
    .delay-200 { animation-delay: 200ms; opacity: 0; }
    .delay-300 { animation-delay: 300ms; opacity: 0; }
    .delay-400 { animation-delay: 400ms; opacity: 0; }
    .delay-500 { animation-delay: 500ms; opacity: 0; }
    .delay-600 { animation-delay: 600ms; opacity: 0; }
    
    .btn-primary {
      background: transparent;
      border: 1px solid var(--text-faint);
      color: var(--text-secondary);
      padding: 16px 32px;
      border-radius: 12px;
      font-size: 15px;
      font-weight: 400;
      cursor: pointer;
      transition: all 150ms ease;
      width: 100%;
    }
    
    .btn-primary:active {
      background: var(--bg-elevated);
      border-color: var(--gold);
      color: var(--gold);
    }
    
    .btn-secondary {
      background: transparent;
      border: none;
      color: var(--text-muted);
      padding: 12px 24px;
      font-size: 13px;
      cursor: pointer;
      transition: color 150ms ease;
    }
    
    .btn-secondary:hover { color: var(--text-secondary); }
    
    .btn-test {
      background: var(--bg-test);
      border: 1px solid var(--amber);
      color: var(--amber);
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 11px;
      cursor: pointer;
      transition: all 150ms ease;
    }
    
    .btn-test:hover {
      background: rgba(252, 211, 77, 0.1);
    }
    
    .input-minimal {
      background: transparent;
      border: 1px solid var(--text-faint);
      border-radius: 12px;
      padding: 16px 20px;
      color: var(--text-primary);
      font-size: 17px;
      font-family: var(--font-body);
      width: 100%;
      text-align: center;
      outline: none;
      transition: border-color 150ms ease;
    }
    
    .input-minimal:focus { border-color: var(--gold); }
    .input-minimal::placeholder { color: var(--text-muted); }
    
    .divider {
      height: 1px;
      background: var(--text-faint);
      opacity: 0.3;
      margin: var(--space-md) 0;
    }
    
    .insight-block {
      border-left: 2px solid var(--gold);
      padding-left: var(--space-md);
      margin-top: var(--space-lg);
      opacity: 0.85;
    }
    
    .insight-block .label {
      font-size: 10px;
      letter-spacing: 0.2em;
      text-transform: uppercase;
      color: var(--text-muted);
      margin-bottom: var(--space-xs);
    }
    
    .insight-block .content {
      font-family: var(--font-display);
      font-style: italic;
      font-size: 15px;
      line-height: 1.8;
      color: var(--text-secondary);
    }
    
    /* TEST MODE PANEL */
    .test-panel {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--bg-test);
      border-top: 1px solid var(--amber);
      padding: 12px 16px;
      z-index: 100;
    }
    
    .test-badge {
      position: fixed;
      top: 8px;
      right: 8px;
      background: var(--amber);
      color: #000;
      font-size: 9px;
      font-weight: 600;
      padding: 4px 8px;
      border-radius: 4px;
      letter-spacing: 0.1em;
      z-index: 100;
    }
    
    ::-webkit-scrollbar { width: 0; }
    
    input[type="date"]::-webkit-calendar-picker-indicator { 
      filter: invert(0.5); 
      cursor: pointer;
    }
    
    input[type="number"]::-webkit-inner-spin-button,
    input[type="number"]::-webkit-outer-spin-button { 
      -webkit-appearance: none; 
      margin: 0; 
    }
    input[type="number"] { -moz-appearance: textfield; }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useMemo, useRef, useCallback } = React;

    // ============================================
    // ANALYTICS (Disabled in TEST mode)
    // ============================================
    const Analytics = {
      init() {},
      setDevice() {},
      track(event, props) { console.log('[TEST Analytics]', event, props); }
    };

    // ============================================
    // UTILITIES
    // ============================================
    const getLocalDateString = (date = new Date()) => {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    };

    const getTodayLocal = () => getLocalDateString();
    
    const getYesterdayLocal = () => {
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      return getLocalDateString(yesterday);
    };

    const getDayName = (dateStr) => {
      const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      return days[new Date(dateStr).getDay()];
    };

    const formatDateAnchor = (dateStr) => {
      if (!dateStr) return null;
      const date = new Date(dateStr + 'T12:00:00');
      const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
      const day = date.getDate();
      const suffix = day === 1 || day === 21 || day === 31 ? 'st' : day === 2 || day === 22 ? 'nd' : day === 3 || day === 23 ? 'rd' : 'th';
      return `${months[date.getMonth()]} ${day}${suffix}`;
    };

    // ============================================
    // TEST DATA GENERATORS
    // ============================================
    const generateTestData = (days, baseHRV = 50, variance = 10) => {
      const history = [];
      const compliance = [];
      const today = new Date();
      
      for (let i = days - 1; i >= 0; i--) {
        const date = new Date(today);
        date.setDate(date.getDate() - i);
        const dateStr = getLocalDateString(date);
        
        // Add some realistic patterns
        const dayOfWeek = date.getDay();
        const weekendBonus = (dayOfWeek === 0 || dayOfWeek === 6) ? 5 : 0;
        const trend = Math.sin(i / 7 * Math.PI) * 5; // weekly cycle
        const noise = (Math.random() - 0.5) * variance;
        
        const value = Math.round(baseHRV + weekendBonus + trend + noise);
        history.push({ date: dateStr, value: Math.max(20, Math.min(100, value)) });
        
        // Add random compliance for REST days
        if (value < baseHRV - variance/2 && i > 0 && Math.random() > 0.3) {
          compliance.push({
            date: dateStr,
            command: 'REST',
            followed: Math.random() > 0.4 ? 'yes' : 'no'
          });
        }
      }
      
      return { history, compliance };
    };

    // ============================================
    // ALGORITHM (unchanged from validated version)
    // ============================================
    const THRESHOLDS = { REST: -1.0, PERFORM: 0.5, MIN_DAYS: 7, MIN_PREVIEW_DAYS: 4, MAD_FLOOR: 3.0 };

    const calculateMedian = (arr) => {
      const sorted = [...arr].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
    };

    const calculateMAD = (arr, median) => {
      const deviations = arr.map(v => Math.abs(v - median)).sort((a, b) => a - b);
      return Math.max(calculateMedian(deviations) * 1.4826, THRESHOLDS.MAD_FLOOR);
    };

    const getCommandKey = (zScore) => {
      if (zScore === null) return 'LEARNING';
      if (zScore < THRESHOLDS.REST) return 'REST';
      if (zScore >= THRESHOLDS.PERFORM) return 'PERFORM';
      return 'BUILD';
    };

    // ============================================
    // PATTERN ENGINE
    // ============================================
    const analyzePatterns = (hrvHistory, complianceLog, firstUseDate) => {
      if (hrvHistory.length < 3) return null;

      const values = hrvHistory.map(h => h.value);
      const median = calculateMedian(values);
      const mad = calculateMAD(values, median);

      const withZScores = hrvHistory.map(h => ({
        ...h,
        zScore: (h.value - median) / mad,
        command: getCommandKey((h.value - median) / mad)
      })).sort((a, b) => new Date(a.date) - new Date(b.date));

      const patterns = {
        baseline: median,
        mad,
        totalDays: hrvHistory.length,
        restDays: withZScores.filter(h => h.command === 'REST').length,
        buildDays: withZScores.filter(h => h.command === 'BUILD').length,
        performDays: withZScores.filter(h => h.command === 'PERFORM').length,
        crashes: [],
        crashesAfterIgnoredRest: [],
        recoveriesAfterRest: [],
        trend: null,
        consecutiveBelowBaseline: 0,
        consecutiveAboveBaseline: 0,
        nearestMatch: null,
        lastPerformDate: null,
        daysSincePerform: null,
        isVolatile: false,
        isStable: false,
      };

      const recent = withZScores.slice(-5);
      if (recent.length >= 3) {
        let rising = 0, falling = 0;
        for (let i = 1; i < recent.length; i++) {
          if (recent[i].zScore > recent[i-1].zScore) rising++;
          else if (recent[i].zScore < recent[i-1].zScore) falling++;
        }
        if (rising >= 3) patterns.trend = 'rising';
        else if (falling >= 3) patterns.trend = 'falling';
        else patterns.trend = 'stable';
      }

      const reversed = [...withZScores].reverse();
      for (const h of reversed) {
        if (h.zScore < 0) patterns.consecutiveBelowBaseline++;
        else break;
      }
      for (const h of reversed) {
        if (h.zScore > 0) patterns.consecutiveAboveBaseline++;
        else break;
      }

      const performDays = withZScores.filter(h => h.command === 'PERFORM');
      if (performDays.length > 0) {
        const lastPerform = performDays[performDays.length - 1];
        patterns.lastPerformDate = lastPerform.date;
        patterns.daysSincePerform = Math.floor(
          (new Date(getTodayLocal()) - new Date(lastPerform.date)) / (1000 * 60 * 60 * 24)
        );
      }

      const restDaysHistory = withZScores.filter(h => h.command === 'REST');
      if (restDaysHistory.length > 0) {
        const lastRest = restDaysHistory[restDaysHistory.length - 1];
        patterns.lastRestDate = lastRest.date;
        patterns.daysSinceRest = Math.floor(
          (new Date(getTodayLocal()) - new Date(lastRest.date)) / (1000 * 60 * 60 * 24)
        );
      }

      if (complianceLog && complianceLog.length > 0) {
        complianceLog.forEach(log => {
          if (!log.command || !log.followed) return;
          
          const nextDate = new Date(log.date);
          nextDate.setDate(nextDate.getDate() + 1);
          const nextDateStr = getLocalDateString(nextDate);
          const nextDay = withZScores.find(h => h.date === nextDateStr);
          
          if (!nextDay) return;
          
          if (log.command === 'REST' && log.followed === 'no') {
            if (nextDay.zScore < THRESHOLDS.REST) {
              patterns.crashesAfterIgnoredRest.push({
                ignoredDate: log.date,
                crashDate: nextDateStr,
                daysLost: 1
              });
            }
          }
          
          if (log.command === 'REST' && log.followed === 'yes') {
            if (nextDay.zScore >= THRESHOLDS.REST) {
              patterns.recoveriesAfterRest.push({
                restDate: log.date,
                readyDate: nextDateStr
              });
            }
          }
        });
      }

      const zScoreStd = Math.sqrt(
        withZScores.reduce((sum, h) => sum + Math.pow(h.zScore, 2), 0) / withZScores.length
      );
      patterns.isVolatile = zScoreStd > 1.5;
      patterns.isStable = zScoreStd < 0.8;

      // Day-of-week pattern detection
      const dayOfWeekStats = {};
      withZScores.forEach(h => {
        const dow = new Date(h.date).getDay();
        if (!dayOfWeekStats[dow]) dayOfWeekStats[dow] = { sum: 0, count: 0 };
        dayOfWeekStats[dow].sum += h.zScore;
        dayOfWeekStats[dow].count++;
      });
      
      const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      let worstDay = null, worstAvg = Infinity;
      let bestDay = null, bestAvg = -Infinity;
      
      Object.entries(dayOfWeekStats).forEach(([dow, stats]) => {
        if (stats.count >= 3) {
          const avg = stats.sum / stats.count;
          if (avg < worstAvg) { worstAvg = avg; worstDay = parseInt(dow); }
          if (avg > bestAvg) { bestAvg = avg; bestDay = parseInt(dow); }
        }
      });
      
      if (worstDay !== null && worstAvg < -0.5) {
        patterns.weakDay = { day: dayNames[worstDay], avgZ: worstAvg };
      }
      if (bestDay !== null && bestAvg > 0.5) {
        patterns.strongDay = { day: dayNames[bestDay], avgZ: bestAvg };
      }

      // Weekend split analysis
      const weekdayValues = withZScores.filter(h => {
        const dow = new Date(h.date).getDay();
        return dow >= 1 && dow <= 5;
      }).map(h => h.value);
      
      const weekendValues = withZScores.filter(h => {
        const dow = new Date(h.date).getDay();
        return dow === 0 || dow === 6;
      }).map(h => h.value);
      
      if (weekdayValues.length >= 5 && weekendValues.length >= 2) {
        const weekdayMean = weekdayValues.reduce((a, b) => a + b, 0) / weekdayValues.length;
        const weekendMean = weekendValues.reduce((a, b) => a + b, 0) / weekendValues.length;
        const spread = weekendMean - weekdayMean;
        
        if (Math.abs(spread) >= 5) {
          patterns.weekendSplit = {
            weekdayMean: Math.round(weekdayMean),
            weekendMean: Math.round(weekendMean),
            spread: Math.round(spread)
          };
        }
      }

      const today = hrvHistory.find(h => h.date === getTodayLocal());
      if (today) {
        const todayZ = (today.value - median) / mad;
        let nearest = null;
        let nearestDiff = Infinity;
        
        withZScores.forEach(h => {
          if (h.date === getTodayLocal()) return;
          const diff = Math.abs(h.zScore - todayZ);
          if (diff < nearestDiff && diff < 0.5) {
            nearestDiff = diff;
            nearest = h;
          }
        });
        
        if (nearest) {
          const nextDate = new Date(nearest.date);
          nextDate.setDate(nextDate.getDate() + 1);
          const nextDateStr = getLocalDateString(nextDate);
          const compliance = complianceLog?.find(c => c.date === nearest.date);
          const nextDay = withZScores.find(h => h.date === nextDateStr);
          
          patterns.nearestMatch = {
            date: nearest.date,
            zScore: nearest.zScore,
            command: nearest.command,
            pushed: compliance?.followed === 'no',
            rested: compliance?.followed === 'yes',
            nextDayCrashed: nextDay ? nextDay.zScore < THRESHOLDS.REST : null,
            nextDayRecovered: nextDay ? nextDay.zScore >= 0 : null
          };
        }
      }

      return patterns;
    };

    // ============================================
    // CONFIDENCE & MODE SYSTEMS
    // ============================================
    const calculateConfidence = (hrvHistory, patterns, complianceLog = []) => {
      if (!patterns || hrvHistory.length < 14) {
        return { 
          level: 'low', 
          score: 30,
          reason: hrvHistory.length < 14 ? 'early_onboarding' : 'no_patterns',
          components: { signal: 15, quality: 10, support: 5 }
        };
      }
      
      const todayEntry = hrvHistory.find(h => h.date === getTodayLocal());
      let signalScore = 15;
      
      if (todayEntry && patterns.baseline && patterns.mad) {
        const robustZ = Math.abs((todayEntry.value - patterns.baseline) / patterns.mad);
        if (robustZ < 0.7) signalScore = 15;
        else if (robustZ < 1.5) signalScore = 30;
        else signalScore = 45;
      }
      
      let qualityScore = 10;
      const totalDays = hrvHistory.length;
      if (totalDays >= 30) qualityScore = 25;
      else if (totalDays >= 21) qualityScore = 20;
      else if (totalDays >= 14) qualityScore = 15;
      
      const yesterday = getYesterdayLocal();
      const hasYesterday = hrvHistory.some(h => h.date === yesterday);
      if (!hasYesterday) qualityScore = Math.max(10, qualityScore - 10);
      
      let supportScore = 5;
      if (patterns.nearestMatch) {
        const today = hrvHistory.find(h => h.date === getTodayLocal());
        if (today) {
          const todayZ = (today.value - patterns.baseline) / patterns.mad;
          const todayCommand = getCommandKey(todayZ);
          
          const withZScores = hrvHistory.map(h => ({
            ...h,
            zScore: (h.value - patterns.baseline) / patterns.mad,
            command: getCommandKey((h.value - patterns.baseline) / patterns.mad)
          })).filter(h => h.date !== getTodayLocal());
          
          const similarDays = withZScores.filter(h => {
            const zDiff = Math.abs(h.zScore - todayZ);
            return h.command === todayCommand && zDiff < 0.8;
          });
          
          if (similarDays.length >= 4) supportScore = 20;
          else if (similarDays.length >= 2) supportScore = 12;
        }
      }
      
      const totalScore = signalScore + qualityScore + supportScore;
      let level = 'low';
      if (totalScore >= 75) level = 'high';
      else if (totalScore >= 50) level = 'medium';
      
      if (patterns.isVolatile && level === 'high') level = 'medium';
      
      return {
        level,
        score: totalScore,
        reason: level === 'low' ? 'insufficient_evidence' : level === 'medium' ? 'moderate_evidence' : 'strong_evidence',
        components: { signal: signalScore, quality: qualityScore, support: supportScore }
      };
    };

    const getMode = (confidence, complianceLog, daysOnApp) => {
      if (confidence.level === 'low' || daysOnApp < 14) return 'UNCERTAIN';
      
      const sevenDaysAgo = new Date();
      sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
      const recentOverrides = complianceLog.filter(log => {
        const logDate = new Date(log.date);
        return logDate >= sevenDaysAgo && log.followed === 'no';
      }).length;
      
      const yesterday = getYesterdayLocal();
      const yesterdayLog = complianceLog.find(c => c.date === yesterday);
      const ignoredYesterdayRest = yesterdayLog?.command === 'REST' && yesterdayLog?.followed === 'no';
      
      if (recentOverrides >= 2 || ignoredYesterdayRest) return 'PROTECTIVE';
      return 'DIRECTIVE';
    };

    const getContext = (command, patterns, complianceLog, hrvHistory, daysOnApp) => {
      const confidence = calculateConfidence(hrvHistory, patterns, complianceLog);
      const mode = getMode(confidence, complianceLog, daysOnApp);
      
      const context = {
        mode,
        confidence,
        type: 'default',
        isWarning: false,
        isAfterRest: false,
        isConsecutive: false,
        isTrending: patterns?.trend || 'stable'
      };
      
      if (command === 'REST') {
        if (patterns?.trend === 'falling' || confidence.level === 'low') {
          context.isWarning = true;
          context.type = 'warning';
        }
      }
      
      if (command === 'BUILD') {
        if (patterns?.trend === 'falling' || confidence.level === 'low') {
          context.isWarning = true;
          context.type = 'warning';
        }
        if (patterns?.trend === 'rising' && patterns?.consecutiveAboveBaseline >= 3) {
          context.type = 'momentum';
        }
        const yesterday = getYesterdayLocal();
        const yesterdayLog = complianceLog?.find(c => c.date === yesterday);
        if (yesterdayLog?.command === 'REST' && yesterdayLog?.followed === 'yes') {
          context.isAfterRest = true;
          if (context.mode === 'DIRECTIVE') context.type = 'after_rest';
        }
      }
      
      if (command === 'PERFORM') {
        const yesterday = getYesterdayLocal();
        const yesterdayLog = complianceLog?.find(c => c.date === yesterday);
        if (yesterdayLog?.command === 'PERFORM') {
          context.isConsecutive = true;
          context.type = 'consecutive';
        }
        if (patterns?.totalDays >= 14 && patterns?.crashesAfterIgnoredRest?.length >= 2) {
          context.isWarning = true;
          if (!context.isConsecutive) context.type = 'warning';
        }
      }
      
      return context;
    };

    // ============================================
    // OBSERVATION & ACTION GENERATORS
    // ============================================
    const generateObservation = (command, patterns, daysOnApp, hrvHistory, complianceLog = []) => {
      const today = new Date();
      const seed = today.getFullYear() * 10000 + (today.getMonth() + 1) * 100 + today.getDate();
      const pick = (arr) => arr.length > 0 ? arr[seed % arr.length] : null;
      
      if (!patterns) {
        const daysRemaining = 4 - hrvHistory.length;
        if (daysRemaining > 0) {
          return { text: `${daysRemaining} day${daysRemaining > 1 ? 's' : ''} until commands unlock.`, type: 'learning_countdown' };
        }
        return { text: "Your baseline is forming.", type: 'learning_forming' };
      }

      const context = getContext(command, patterns, complianceLog, hrvHistory, daysOnApp);
      const mode = context.mode;
      const confidence = context.confidence;
      const crashCount = patterns.crashesAfterIgnoredRest?.length || 0;
      const canUsePersonalization = daysOnApp >= 14 && confidence.level !== 'low';

      if (command === 'REST') {
        if (canUsePersonalization && patterns.nearestMatch?.nextDayCrashed) {
          const anchor = formatDateAnchor(patterns.nearestMatch.date);
          if (anchor) return { text: `This looks like ${anchor}. That day cost you.`, type: 'rest_date_anchor' };
        }
        
        if (canUsePersonalization && crashCount >= 2) {
          return { text: `${crashCount} times you've pushed through REST. ${crashCount} times you paid.`, type: 'rest_proof' };
        }
        
        if (mode === 'DIRECTIVE') {
          return pick([
            { text: "The work is done. Now the building happens.", type: 'rest_directive' },
            { text: "You stressed the system. Now it adapts.", type: 'rest_directive' },
            { text: "Not a setback. A setup.", type: 'rest_directive' }
          ]);
        }
        
        if (mode === 'PROTECTIVE') {
          return pick([
            { text: "You feel fine. The trend says otherwise.", type: 'rest_protective' },
            { text: "The body doesn't send alerts. It just keeps sliding until it hands you the bill.", type: 'rest_protective' }
          ]);
        }
        
        return { text: "Signal is unclear. Default to less.", type: 'rest_uncertain' };
      }

      if (command === 'BUILD') {
        if (context.isAfterRest && mode === 'DIRECTIVE') {
          return pick([
            { text: "You rested. This is the return.", type: 'build_after_rest' },
            { text: "Yesterday's patience. Today's capacity.", type: 'build_after_rest' }
          ]);
        }
        
        if (mode === 'DIRECTIVE') {
          return pick([
            { text: "Room to work. Not room to be reckless.", type: 'build_directive' },
            { text: "Middle of your range. Solid work is available.", type: 'build_directive' },
            { text: "Enough for quality. Not enough for ego.", type: 'build_directive' }
          ]);
        }
        
        if (mode === 'PROTECTIVE') {
          return pick([
            { text: "Still in range, but the direction matters.", type: 'build_protective' },
            { text: "The runway is getting shorter. Land smoothly.", type: 'build_protective' }
          ]);
        }
        
        return { text: "Do what's programmed. Nothing extra.", type: 'build_uncertain' };
      }

      if (command === 'PERFORM') {
        if (context.isConsecutive) {
          return { text: "Second straight day. Rare. Stay disciplined.", type: 'perform_consecutive' };
        }
        
        if (canUsePersonalization && patterns.daysSincePerform >= 7) {
          return { text: `First green in ${patterns.daysSincePerform} days. The drought is over.`, type: 'perform_rarity' };
        }
        
        if (mode === 'DIRECTIVE') {
          return pick([
            { text: "The tank is full. This is what you've been building toward.", type: 'perform_directive' },
            { text: "Green light. No caveats.", type: 'perform_directive' },
            { text: "Capacity is peaking. Use it. You can't save it.", type: 'perform_directive' }
          ]);
        }
        
        if (mode === 'PROTECTIVE') {
          return { text: "Green light. But the road still has turns.", type: 'perform_protective' };
        }
        
        return { text: "Green, but signal is noisy. Keep it controlled.", type: 'perform_uncertain' };
      }
      
      return { text: "Baseline forming.", type: 'learning' };
    };

    const generateActions = (command, patterns, hrvHistory, complianceLog = [], daysOnApp = 0) => {
      if (!patterns || hrvHistory.length < 7) return null;
      
      const context = getContext(command, patterns, complianceLog, hrvHistory, daysOnApp);

      if (command === 'REST') {
        if (context.isWarning) {
          return {
            primaryAction: "10-20 minute walk. 10 minutes stretching. That's the whole day.",
            effortBoundary: "Conversation pace. If you can't speak in full sentences, slow down. RPE 2.",
            recoveryLever: "In bed 30-60 minutes earlier than usual. This is the lever.",
            guardrail: "Restlessness is a feeling, not a command."
          };
        }
        return {
          primaryAction: "20-30 minutes easy movement. Walk, stretch, foam roll. Stop while it still feels easy.",
          effortBoundary: "Nose-breath only. If you need your mouth, slow down. RPE 2-3.",
          recoveryLever: "Water before coffee. Protein at every meal. Protect an 8-hour sleep window.",
          guardrail: "No 'just a quick one.' That's how rest days become debt."
        };
      }

      if (command === 'BUILD') {
        if (context.isWarning) {
          return {
            primaryAction: "Same workout. Pull one lever back 20%: lighter load, fewer reps, or shorter time cap. Pick one.",
            effortBoundary: "RPE 6 ceiling. When form breaks, rack it.",
            recoveryLever: "In bed 30 minutes earlier than usual. Protein within 60 minutes.",
            guardrail: "A shortened session is a win. A crash is a week lost."
          };
        }
        if (context.isAfterRest) {
          return {
            primaryAction: "Full programmed work. Finish feeling like you could do a little more—but don't.",
            effortBoundary: "RPE 7. Leave 20% in the tank. That's fuel for the streak.",
            recoveryLever: "Don't undo yesterday's investment. Another good night tonight.",
            guardrail: "Feeling good doesn't mean 'go all out.' It means 'execute cleanly.'"
          };
        }
        return {
          primaryAction: "Programmed work only. Skip the finisher. Leave 10 minutes before you normally would.",
          effortBoundary: "RPE 7 cap. Finish feeling like you could do a little more. When form breaks, rack it.",
          recoveryLever: "Protein within 2 hours of training. Protect 7-8 hours sleep.",
          guardrail: "Don't turn a BUILD day into a PERFORM day. They have different purposes."
        };
      }

      if (command === 'PERFORM') {
        if (context.isConsecutive) {
          return {
            primaryAction: "Shorter session than yesterday. 75% of the duration. 85% of the intensity.",
            effortBoundary: "RPE 7-8 ceiling. Lower than yesterday. If anything feels off in warm-up, convert to BUILD.",
            recoveryLever: "Tonight is critical. 8+ hours. Extra protein. This is probably the last green for a while.",
            guardrail: "Three consecutive PERFORMs almost never end well. Stop while you're ahead."
          };
        }
        if (context.isWarning) {
          return {
            primaryAction: "One hard effort in the first 15 minutes. Then coast. No encores.",
            effortBoundary: "RPE 8 once. Then immediately drop to 6.",
            recoveryLever: "Double down on recovery tonight.",
            guardrail: "This pattern has cost days before. Keep today clean so tomorrow stays alive."
          };
        }
        return {
          primaryAction: "Your hard effort goes in the first 20 minutes. Heavy lift, benchmark, key interval—whatever it is, do it first. Then coast.",
          effortBoundary: "RPE 8-9 for one effort. Leave a rep in reserve. Then drop to 6-7. No second peaks.",
          recoveryLever: "Refuel within 60 minutes: protein + carbs. Protect an 8-hour sleep window.",
          guardrail: "Don't turn a great day into a two-day hangover. One peak. Then done."
        };
      }

      return null;
    };

    // ============================================
    // IMPOSSIBLE INSIGHTS
    // ============================================
    const getImpossibleInsight = (daysOnApp, patterns, complianceLog) => {
      if (daysOnApp === 7 && patterns?.weekendSplit) {
        const { weekdayMean, weekendMean } = patterns.weekendSplit;
        return {
          label: 'YOUR FIRST WEEK',
          content: [
            `Monday through Friday: ${weekdayMean}.`,
            `Saturday and Sunday: ${weekendMean}.`,
            '',
            'You are not the same person on weekends.',
            '',
            "You've never noticed this.",
            'How could you?',
            "You can't feel a weekly average.",
            '',
            "But it's been true your whole life.",
            'Now you know.'
          ]
        };
      }
      
      if (daysOnApp === 14 && (patterns?.weakDay || patterns?.strongDay)) {
        const lines = [];
        if (patterns.weakDay && patterns.strongDay) {
          lines.push(`Your worst days: ${patterns.weakDay.day}s.`);
          lines.push(`Your best days: ${patterns.strongDay.day}s.`);
        } else if (patterns.weakDay) {
          lines.push(`Your ${patterns.weakDay.day}s consistently drag.`);
        } else if (patterns.strongDay) {
          lines.push(`Your ${patterns.strongDay.day}s consistently peak.`);
        }
        lines.push('');
        lines.push('This is not random.');
        lines.push('This is your weekly rhythm.');
        
        return { label: 'TWO WEEKS', content: lines };
      }
      
      if (daysOnApp === 30) {
        const restIssued = complianceLog.filter(c => c.command === 'REST').length;
        const restFollowed = complianceLog.filter(c => c.command === 'REST' && c.followed === 'yes').length;
        
        if (restIssued >= 3) {
          return {
            label: 'ONE MONTH',
            content: [
              `REST commands: ${restIssued}`,
              `Followed: ${restFollowed}`,
              '',
              'The times REST was followed',
              'all preceded climbs.',
              '',
              'The pattern is already clear.'
            ]
          };
        }
      }
      
      if (daysOnApp === 90) {
        return {
          label: 'NINETY DAYS',
          content: [
            'Rest → rise.',
            'Push through → fall.',
            '',
            'You just never had a translator',
            'to show you the results.',
            '',
            'Now you do.'
          ]
        };
      }
      
      return null;
    };

    // ============================================
    // UI COMPONENTS
    // ============================================
    
    const CommandWord = ({ command, onClick, isRevealed }) => {
      const colors = {
        REST: '#FDA4AF',
        BUILD: '#C9A962', 
        PERFORM: '#6EE7B7',
        LEARNING: '#A1A1AA'
      };
      
      return (
        <div 
          className={`text-center cursor-pointer transition-all duration-600 ${isRevealed ? 'pt-8' : 'pt-32'}`}
          onClick={onClick}
        >
          <h1 
            className={`font-display animate-rise ${isRevealed ? 'text-4xl' : 'text-7xl'}`}
            style={{ 
              color: colors[command] || colors.LEARNING,
              transition: 'font-size 600ms ease-in-out'
            }}
          >
            {command}
          </h1>
          {!isRevealed && (
            <p className="text-sm mt-8 animate-fade delay-500" style={{ color: 'var(--text-muted)', opacity: 0.4 }}>
              touch to understand
            </p>
          )}
        </div>
      );
    };

    const Observation = ({ text }) => (
      <div className="text-center px-8 animate-rise">
        <p className="text-base leading-relaxed" style={{ color: 'var(--text-secondary)', lineHeight: 1.8 }}>
          {text}
        </p>
      </div>
    );

    const Prescription = ({ actions }) => {
      if (!actions) return null;
      
      return (
        <div className="px-8 space-y-5 animate-rise delay-200">
          <div className="divider" />
          
          <div className="space-y-4">
            <PrescriptionItem text={actions.primaryAction} />
            <PrescriptionItem text={actions.effortBoundary} muted />
            <PrescriptionItem text={actions.recoveryLever} muted />
          </div>
          
          <div className="divider" />
          
          <div className="flex items-start gap-3 animate-rise delay-300">
            <span style={{ color: 'var(--rose)', fontSize: '14px' }}>⚠</span>
            <p className="text-sm leading-relaxed" style={{ color: 'var(--rose)', opacity: 0.8 }}>
              {actions.guardrail}
            </p>
          </div>
        </div>
      );
    };

    const PrescriptionItem = ({ text, muted }) => (
      <div className="flex items-start gap-3">
        <span className="mt-2 block w-1.5 h-1.5 rounded-full flex-shrink-0" style={{ backgroundColor: 'var(--gold)' }} />
        <p className="text-sm leading-relaxed" style={{ color: muted ? 'var(--text-muted)' : 'var(--text-secondary)' }}>
          {text}
        </p>
      </div>
    );

    const InsightBlock = ({ insight }) => {
      if (!insight) return null;
      
      return (
        <div className="insight-block animate-rise delay-400 mt-8">
          <div className="label">{insight.label}</div>
          <div className="content">
            {insight.content.map((line, i) => (
              <React.Fragment key={i}>
                {line || <br />}
                {line && i < insight.content.length - 1 && <br />}
              </React.Fragment>
            ))}
          </div>
        </div>
      );
    };

    const CompliancePrompt = ({ onSelect }) => (
      <div className="fixed inset-0 flex items-center justify-center p-10" style={{ background: 'var(--bg-primary)' }}>
        <div className="text-center space-y-10 animate-rise max-w-sm w-full">
          <p className="font-display text-xl italic" style={{ color: 'var(--text-secondary)' }}>
            Yesterday was...
          </p>
          
          <div className="flex gap-4">
            <button onClick={() => onSelect('yes')} className="btn-primary flex-1">Rested</button>
            <button onClick={() => onSelect('no')} className="btn-primary flex-1">Trained</button>
          </div>
        </div>
      </div>
    );

    const HRVInput = ({ value, onChange, onSubmit, hrvSource }) => (
      <div className="space-y-6 animate-rise">
        <div className="text-center">
          <p className="text-sm mb-2" style={{ color: 'var(--text-muted)' }}>
            {hrvSource?.label || 'Your'} HRV this morning
          </p>
        </div>
        
        <input
          type="number"
          value={value}
          onChange={(e) => onChange(e.target.value)}
          onKeyDown={(e) => e.key === 'Enter' && onSubmit()}
          placeholder="ms"
          className="input-minimal text-3xl font-display"
          autoFocus
        />
        
        <button
          onClick={onSubmit}
          disabled={!value}
          className="btn-primary"
          style={{ 
            opacity: value ? 1 : 0.3,
            borderColor: value ? 'var(--gold)' : 'var(--text-faint)',
            color: value ? 'var(--gold)' : 'var(--text-muted)'
          }}
        >
          Log
        </button>
      </div>
    );

    // ============================================
    // TEST PANEL COMPONENT
    // ============================================
    const TestPanel = ({ 
      hrvHistory, 
      patterns, 
      daysOnApp, 
      onLoadTestData, 
      onSetDaysOnApp,
      onAddTodayHRV,
      onClear 
    }) => {
      const [testHRV, setTestHRV] = useState('50');
      
      return (
        <div className="test-panel">
          <div className="flex items-center gap-2 flex-wrap">
            <span className="text-xs" style={{ color: 'var(--amber)' }}>TEST:</span>
            
            <button onClick={() => onLoadTestData(7)} className="btn-test">7d data</button>
            <button onClick={() => onLoadTestData(14)} className="btn-test">14d data</button>
            <button onClick={() => onLoadTestData(30)} className="btn-test">30d data</button>
            <button onClick={() => onLoadTestData(90)} className="btn-test">90d data</button>
            
            <span className="text-xs mx-2" style={{ color: 'var(--text-muted)' }}>|</span>
            
            <input
              type="number"
              value={testHRV}
              onChange={(e) => setTestHRV(e.target.value)}
              className="w-16 px-2 py-1 text-xs rounded"
              style={{ background: 'var(--bg-elevated)', border: '1px solid var(--text-faint)', color: 'var(--text-primary)' }}
            />
            <button onClick={() => onAddTodayHRV(parseInt(testHRV))} className="btn-test">Add Today</button>
            
            <span className="text-xs mx-2" style={{ color: 'var(--text-muted)' }}>|</span>
            
            <button onClick={onClear} className="btn-test">Clear</button>
            
            <span className="text-xs ml-auto" style={{ color: 'var(--text-muted)' }}>
              {hrvHistory.length}d | {patterns?.baseline ? `μ${Math.round(patterns.baseline)}` : '—'} | Day {daysOnApp}
            </span>
          </div>
        </div>
      );
    };

    // ============================================
    // MAIN APPLICATION
    // ============================================
    const App = () => {
      const [hrvHistory, setHrvHistory] = useState([]);
      const [complianceLog, setComplianceLog] = useState([]);
      const [firstUseDate, setFirstUseDate] = useState(null);
      const [hrvSource, setHrvSource] = useState({ id: 'test', label: 'TEST' });
      const [isLoading, setIsLoading] = useState(true);
      
      const [todayHRV, setTodayHRV] = useState('');
      const [isRevealed, setIsRevealed] = useState(false);
      const [showCompliancePrompt, setShowCompliancePrompt] = useState(false);
      const [pendingCompliance, setPendingCompliance] = useState(null);

      useEffect(() => {
        try {
          const saved = localStorage.getItem('genysys_v2_test_data');
          if (saved) {
            const data = JSON.parse(saved);
            setHrvHistory(data.hrvHistory || []);
            setComplianceLog(data.complianceLog || []);
            setFirstUseDate(data.firstUseDate);
          }
        } catch (e) {
          console.error('Error loading data:', e);
        }
        setIsLoading(false);
      }, []);

      const saveData = useCallback((updates = {}) => {
        const data = {
          hrvHistory,
          complianceLog,
          firstUseDate,
          hrvSource,
          ...updates
        };
        localStorage.setItem('genysys_v2_test_data', JSON.stringify(data));
      }, [hrvHistory, complianceLog, firstUseDate, hrvSource]);

      const today = getTodayLocal();
      const todayEntry = hrvHistory.find(h => h.date === today);
      const patterns = useMemo(() => analyzePatterns(hrvHistory, complianceLog, firstUseDate), [hrvHistory, complianceLog, firstUseDate]);
      
      const daysOnApp = firstUseDate 
        ? Math.floor((new Date() - new Date(firstUseDate)) / (1000 * 60 * 60 * 24)) + 1
        : hrvHistory.length || 1;

      const result = useMemo(() => {
        if (!todayEntry || !patterns) {
          return { commandKey: 'LEARNING', isPreview: true, daysUntilFull: Math.max(0, 7 - hrvHistory.length) };
        }
        const zScore = (todayEntry.value - patterns.baseline) / patterns.mad;
        const command = getCommandKey(zScore);
        return { commandKey: command, zScore, isPreview: hrvHistory.length < 7 };
      }, [todayEntry, patterns, hrvHistory.length]);

      const observation = useMemo(() => 
        generateObservation(result?.commandKey, patterns, daysOnApp, hrvHistory, complianceLog),
        [result?.commandKey, patterns, daysOnApp, hrvHistory, complianceLog]
      );

      const actions = useMemo(() => 
        generateActions(result?.commandKey, patterns, hrvHistory, complianceLog, daysOnApp),
        [result?.commandKey, patterns, hrvHistory, complianceLog, daysOnApp]
      );

      const impossibleInsight = useMemo(() => 
        getImpossibleInsight(daysOnApp, patterns, complianceLog),
        [daysOnApp, patterns, complianceLog]
      );

      // TEST HANDLERS
      const handleLoadTestData = (days) => {
        const { history, compliance } = generateTestData(days);
        const firstDate = history[0]?.date || getTodayLocal();
        setHrvHistory(history);
        setComplianceLog(compliance);
        setFirstUseDate(firstDate);
        setIsRevealed(false);
        saveData({ hrvHistory: history, complianceLog: compliance, firstUseDate: firstDate });
      };

      const handleAddTodayHRV = (value) => {
        if (isNaN(value) || value < 1) return;
        const newHistory = [...hrvHistory.filter(h => h.date !== today), { date: today, value }];
        if (!firstUseDate) setFirstUseDate(today);
        setHrvHistory(newHistory);
        setIsRevealed(false);
        saveData({ hrvHistory: newHistory, firstUseDate: firstUseDate || today });
      };

      const handleClear = () => {
        setHrvHistory([]);
        setComplianceLog([]);
        setFirstUseDate(null);
        setIsRevealed(false);
        localStorage.removeItem('genysys_v2_test_data');
      };

      const handleLogHRV = () => {
        const value = parseInt(todayHRV);
        if (isNaN(value) || value < 1 || value > 300) return;
        handleAddTodayHRV(value);
        setTodayHRV('');
      };

      const handleComplianceSelect = (followed) => {
        if (!pendingCompliance) return;
        const newLog = [...complianceLog, { ...pendingCompliance, followed }];
        setComplianceLog(newLog);
        saveData({ complianceLog: newLog });
        setShowCompliancePrompt(false);
        setPendingCompliance(null);
      };

      if (isLoading) {
        return (
          <div className="min-h-screen flex items-center justify-center" style={{ background: 'var(--bg-primary)' }}>
            <div className="animate-fade" style={{ color: 'var(--text-muted)' }}>...</div>
          </div>
        );
      }

      if (showCompliancePrompt) {
        return <CompliancePrompt onSelect={handleComplianceSelect} />;
      }

      return (
        <div className="min-h-screen pb-16" style={{ background: 'var(--bg-primary)' }}>
          {/* TEST MODE BADGE */}
          <div className="test-badge">TEST MODE</div>
          
          <div className="max-w-md mx-auto px-10 py-8 min-h-screen flex flex-col">
            
            <header className="flex justify-between items-center mb-8">
              <span className="text-xs tracking-widest" style={{ color: 'var(--gold)', opacity: 0.6 }}>
                GENYSYS
              </span>
              <span className="text-xs" style={{ color: 'var(--text-muted)' }}>
                {new Date().toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric' })}
              </span>
            </header>

            <main className="flex-1 flex flex-col">
              
              {!todayEntry && (
                <div className="flex-1 flex items-center justify-center">
                  <div className="w-full max-w-xs">
                    <HRVInput
                      value={todayHRV}
                      onChange={setTodayHRV}
                      onSubmit={handleLogHRV}
                      hrvSource={hrvSource}
                    />
                  </div>
                </div>
              )}

              {todayEntry && (
                <div className="flex-1">
                  <CommandWord 
                    command={result?.commandKey || 'LEARNING'} 
                    onClick={() => setIsRevealed(true)}
                    isRevealed={isRevealed}
                  />

                  {isRevealed && (
                    <div className="mt-8 space-y-6">
                      {observation && <Observation text={observation.text} />}
                      <Prescription actions={actions} />
                      {impossibleInsight && (
                        <div className="px-8">
                          <InsightBlock insight={impossibleInsight} />
                        </div>
                      )}
                      {result?.isPreview && (
                        <div className="text-center mt-8 animate-rise delay-500">
                          <p className="text-xs" style={{ color: 'var(--text-muted)' }}>
                            {result.daysUntilFull > 0 
                              ? `${result.daysUntilFull} days until personalized guidance unlocks.`
                              : 'Baseline forming.'}
                          </p>
                        </div>
                      )}
                    </div>
                  )}
                </div>
              )}
            </main>
          </div>

          {/* TEST PANEL */}
          <TestPanel
            hrvHistory={hrvHistory}
            patterns={patterns}
            daysOnApp={daysOnApp}
            onLoadTestData={handleLoadTestData}
            onAddTodayHRV={handleAddTodayHRV}
            onClear={handleClear}
          />
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
