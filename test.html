<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#1a2f1a">
  <title>GENYSYS — TEST MODE</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18.2.0/umd/react.production.min.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js" crossorigin="anonymous"></script>
  <script src="https://unpkg.com/@babel/standalone@7.23.5/babel.min.js" crossorigin="anonymous"></script>
  <style>
    body { 
      background: linear-gradient(180deg, #2d3b2d 0%, #3d4f3d 20%, #4a5d4a 40%, #5a6b5a 60%, #6b7b6b 80%, #8a9a8a 100%);
      background-attachment: fixed;
      min-height: 100vh;
    }
    .glass { background: rgba(40, 50, 40, 0.6); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); border: 1px solid rgba(255, 255, 255, 0.08); }
    .glass-light { background: rgba(60, 75, 60, 0.5); backdrop-filter: blur(16px); -webkit-backdrop-filter: blur(16px); border: 1px solid rgba(255, 255, 255, 0.06); }
    .glass-dark { background: rgba(20, 30, 20, 0.7); backdrop-filter: blur(24px); -webkit-backdrop-filter: blur(24px); border: 1px solid rgba(255, 255, 255, 0.05); }
    .mist-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: linear-gradient(180deg, rgba(180,190,180,0.1) 0%, rgba(180,190,180,0) 30%, rgba(180,190,180,0) 70%, rgba(180,190,180,0.05) 100%); pointer-events: none; z-index: 1; }
    .content-layer { position: relative; z-index: 2; }
    input[type="date"]::-webkit-calendar-picker-indicator { filter: invert(0.7); }
    input[type="number"]::-webkit-inner-spin-button, input[type="number"]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
    input[type="number"] { -moz-appearance: textfield; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
    @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }
    @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-3px); } }
    .fade-in { animation: fadeIn 0.6s ease-out forwards; }
    .fade-in-delay-1 { animation: fadeIn 0.6s ease-out 0.2s forwards; opacity: 0; }
    .fade-in-delay-2 { animation: fadeIn 0.6s ease-out 0.4s forwards; opacity: 0; }
    .fade-in-delay-3 { animation: fadeIn 0.6s ease-out 0.6s forwards; opacity: 0; }
    .pulse-slow { animation: pulse 3s ease-in-out infinite; }
    .float { animation: float 4s ease-in-out infinite; }
    .line-clamp-2 {
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    * { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; }
    ::-webkit-scrollbar { width: 4px; }
    ::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
    ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 2px; }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useState, useEffect, useMemo, useRef } = React;

    // ============================================
    // ANALYTICS CONFIGURATION
    // ============================================
    const ANALYTICS_ENDPOINT = 'YOUR_GOOGLE_APPS_SCRIPT_URL_HERE';
    
    const ALLOWED_EVENTS = [
      'session_start', 'onboarding_complete', 'first_hrv_logged', 'hrv_logged',
      'hrv_backfilled', 'command_generated', 'compliance_recorded',
      'day_3_active', 'day_7_active', 'day_14_active', 'day_30_active', 'day_60_active', 'day_90_active',
      'milestone_reached', 'observation_shown',
      'feedback_round1_submitted', 'feedback_round1_dismissed', 
      'feedback_round2_submitted', 'feedback_round2_dismissed',
      'data_exported', 'data_reset', 'legacy_user_migrated'
    ];

    const generateUUID = () => {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
      });
    };

    const getTimezone = () => {
      try {
        return Intl.DateTimeFormat().resolvedOptions().timeZone;
      } catch (e) {
        return 'Unknown';
      }
    };

    const Analytics = {
      userId: null,
      timezone: null,
      device: null,
      firstUseDate: null,

      init() {
        let stored = localStorage.getItem('genysys_analytics');
        if (stored) {
          const data = JSON.parse(stored);
          this.userId = data.userId;
          this.timezone = data.timezone || getTimezone();
          this.firstUseDate = data.firstUseDate;
        } else {
          this.userId = generateUUID();
          this.timezone = getTimezone();
          const appData = localStorage.getItem('genysys_v2_test_data');
          if (appData) {
            try {
              const parsed = JSON.parse(appData);
              this.firstUseDate = parsed.firstUseDate || this.getTodayLocal();
            } catch (e) {
              this.firstUseDate = this.getTodayLocal();
            }
          } else {
            this.firstUseDate = this.getTodayLocal();
          }
          this.save();
        }
      },

      getTodayLocal() {
        const date = new Date();
        return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
      },

      save() {
        localStorage.setItem('genysys_analytics', JSON.stringify({
          userId: this.userId,
          timezone: this.timezone,
          firstUseDate: this.firstUseDate
        }));
      },

      setDevice(device) { this.device = device; },

      getDaysActive() {
        if (!this.firstUseDate) return 0;
        return Math.floor((new Date() - new Date(this.firstUseDate)) / (1000 * 60 * 60 * 24));
      },

      track(eventName, properties = {}) {
        if (!ALLOWED_EVENTS.includes(eventName)) {
          console.warn('[Analytics] Unknown event:', eventName);
          return;
        }
        if (!this.userId) return;
        
        const payload = {
          timestamp: new Date().toISOString(),
          userId: this.userId,
          event: eventName,
          device: this.device || properties.device || 'unknown',
          daysActive: this.getDaysActive(),
          region: this.timezone,
          ...properties
        };

        console.log('[Analytics]', eventName, payload);

        if (ANALYTICS_ENDPOINT && ANALYTICS_ENDPOINT !== 'YOUR_GOOGLE_APPS_SCRIPT_URL_HERE') {
          fetch(ANALYTICS_ENDPOINT, {
            method: 'POST',
            mode: 'no-cors',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          }).catch(err => console.log('Analytics error:', err));
        }
      }
    };

    Analytics.init();

    // ============================================
    // UTILITIES
    // ============================================
    const getLocalDateString = (date = new Date()) => {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    };

    const getTodayLocal = () => getLocalDateString();
    
    const getYesterdayLocal = () => {
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      return getLocalDateString(yesterday);
    };

    const getDayName = (dateStr) => {
      const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      return days[new Date(dateStr).getDay()];
    };

    const getRelativeDay = (dateStr) => {
      const today = new Date(getTodayLocal());
      const target = new Date(dateStr);
      const diffDays = Math.floor((today - target) / (1000 * 60 * 60 * 24));
      if (diffDays === 0) return 'today';
      if (diffDays === 1) return 'yesterday';
      if (diffDays < 7) return getDayName(dateStr);
      if (diffDays < 14) return 'last ' + getDayName(dateStr);
      return `${diffDays} days ago`;
    };

    // ============================================
    // ALGORITHM (unchanged from validated version)
    // ============================================
    const THRESHOLDS = { REST: -1.0, PERFORM: 0.5, MIN_DAYS: 7, MIN_PREVIEW_DAYS: 4, MAD_FLOOR: 3.0 };

    const calculateMedian = (arr) => {
      const sorted = [...arr].sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
    };

    const calculateMAD = (arr, median) => {
      const deviations = arr.map(v => Math.abs(v - median)).sort((a, b) => a - b);
      return Math.max(calculateMedian(deviations) * 1.4826, THRESHOLDS.MAD_FLOOR);
    };

    const getCommandKey = (zScore) => {
      if (zScore === null) return 'LEARNING';
      if (zScore < THRESHOLDS.REST) return 'REST';
      if (zScore >= THRESHOLDS.PERFORM) return 'PERFORM';
      return 'BUILD';
    };

    // ============================================
    // PATTERN ENGINE
    // ============================================
    const analyzePatterns = (hrvHistory, complianceLog, firstUseDate) => {
      if (hrvHistory.length < 3) return null;

      const values = hrvHistory.map(h => h.value);
      const median = calculateMedian(values);
      const mad = calculateMAD(values, median);

      // Calculate z-scores for all entries
      const withZScores = hrvHistory.map(h => ({
        ...h,
        zScore: (h.value - median) / mad,
        command: getCommandKey((h.value - median) / mad)
      })).sort((a, b) => new Date(a.date) - new Date(b.date));

      // Find patterns
      const patterns = {
        baseline: median,
        mad,
        totalDays: hrvHistory.length,
        
        // Command distribution
        restDays: withZScores.filter(h => h.command === 'REST').length,
        buildDays: withZScores.filter(h => h.command === 'BUILD').length,
        performDays: withZScores.filter(h => h.command === 'PERFORM').length,
        
        // Crash analysis
        crashes: [],
        crashesAfterIgnoredRest: [],
        recoveriesAfterRest: [],
        
        // Trend
        trend: null,
        consecutiveBelowBaseline: 0,
        consecutiveAboveBaseline: 0,
        
        // Historical comparisons
        nearestMatch: null,
        lastPerformDate: null,
        daysSincePerform: null,
        
        // Volatility
        isVolatile: false,
        isStable: false,
      };

      // Analyze trend (last 3-5 days)
      const recent = withZScores.slice(-5);
      if (recent.length >= 3) {
        let rising = 0, falling = 0;
        for (let i = 1; i < recent.length; i++) {
          if (recent[i].zScore > recent[i-1].zScore) rising++;
          else if (recent[i].zScore < recent[i-1].zScore) falling++;
        }
        if (rising >= 3) patterns.trend = 'rising';
        else if (falling >= 3) patterns.trend = 'falling';
        else patterns.trend = 'stable';
      }

      // Count consecutive days below/above baseline
      const reversed = [...withZScores].reverse();
      for (const h of reversed) {
        if (h.zScore < 0) patterns.consecutiveBelowBaseline++;
        else break;
      }
      for (const h of reversed) {
        if (h.zScore > 0) patterns.consecutiveAboveBaseline++;
        else break;
      }

      // Find last PERFORM day
      const performDays = withZScores.filter(h => h.command === 'PERFORM');
      if (performDays.length > 0) {
        const lastPerform = performDays[performDays.length - 1];
        patterns.lastPerformDate = lastPerform.date;
        patterns.daysSincePerform = Math.floor(
          (new Date(getTodayLocal()) - new Date(lastPerform.date)) / (1000 * 60 * 60 * 24)
        );
      }

      // Find last REST day
      const restDaysHistory = withZScores.filter(h => h.command === 'REST');
      if (restDaysHistory.length > 0) {
        const lastRest = restDaysHistory[restDaysHistory.length - 1];
        patterns.lastRestDate = lastRest.date;
        patterns.daysSinceRest = Math.floor(
          (new Date(getTodayLocal()) - new Date(lastRest.date)) / (1000 * 60 * 60 * 24)
        );
      }

      // Analyze compliance outcomes
      if (complianceLog && complianceLog.length > 0) {
        complianceLog.forEach(log => {
          if (!log.command || !log.followed) return;
          
          const nextDate = new Date(log.date);
          nextDate.setDate(nextDate.getDate() + 1);
          const nextDateStr = getLocalDateString(nextDate);
          const nextDay = withZScores.find(h => h.date === nextDateStr);
          
          if (!nextDay) return;
          
          // REST ignored → crashed?
          if (log.command === 'REST' && log.followed === 'no') {
            if (nextDay.zScore < THRESHOLDS.REST) {
              patterns.crashesAfterIgnoredRest.push({
                ignoredDate: log.date,
                crashDate: nextDateStr,
                daysLost: 1
              });
            }
          }
          
          // REST followed → recovered?
          if (log.command === 'REST' && log.followed === 'yes') {
            if (nextDay.zScore >= THRESHOLDS.REST) {
              patterns.recoveriesAfterRest.push({
                restDate: log.date,
                readyDate: nextDateStr
              });
            }
          }
        });
      }

      // Calculate volatility
      const zScoreStd = Math.sqrt(
        withZScores.reduce((sum, h) => sum + Math.pow(h.zScore, 2), 0) / withZScores.length
      );
      patterns.isVolatile = zScoreStd > 1.5;
      patterns.isStable = zScoreStd < 0.8;

      // === PATTERN NAMES ===
      
      // Recovery arc: 3+ days of rising from REST
      if (patterns.trend === 'rising' && patterns.consecutiveAboveBaseline >= 2) {
        const recentRest = withZScores.slice(-7).find(h => h.command === 'REST');
        if (recentRest) {
          patterns.patternName = 'recovery_arc';
        }
      }
      
      // Back-to-back PERFORM crash pattern
      const performIndices = withZScores.map((h, i) => h.command === 'PERFORM' ? i : -1).filter(i => i >= 0);
      let backToBackCrashes = 0;
      for (let i = 1; i < performIndices.length; i++) {
        if (performIndices[i] - performIndices[i-1] === 1) {
          const dayAfter = withZScores[performIndices[i] + 1];
          if (dayAfter && dayAfter.command === 'REST') {
            backToBackCrashes++;
          }
        }
      }
      if (backToBackCrashes >= 2) {
        patterns.patternName = 'back_to_back_crash';
        patterns.backToBackCrashes = backToBackCrashes;
      }
      
      // Day-of-week pattern detection
      const dayOfWeekStats = {};
      withZScores.forEach(h => {
        const dow = new Date(h.date).getDay();
        if (!dayOfWeekStats[dow]) dayOfWeekStats[dow] = { sum: 0, count: 0 };
        dayOfWeekStats[dow].sum += h.zScore;
        dayOfWeekStats[dow].count++;
      });
      
      const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
      let worstDay = null, worstAvg = Infinity;
      let bestDay = null, bestAvg = -Infinity;
      
      Object.entries(dayOfWeekStats).forEach(([dow, stats]) => {
        if (stats.count >= 3) {
          const avg = stats.sum / stats.count;
          if (avg < worstAvg) { worstAvg = avg; worstDay = parseInt(dow); }
          if (avg > bestAvg) { bestAvg = avg; bestDay = parseInt(dow); }
        }
      });
      
      if (worstDay !== null && worstAvg < -0.5) {
        patterns.weakDay = { day: dayNames[worstDay], avgZ: worstAvg };
      }
      if (bestDay !== null && bestAvg > 0.5) {
        patterns.strongDay = { day: dayNames[bestDay], avgZ: bestAvg };
      }
      
      const todayDow = new Date().getDay();
      if (dayOfWeekStats[todayDow] && dayOfWeekStats[todayDow].count >= 3) {
        const todayDowAvg = dayOfWeekStats[todayDow].sum / dayOfWeekStats[todayDow].count;
        if (todayDowAvg < -0.3) {
          patterns.todayDowPattern = { day: dayNames[todayDow], tendency: 'low', avgZ: todayDowAvg };
        } else if (todayDowAvg > 0.3) {
          patterns.todayDowPattern = { day: dayNames[todayDow], tendency: 'high', avgZ: todayDowAvg };
        }
      }

      // === IMPOSSIBLE INSIGHT ===
      const todayEntry = hrvHistory.find(h => h.date === getTodayLocal());
      if (todayEntry) {
        const todayZ = (todayEntry.value - median) / mad;
        const todayCommand = getCommandKey(todayZ);
        
        if (todayCommand === 'PERFORM' && patterns.trend === 'falling') {
          patterns.impossibleInsight = {
            type: 'false_peak',
            text: "Your HRV is high but your trend is falling. This peak may not hold."
          };
        }
        
        if (todayZ > 0 && patterns.isVolatile) {
          patterns.impossibleInsight = {
            type: 'unstable_high',
            text: "You're above baseline but your week has been erratic. Tread carefully."
          };
        }
        
        if (todayCommand === 'PERFORM' && patterns.daysSinceRest >= 5) {
          patterns.impossibleInsight = {
            type: 'no_rest_perform',
            text: `${patterns.daysSinceRest} days without REST. This PERFORM is borrowed time.`
          };
        }
        
        if (patterns.nearestMatch?.nextDayCrashed && todayCommand !== 'REST') {
          patterns.impossibleInsight = {
            type: 'historical_warning',
            text: "Last time you looked like this, you crashed the next day."
          };
        }
      }

      // Find nearest historical match to today
      const today = hrvHistory.find(h => h.date === getTodayLocal());
      if (today) {
        const todayZ = (today.value - median) / mad;
        let nearest = null;
        let nearestDiff = Infinity;
        
        withZScores.forEach(h => {
          if (h.date === getTodayLocal()) return;
          const diff = Math.abs(h.zScore - todayZ);
          if (diff < nearestDiff && diff < 0.5) {
            nearestDiff = diff;
            nearest = h;
          }
        });
        
        if (nearest) {
          const nextDate = new Date(nearest.date);
          nextDate.setDate(nextDate.getDate() + 1);
          const nextDateStr = getLocalDateString(nextDate);
          const compliance = complianceLog?.find(c => c.date === nearest.date);
          const nextDay = withZScores.find(h => h.date === nextDateStr);
          
          patterns.nearestMatch = {
            date: nearest.date,
            zScore: nearest.zScore,
            command: nearest.command,
            pushed: compliance?.followed === 'no',
            rested: compliance?.followed === 'yes',
            nextDayCrashed: nextDay ? nextDay.zScore < THRESHOLDS.REST : null,
            nextDayRecovered: nextDay ? nextDay.zScore >= 0 : null
          };
        }
      }

      return patterns;
    };

    // ============================================
    // CONFIDENCE CALCULATION SYSTEM
    // Hidden driver for language and action selection
    // Never shown to user - operates in background
    // ============================================
    
    // Scoring: Signal (45%) + Quality (35%) + Support (20%) = 0-100
    // Buckets: High (≥75), Medium (50-74), Low (<50)
    // Hard overrides: Travel, <14 days, inconsistent timing → Low
    
    const calculateConfidence = (hrvHistory, patterns, complianceLog = []) => {
      // Early return: not enough data = always Low
      if (!patterns || hrvHistory.length < 14) {
        return { 
          level: 'low', 
          score: 30,
          reason: hrvHistory.length < 14 ? 'early_onboarding' : 'no_patterns',
          components: { signal: 15, quality: 10, support: 5 }
        };
      }
      
      // ========== 1. SIGNAL STRENGTH (45 points max) ==========
      // Based on robust z-score: how meaningful is today's reading?
      const todayEntry = hrvHistory.find(h => h.date === getTodayLocal());
      let signalScore = 15; // weak default
      
      if (todayEntry && patterns.baseline && patterns.mad) {
        const robustZ = Math.abs((todayEntry.value - patterns.baseline) / patterns.mad);
        
        if (robustZ < 0.7) signalScore = 15;      // weak signal
        else if (robustZ < 1.5) signalScore = 30;  // medium signal
        else if (robustZ < 2.5) signalScore = 45;  // strong signal
        else signalScore = 45;                     // very strong (capped)
      }
      
      // ========== 2. MEASUREMENT QUALITY (35 points max) ==========
      // Based on data consistency and completeness
      let qualityScore = 10; // low default
      
      // Check days of data
      const totalDays = hrvHistory.length;
      if (totalDays >= 30) qualityScore = 25;
      else if (totalDays >= 21) qualityScore = 20;
      else if (totalDays >= 14) qualityScore = 15;
      else qualityScore = 10;
      
      // Penalty: Missing yesterday's HRV (less context)
      const yesterday = getYesterdayLocal();
      const hasYesterday = hrvHistory.some(h => h.date === yesterday);
      if (!hasYesterday) qualityScore = Math.max(10, qualityScore - 10);
      
      // Bonus: Consistent daily logging (check last 7 days)
      const recentDates = [];
      for (let i = 0; i < 7; i++) {
        const d = new Date();
        d.setDate(d.getDate() - i);
        recentDates.push(getLocalDateString(d));
      }
      const recentLogged = recentDates.filter(d => hrvHistory.some(h => h.date === d)).length;
      if (recentLogged >= 6) qualityScore = Math.min(35, qualityScore + 10);
      else if (recentLogged <= 3) qualityScore = Math.max(10, qualityScore - 5);
      
      // ========== 3. HISTORICAL SUPPORT (20 points max) ==========
      // Based on situation fingerprint matching
      let supportScore = 5; // weak default
      
      if (patterns.nearestMatch) {
        // We have a historical match - check how many similar situations exist
        const today = hrvHistory.find(h => h.date === getTodayLocal());
        if (today) {
          const todayZ = (today.value - patterns.baseline) / patterns.mad;
          const todayCommand = getCommandKey(todayZ);
          
          // Count similar fingerprints: same command + similar trend
          const withZScores = hrvHistory.map(h => ({
            ...h,
            zScore: (h.value - patterns.baseline) / patterns.mad,
            command: getCommandKey((h.value - patterns.baseline) / patterns.mad)
          })).filter(h => h.date !== getTodayLocal());
          
          const similarDays = withZScores.filter(h => {
            const zDiff = Math.abs(h.zScore - todayZ);
            return h.command === todayCommand && zDiff < 0.8;
          });
          
          if (similarDays.length >= 4) supportScore = 20;      // strong support
          else if (similarDays.length >= 2) supportScore = 12;  // medium support
          else supportScore = 5;                                // weak support
        }
      }
      
      // ========== COMPUTE TOTAL & BUCKET ==========
      const totalScore = signalScore + qualityScore + supportScore;
      
      let level = 'low';
      if (totalScore >= 75) level = 'high';
      else if (totalScore >= 50) level = 'medium';
      
      // ========== HARD OVERRIDES ==========
      // These force Low confidence regardless of score
      
      // Check for volatile week (indicates unstable measurement conditions)
      if (patterns.isVolatile && level === 'high') {
        level = 'medium';
      }
      
      // First day back after travel-like pattern (big swing after stability)
      // This is a proxy for timezone change detection
      const recent3 = hrvHistory.slice(-3);
      if (recent3.length >= 3) {
        const recent3Zs = recent3.map(h => (h.value - patterns.baseline) / patterns.mad);
        const range = Math.max(...recent3Zs) - Math.min(...recent3Zs);
        if (range > 2.5) {
          level = 'low';
        }
      }
      
      return {
        level,
        score: totalScore,
        reason: level === 'low' ? 'insufficient_evidence' : level === 'medium' ? 'moderate_evidence' : 'strong_evidence',
        components: { signal: signalScore, quality: qualityScore, support: supportScore }
      };
    };

    // ============================================
    // CONTEXT DETECTION (includes confidence)
    // ============================================
    const getContext = (command, patterns, complianceLog, hrvHistory = []) => {
      const context = { 
        type: 'default', 
        isWarning: false, 
        isConsecutive: false, 
        isAfterRest: false,
        confidence: { level: 'low', score: 30 }
      };
      if (!patterns) return context;
      
      // Calculate confidence first - it can force warning state
      context.confidence = calculateConfidence(hrvHistory, patterns, complianceLog);
      
      // Low confidence forces warning context
      if (context.confidence.level === 'low') {
        context.isWarning = true;
        context.type = 'warning';
      }
      
      if (patterns.trend === 'falling' || patterns.consecutiveBelowBaseline >= 2) {
        context.isWarning = true;
        context.type = 'warning';
      }
      
      if (command === 'BUILD' && patterns.daysSinceRest === 1) {
        context.isAfterRest = true;
        // Only use after_rest type if not in warning state
        if (!context.isWarning) context.type = 'after_rest';
      }
      
      if (command === 'PERFORM') {
        const yesterday = getYesterdayLocal();
        const yesterdayLog = complianceLog?.find(c => c.date === yesterday);
        if (yesterdayLog?.command === 'PERFORM') {
          context.isConsecutive = true;
          context.type = 'consecutive';
        }
        if (patterns.totalDays >= 14 && patterns.crashesAfterIgnoredRest?.length >= 2) {
          context.isWarning = true;
          if (!context.isConsecutive) context.type = 'warning';
        }
      }
      return context;
    };

    // ============================================
    // THE VOICE - Communication System
    // Confidence-adjusted language per spec
    // ============================================
    const generateObservation = (command, patterns, daysOnApp, lastObservationType, hrvHistory, complianceLog = []) => {
      const today = new Date();
      const seed = today.getFullYear() * 10000 + (today.getMonth() + 1) * 100 + today.getDate();
      const pick = (arr) => arr.length > 0 ? arr[seed % arr.length] : null;
      
      if (!patterns) {
        const daysRemaining = 4 - hrvHistory.length;
        if (daysRemaining > 0) return { text: `${daysRemaining} day${daysRemaining > 1 ? 's' : ''} until commands. Add history below to unlock today.`, type: 'learning_countdown' };
        return { text: "Your baseline is forming.", type: 'learning_forming' };
      }

      const receipts = {
        daysBelow: patterns.consecutiveBelowBaseline || 0,
        daysAbove: patterns.consecutiveAboveBaseline || 0,
        daysSincePerform: patterns.daysSincePerform || 0,
        daysSinceRest: patterns.daysSinceRest || 0,
        trend: patterns.trend || 'stable',
        totalDays: patterns.totalDays || hrvHistory.length,
        crashCount: patterns.crashesAfterIgnoredRest?.length || 0,
      };
      
      // Get context WITH hrvHistory for confidence calculation
      const context = getContext(command, patterns, complianceLog, hrvHistory);
      const confidence = context.confidence;
      
      // Helper: format date for anchoring (only high confidence + day 14+)
      const formatDateAnchor = (dateStr) => {
        if (!dateStr) return null;
        const date = new Date(dateStr + 'T12:00:00');
        const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        const day = date.getDate();
        const suffix = day === 1 || day === 21 || day === 31 ? 'st' : day === 2 || day === 22 ? 'nd' : day === 3 || day === 23 ? 'rd' : 'th';
        return `${months[date.getMonth()]} ${day}${suffix}`;
      };
      
      const canUseDateAnchors = confidence.level === 'high' && daysOnApp >= 14;

      // Milestones
      const milestones = { 7: "A week. Your baseline is real now. Now we build.", 14: "Two weeks. I know your highs. I know your lows.", 30: "A month. Your rhythms. Now we work together.", 60: "Two months. Your body speaks clearly now.", 90: "Three months. The patterns are undeniable." };
      if (milestones[daysOnApp]) return { text: milestones[daysOnApp], type: `milestone_${daysOnApp}` };

      // ========== REST OBSERVATIONS (confidence-adjusted) ==========
      if (command === 'REST') {
        const frames = [];
        
        // HIGH CONFIDENCE: Date-anchored warnings (Day 14+)
        if (canUseDateAnchors && patterns.nearestMatch?.nextDayCrashed) {
          const anchor = formatDateAnchor(patterns.nearestMatch.date);
          if (anchor) frames.push({ text: `This looks like ${anchor}. That one didn't end well.`, type: 'rest_date_anchor', priority: 12 });
        }
        
        // HIGH CONFIDENCE: Sharp pattern warnings
        if (confidence.level === 'high' && receipts.crashCount >= 2) {
          frames.push({ text: `This pattern usually costs you. Protect today.`, type: 'rest_pattern_warning', priority: 11 });
        }
        
        // MEDIUM CONFIDENCE: Softer language
        if (confidence.level === 'medium') {
          frames.push({ text: "The signal points one direction. Worth respecting.", type: 'rest_medium_conf', priority: 10 });
        }
        
        // LOW CONFIDENCE: Conservative language
        if (confidence.level === 'low') {
          frames.push({ text: "Something's off today. Play it conservative.", type: 'rest_low_conf', priority: 10 });
          frames.push({ text: "Unusual reading. See how tomorrow looks.", type: 'rest_low_conf_2', priority: 10 });
        }
        
        // Standard REST observations
        if (receipts.daysBelow >= 2) frames.push({ text: `Day ${receipts.daysBelow} below baseline. Stay patient.`, type: 'rest_streak', priority: 10 });
        if (receipts.crashCount > 0 && confidence.level !== 'high') frames.push({ text: `You've pushed through REST ${receipts.crashCount} time${receipts.crashCount > 1 ? 's' : ''} and paid. I remember.`, type: 'rest_crash_history', priority: 9 });
        
        const firstPrinciples = ["The work is done. Now the building happens.", "You stressed the system. Now it adapts. Don't interrupt.", "The stimulus is in. The adaptation is happening. Protect it."];
        const permission = ["Not a setback. A setup.", "This isn't stopping. This is building.", "Rest isn't earned. It's required."];
        const stakes = ["Push today, pay tomorrow. Your call.", "The next PERFORM day is being built right now. Guard it.", "You're not sitting out. You're loading the spring."];
        const warnings = ["I know you feel fine. The numbers disagree. Trust the numbers.", "Your mind is ready. Your system isn't. Listen to the system.", "You could push. You'd get away with it today. Tomorrow is the question."];
        
        if (context.isWarning && confidence.level !== 'low') warnings.forEach(w => frames.push({ text: w, type: 'rest_warning', priority: 9 }));
        firstPrinciples.forEach(t => frames.push({ text: t, type: 'rest_first_principles', priority: 7 }));
        permission.forEach(t => frames.push({ text: t, type: 'rest_permission', priority: 6 }));
        stakes.forEach(t => frames.push({ text: t, type: 'rest_stakes', priority: 5 }));
        frames.sort((a, b) => b.priority - a.priority);
        return pick(frames.slice(0, 5));
      }

      // ========== BUILD OBSERVATIONS (confidence-adjusted) ==========
      if (command === 'BUILD') {
        const frames = [];
        
        // LOW CONFIDENCE: Conservative language first
        if (confidence.level === 'low') {
          frames.push({ text: "Something's tilting. Be smart today.", type: 'build_low_conf', priority: 11 });
          frames.push({ text: "The signal isn't clear. Stay controlled.", type: 'build_low_conf_2', priority: 11 });
        }
        
        // MEDIUM CONFIDENCE: Softer language
        if (confidence.level === 'medium') {
          frames.push({ text: "The trend tells a different story than how you feel.", type: 'build_medium_conf', priority: 10 });
        }
        
        const steadyState = ["Room to work. Not room to be reckless.", "Standard capacity. Execute your program.", "Enough in the tank for quality work. Not enough for ego work."];
        const momentum = ["Something's working. Don't change anything.", "Climbing. Let's keep it going.", "The trend is your friend right now."];
        const afterRest = ["Yesterday's rest is showing up. Use it wisely.", "The investment is maturing. Solid work today.", "You rested. This is the dividend. Reinvest carefully."];
        const caution = ["Still in range, but the direction matters. Stay aware.", "BUILD today. But the trend is tilting. Be smart.", "I'm giving you BUILD. I almost gave you REST. Respect that."];
        
        if (context.isAfterRest && confidence.level !== 'low') afterRest.forEach(t => frames.push({ text: t, type: 'build_after_rest', priority: 10 }));
        if (context.isWarning && confidence.level !== 'low') caution.forEach(t => frames.push({ text: t, type: 'build_caution', priority: 9 }));
        if (receipts.trend === 'rising' && confidence.level !== 'low') momentum.forEach(t => frames.push({ text: t, type: 'build_momentum', priority: 8 }));
        steadyState.forEach(t => frames.push({ text: t, type: 'build_steady', priority: 6 }));
        frames.sort((a, b) => b.priority - a.priority);
        return pick(frames.slice(0, 5));
      }

      // ========== PERFORM OBSERVATIONS (confidence-adjusted) ==========
      if (command === 'PERFORM') {
        const frames = [];
        
        // HIGH CONFIDENCE: Date-anchored celebrations or warnings
        if (canUseDateAnchors && patterns.nearestMatch) {
          const anchor = formatDateAnchor(patterns.nearestMatch.date);
          if (anchor && patterns.nearestMatch.pushed && patterns.nearestMatch.nextDayCrashed) {
            frames.push({ text: `You were here on ${anchor}. One effort, then leave—so tomorrow doesn't bite.`, type: 'perform_date_warning', priority: 12 });
          }
        }
        
        // HIGH CONFIDENCE: Sharp language allowed
        if (confidence.level === 'high') {
          frames.push({ text: "The system says yes. All the way yes.", type: 'perform_high_conf', priority: 11 });
        }
        
        // MEDIUM CONFIDENCE: Measured language
        if (confidence.level === 'medium') {
          frames.push({ text: "Green light. The road still has turns.", type: 'perform_medium_conf', priority: 10 });
        }
        
        // LOW CONFIDENCE: Even PERFORM gets conservative language
        if (confidence.level === 'low') {
          frames.push({ text: "The numbers say yes. History says be careful.", type: 'perform_low_conf', priority: 11 });
          frames.push({ text: "Green light—with a flag. Eyes open.", type: 'perform_low_conf_2', priority: 11 });
        }
        
        const pure = ["The tank is full. This is what you've been building toward.", "Green light. No caveats. Go.", "Everything is aligned. This is your day."];
        const earned = ["You rested when I said rest. This is what that buys you.", "You trusted the system. The system is rewarding you."];
        const rare = [`First green light in ${receipts.daysSincePerform} days. Don't waste it.`, "You haven't been here in a while. Welcome back."];
        const cautious = ["Green light. But you've been here before and overcooked it.", "Yes, push. No, don't be stupid.", "Go hard. Then stop. Don't chase the dragon."];
        const consecutive = ["Second straight day. Rare. Use it, but stay aware.", "Back-to-back green. Don't push your luck.", "Two in a row. Go—but know that three is almost never."];
        
        if (context.isConsecutive) consecutive.forEach(t => frames.push({ text: t, type: 'perform_consecutive', priority: 10 }));
        if (context.isWarning && !context.isConsecutive && confidence.level !== 'low') cautious.forEach(t => frames.push({ text: t, type: 'perform_cautious', priority: 9 }));
        if (receipts.daysSincePerform >= 7) rare.forEach(t => frames.push({ text: t, type: 'perform_rare', priority: 10 }));
        if (receipts.daysSinceRest <= 2 && confidence.level !== 'low') earned.forEach(t => frames.push({ text: t, type: 'perform_earned', priority: 8 }));
        if (confidence.level !== 'low') pure.forEach(t => frames.push({ text: t, type: 'perform_pure', priority: 6 }));
        frames.sort((a, b) => b.priority - a.priority);
        return pick(frames.slice(0, 5));
      }
      return { text: "Baseline forming.", type: 'learning' };
    };

    // ============================================
    // THE ACTION SYSTEM
    // Confidence-integrated per spec:
    // Low → always Warning set
    // Medium → Default with softer language  
    // High → Full prescriptions allowed
    // ============================================
    const generateActions = (command, patterns, hrvHistory, complianceLog = []) => {
      if (!patterns || hrvHistory.length < 7) return null;
      const today = new Date();
      const seed = today.getFullYear() * 10000 + (today.getMonth() + 1) * 100 + today.getDate() + (command?.charCodeAt(0) || 0);
      const pick = (arr) => arr.length > 0 ? arr[seed % arr.length] : null;
      
      // Get context WITH hrvHistory for confidence
      const context = getContext(command, patterns, complianceLog, hrvHistory);
      const confidence = context.confidence;
      
      // KEY RULE: Low confidence → always use Warning action set
      const forceWarning = confidence.level === 'low';

      if (command === 'REST') {
        const isWarning = forceWarning || context.isWarning || patterns.trend === 'falling';
        
        if (isWarning) {
          // REST — Warning (Trending Down or Low Confidence)
          return {
            primaryAction: pick([
              "10-20 minute walk. 10 minutes of stretching. That's the whole day.",
              "Movement is optional today. If you do anything, keep it gentle.",
              "Less than you think. Then less than that."
            ]),
            effortBoundary: pick([
              "Nose-breath only. If you can't speak in full sentences, slow down.",
              "RPE 2. Barely above sitting on the couch.",
              "Conversation pace at all times."
            ]),
            recoveryLever: pick([
              "In bed 30-60 minutes earlier than usual tonight.",
              "Double down: 8+ hours sleep, steady water intake, protein every meal.",
              "Cancel or postpone one thing on your calendar. Create space."
            ]),
            guardrail: pick(confidence.level === 'low' ? [
              "Something's off today. Play it conservative.",
              "Not enough data to be certain. When in doubt, rest."
            ] : [
              "I get it—you want to move. Today's win is restraint.",
              "The trend is falling. Every rest hour today is an investment."
            ])
          };
        } else {
          // REST — Default
          return {
            primaryAction: pick([
              "20-30 minutes easy movement. Walk, stretch, foam roll. Stop while it still feels easy.",
              "One walk. One stretch session. Nothing that requires gym clothes.",
              "Move for 20-30 minutes. If you're tempted to do more, that's the signal to stop."
            ]),
            effortBoundary: pick([
              "Nose-breath only. If you need your mouth, slow down.",
              "If you can't hold a full conversation, you're going too hard.",
              "RPE 2-3. You should finish feeling under-stimulated."
            ]),
            recoveryLever: pick([
              "Water before coffee. One bottle by noon. One by dinner.",
              "Protect an 8-hour sleep window tonight.",
              "Protein at every meal. Your body is rebuilding."
            ]),
            guardrail: pick([
              "No lifting today. This is a recovery day.",
              "The gym exists tomorrow. Today it costs more than it gives.",
              "Don't test how you feel with intensity. Trust the number."
            ])
          };
        }
      }

      if (command === 'BUILD') {
        const isAfterRest = context.isAfterRest && !forceWarning;
        const isWarning = forceWarning || context.isWarning || patterns.trend === 'falling';
        
        if (isWarning) {
          // BUILD — Warning (Trending Down or Low Confidence)
          return {
            primaryAction: pick([
              "Same workout. Pull one lever back 20%: lighter load, fewer reps, or shorter time cap. Pick one.",
              "Do 80% of what's programmed. Cut the last movement or the last round.",
              "Abbreviated session. Main work only. Skip accessories entirely."
            ]),
            effortBoundary: pick([
              "RPE 6 ceiling. When form breaks, rack it. No grind reps.",
              "If it turns into survival, stop. A partial session beats a crash.",
              "Cap the session at ~45 minutes if you're trending down."
            ]),
            recoveryLever: pick([
              "In bed 30 minutes earlier than usual tonight.",
              "Protein within 60 minutes. Extra carbs tonight—you're in repair mode.",
              "Stress audit: cancel or postpone one obligation this week."
            ]),
            guardrail: pick(confidence.level === 'low' ? [
              "Something's tilting. Be smart today.",
              "The signal isn't clear. Stay controlled."
            ] : [
              "Don't fight the trend with more effort. That's how 3 bad days become 7.",
              "A shortened session is a win. A crash is a week lost."
            ])
          };
        } else if (isAfterRest) {
          // BUILD — After Rest Day
          return {
            primaryAction: pick([
              "Full programmed work. Finish feeling like you could do a little more—but don't.",
              "Execute the plan completely. No additions. Bank the session.",
              "Yesterday's rest bought this capacity. Spend it wisely, not recklessly."
            ]),
            effortBoundary: pick([
              "RPE 7. Finish with something left. That's fuel for the streak.",
              "Quality reps only. Stop before form degrades.",
              "If you're tempted to add more, that's ego. Stick to the plan."
            ]),
            recoveryLever: pick([
              "Don't undo yesterday's investment. Another good night tonight.",
              "Protein within 2 hours. Stay hydrated—you're still in recovery mode.",
              "Two good days in a row is the goal. Protect the streak."
            ]),
            guardrail: pick([
              "Feeling good doesn't mean 'go all out.' It means 'finish with something left.'",
              "One rest day doesn't clear all debt. Stay patient."
            ])
          };
        } else {
          // BUILD — Default
          return {
            primaryAction: pick([
              "Programmed work only. Skip the finisher. Leave 10 minutes before you normally would.",
              "Full workout. Finish feeling like you could do a little more—and don't.",
              "Do what's written. Nothing extra. Walk out with gas in the tank."
            ]),
            effortBoundary: pick([
              "RPE 7 cap. Finish feeling like you could do a little more.",
              "When form gets questionable, rack it. No grind reps today.",
              "If you're class-based: scale to finish smooth, not wrecked."
            ]),
            recoveryLever: pick([
              "Protein within 2 hours of training. Steady water intake through the day.",
              "Protect 7-8 hours sleep tonight. Tomorrow's capacity depends on it.",
              "Note what felt hard. That's data, not failure."
            ]),
            guardrail: pick([
              "Don't turn a BUILD day into a PERFORM day. They have different purposes.",
              "Today is for deposits, not withdrawals. Save the empty tank for green light days."
            ])
          };
        }
      }

      if (command === 'PERFORM') {
        const isConsecutive = context.isConsecutive;
        const isWarning = (forceWarning || context.isWarning) && !isConsecutive;
        
        if (isConsecutive) {
          // PERFORM — Consecutive (Day 2)
          return {
            primaryAction: pick([
              "Shorter session than yesterday. 75% of the duration, 85% of the intensity.",
              "Main work only. Cut all accessories. Be in and out in 40 minutes.",
              "One moderate-high effort. No true max attempts today."
            ]),
            effortBoundary: pick([
              "RPE 7-8 ceiling. Lower than yesterday. You're spending reserves.",
              "If anything feels off in warm-up, convert to a BUILD day. No questions.",
              "Quality over quantity. Every rep should look the same as rep one."
            ]),
            recoveryLever: pick([
              "Tonight is critical. 8+ hours. Extra protein. Steady hydration.",
              "This is probably your last green for a while. Plan for REST tomorrow.",
              "Recovery starts the moment you leave. Prioritize it over everything else tonight."
            ]),
            guardrail: pick([
              "Three consecutive PERFORMs almost never end well. Don't chase the hat trick.",
              "The third day is where problems happen. Stop while you're ahead.",
              "Tomorrow's REST is already scheduled. Accept it now."
            ])
          };
        } else if (isWarning) {
          // PERFORM — Warning (Pattern Risk or Low Confidence)
          return {
            primaryAction: pick([
              "One hard effort in the first 15 minutes. Then coast. No encores today.",
              "Hit your main work at RPE 8. Skip accessories entirely. Leave before you pay for it.",
              "Attack, then retreat. Don't linger looking for more."
            ]),
            effortBoundary: pick([
              "RPE 8 once. Then immediately drop to 6. Hard stop.",
              "Set a time limit: ~45 minutes including warm-up. Then leave.",
              "One solid effort. Whether it's a PR or not, move on."
            ]),
            recoveryLever: pick([
              "Double down on recovery tonight. This pattern has cost you before.",
              "Protein within 30 minutes. Extra sleep: in bed 30 minutes earlier.",
              "What you do in the next 12 hours matters more than what you did in the gym."
            ]),
            guardrail: pick(confidence.level === 'low' ? [
              "The numbers say yes. History says be careful.",
              "Green light—with a flag. Eyes open."
            ] : [
              "The green light doesn't erase the pattern. Stay sharp.",
              "Confidence is fuel. Overconfidence gets expensive."
            ])
          };
        } else {
          // PERFORM — Default
          return {
            primaryAction: pick([
              "The tank is full. Put your hardest work in the first 15-20 minutes.",
              "Green light. Execute the effort you've been holding back.",
              "Capacity is peaking. Use it—you can't save it."
            ]),
            effortBoundary: pick([
              "One peak effort. RPE 8-9 allowed, then coast at 6-7. Don't chase a second peak.",
              "Leave a rep in reserve even on the hardest set. That's the discipline.",
              "~45-60 minutes, then leave. No bonus volume."
            ]),
            recoveryLever: pick([
              "Refuel within 60 minutes. Carbs + protein.",
              "Protect an 8-hour sleep window tonight. This is the ROI on today's effort.",
              "Tomorrow will tell you if you got this right. Plan for a BUILD or REST."
            ]),
            guardrail: pick([
              "Don't turn a great day into a two-day hangover. One peak. Then done.",
              "The extra set, the extra attempt, the 'one more'—that's where problems start.",
              "Sustainable peaks beat one-time glory. There will be more green days if you're smart."
            ])
          };
        }
      }
      return null;
    };

    // ============================================
    // COLORS - Earthy, organic palette
    // ============================================
    const COMMAND_STYLES = {
      REST: { color: '#e8b89d', bg: 'rgba(232, 184, 157, 0.12)', border: 'rgba(232, 184, 157, 0.2)', glow: 'rgba(232, 184, 157, 0.1)' },
      BUILD: { color: '#c9b896', bg: 'rgba(201, 184, 150, 0.12)', border: 'rgba(201, 184, 150, 0.2)', glow: 'rgba(201, 184, 150, 0.1)' },
      PERFORM: { color: '#9dc4a8', bg: 'rgba(157, 196, 168, 0.12)', border: 'rgba(157, 196, 168, 0.2)', glow: 'rgba(157, 196, 168, 0.1)' },
      LEARNING: { color: '#a8b5a8', bg: 'rgba(168, 181, 168, 0.12)', border: 'rgba(168, 181, 168, 0.2)', glow: 'rgba(168, 181, 168, 0.1)' },
    };

    // ============================================
    // TYPEWRITER COMPONENT - Word by word reveal
    // ============================================
    const Typewriter = ({ text, speed = 80, onComplete, className = '' }) => {
      const [displayedWords, setDisplayedWords] = useState(0);
      const [isComplete, setIsComplete] = useState(false);
      const words = text ? text.split(' ') : [];
      
      useEffect(() => {
        if (!text) return;
        setDisplayedWords(0);
        setIsComplete(false);
      }, [text]);
      
      useEffect(() => {
        if (displayedWords < words.length) {
          const timer = setTimeout(() => {
            setDisplayedWords(prev => prev + 1);
          }, speed);
          return () => clearTimeout(timer);
        } else if (words.length > 0 && !isComplete) {
          setIsComplete(true);
          onComplete?.();
        }
      }, [displayedWords, words.length, speed, isComplete, onComplete]);
      
      const visibleText = words.slice(0, displayedWords).join(' ');
      const showCursor = !isComplete && words.length > 0;
      
      return (
        <span className={className}>
          {visibleText}
          {showCursor && <span className="animate-pulse ml-0.5">|</span>}
        </span>
      );
    };

    // Tagline Component
    const Tagline = () => (
      <div className="fixed bottom-6 left-0 right-0 text-center fade-in-delay-3" style={{ zIndex: 10, pointerEvents: 'none' }}>
        <p className="text-white/40 text-sm tracking-wide mb-2">Your body is talking.</p>
        <svg className="mx-auto float" width="24" height="24" viewBox="0 0 24 24" fill="none">
          <path d="M12 22C12 22 12 16 12 14C12 12 10 10 8 10C6 10 4 12 4 14C4 16 6 18 8 18" stroke="#8b9b7a" strokeWidth="1.5" strokeLinecap="round"/>
          <path d="M12 22C12 22 12 16 12 14C12 12 14 10 16 10C18 10 20 12 20 14C20 16 18 18 16 18" stroke="#a8b89a" strokeWidth="1.5" strokeLinecap="round"/>
        </svg>
      </div>
    );

    // ============================================
    // FEEDBACK MODAL - The Invitation (glassmorphism)
    // ============================================
    const FeedbackModal = ({ 
      round, daysOnApp,
      step, setStep, 
      response, setResponse, 
      text, setText, 
      email, setEmail, 
      onSend, onDismiss 
    }) => (
      <div className="fixed inset-0 bg-black/70 backdrop-blur-md flex items-center justify-center p-6 z-50">
        <div className="max-w-sm w-full space-y-8">
          
          {/* Round 1 (Day 10-14): The Commitment */}
          {round === 1 && (
            <>
              {step === 1 && (
                <div className="text-center space-y-8 fade-in">
                  <div className="space-y-4">
                    <p className="text-white/30 text-sm tracking-wide">Day {daysOnApp}</p>
                    <p className="text-white text-xl leading-relaxed">Most people quit by now.</p>
                    <p className="text-white/60">You didn't.</p>
                  </div>
                  <button onClick={() => setStep(2)} className="text-white/40 hover:text-white text-sm transition">Continue →</button>
                </div>
              )}

              {step === 2 && (
                <div className="text-center space-y-6 fade-in">
                  <p className="text-white text-lg">What are you building toward?</p>
                  <div className="space-y-2">
                    {[
                      { key: 'competition', label: 'Competition' },
                      { key: 'longevity', label: 'Longevity' },
                      { key: 'consistency', label: 'Staying consistent' },
                      { key: 'feeling', label: 'Feeling better' },
                      { key: 'other', label: 'Something else' },
                    ].map(opt => (
                      <button key={opt.key} onClick={() => { setResponse(opt.key); setStep(opt.key === 'other' ? 3 : 4); }} className="w-full glass hover:bg-white/10 text-white/70 py-3 rounded-2xl text-sm transition-all duration-300">{opt.label}</button>
                    ))}
                  </div>
                  <button onClick={() => onDismiss(false)} className="text-white/20 text-xs">Skip</button>
                </div>
              )}

              {step === 3 && (
                <div className="text-center space-y-6 fade-in">
                  <p className="text-white text-lg">Tell me more.</p>
                  <textarea value={text} onChange={(e) => setText(e.target.value)} placeholder="What are you working toward..." className="w-full glass rounded-2xl px-4 py-3 text-white text-sm placeholder-white/30 focus:outline-none resize-none h-24" autoFocus />
                  <button onClick={() => setStep(4)} className="w-full bg-white/90 text-black font-medium py-3 rounded-2xl">Continue</button>
                </div>
              )}

              {step === 4 && (
                <div className="text-center space-y-6 fade-in">
                  <div className="space-y-3">
                    <p className="text-white text-lg">I'm building something too.</p>
                    <p className="text-white/40 text-sm">Auto-sync. Deeper patterns.<br/>Predictions before you feel them.</p>
                  </div>
                  <div className="space-y-3 pt-2">
                    <p className="text-white/50 text-sm">Want early access?</p>
                    <input type="email" value={email} onChange={(e) => setEmail(e.target.value)} placeholder="Email" className="w-full glass rounded-2xl px-4 py-3 text-white text-sm text-center placeholder-white/30 focus:outline-none" />
                  </div>
                  <div className="space-y-2">
                    <button onClick={onSend} className="w-full bg-white/90 text-black font-medium py-3 rounded-2xl">I'm in</button>
                    <button onClick={onSend} className="w-full text-white/40 text-sm py-2">Just keep going</button>
                  </div>
                </div>
              )}
            </>
          )}

          {/* Round 2 (Day 35-45): The Inner Circle */}
          {round === 2 && (
            <>
              {step === 1 && (
                <div className="text-center space-y-8 fade-in">
                  <div className="space-y-4">
                    <p className="text-white/30 text-sm tracking-wide">Day {daysOnApp}</p>
                    <p className="text-white text-xl leading-relaxed">You're still here.</p>
                    <p className="text-white/40 text-sm">That puts you ahead of 95% of people<br/>who try to train smarter.</p>
                  </div>
                  <button onClick={() => setStep(2)} className="text-white/40 hover:text-white text-sm transition">Continue →</button>
                </div>
              )}

              {step === 2 && (
                <div className="text-center space-y-6 fade-in">
                  <div className="space-y-2">
                    <p className="text-white text-lg">I'm building the next version.</p>
                    <p className="text-white/40 text-sm">What would make this twice as valuable?</p>
                  </div>
                  <textarea value={text} onChange={(e) => setText(e.target.value)} placeholder="The one thing..." className="w-full glass rounded-2xl px-4 py-3 text-white text-sm placeholder-white/30 focus:outline-none resize-none h-24" autoFocus />
                  <button onClick={() => setStep(3)} className="w-full bg-white/90 text-black font-medium py-3 rounded-2xl">Continue</button>
                  <button onClick={() => setStep(3)} className="text-white/20 text-xs">Skip</button>
                </div>
              )}

              {step === 3 && (
                <div className="text-center space-y-6 fade-in">
                  <div className="space-y-3">
                    <p className="text-white text-lg">One more thing.</p>
                    <p className="text-white/40 text-sm">Anyone in your life who needs this?</p>
                    <p className="text-white/25 text-xs">A training partner. Someone who never rests.<br/>A friend who's always overtrained.</p>
                  </div>
                  <div className="space-y-2">
                    <button onClick={() => { setResponse('yes'); setStep(4); }} className="w-full glass hover:bg-white/10 text-white/70 py-3 rounded-2xl text-sm transition-all">Yes, I know someone</button>
                    <button onClick={() => { setResponse('no'); onSend(); }} className="w-full text-white/40 text-sm py-2">Not right now</button>
                  </div>
                </div>
              )}

              {step === 4 && (
                <div className="text-center space-y-6 fade-in">
                  <p className="text-white text-lg">I'll make sure they get in.</p>
                  <input type="text" value={email} onChange={(e) => setEmail(e.target.value)} placeholder="Their email or name" className="w-full glass rounded-2xl px-4 py-3 text-white text-sm text-center placeholder-white/30 focus:outline-none" autoFocus />
                  <button onClick={onSend} className="w-full bg-white/90 text-black font-medium py-3 rounded-2xl">Done</button>
                  <button onClick={onSend} className="text-white/20 text-xs">Skip</button>
                </div>
              )}
            </>
          )}
        </div>
      </div>
    );

    // ============================================
    // HRV SOURCE SELECTOR
    // ============================================
    const HRV_SOURCES = [
      { id: 'whoop', label: 'WHOOP' },
      { id: 'apple', label: 'Apple Watch' },
      { id: 'oura', label: 'Oura' },
      { id: 'garmin', label: 'Garmin' },
      { id: 'fitbit', label: 'Fitbit' },
    ];

    // ============================================
    // INFO MODAL - How GENYSYS Works
    // ============================================
    const InfoModal = ({ onClose, hrvSource }) => {
      // Device-specific HRV instructions
      const getHrvInstructions = () => {
        const deviceId = hrvSource?.id || 'apple';
        const deviceLabel = hrvSource?.label || 'Apple Watch';
        
        const instructions = {
          apple: {
            title: 'Where to find your HRV (Apple Watch)',
            steps: [
              'Open the Health app on your iPhone',
              'Tap Browse → Heart → Heart Rate Variability',
              'Look at your most recent morning reading',
              'Use the number in milliseconds (ms)'
            ]
          },
          whoop: {
            title: 'Where to find your HRV (WHOOP)',
            steps: [
              'Open the WHOOP app',
              'Tap on your daily Recovery score',
              'Scroll to "Heart Rate Variability"',
              'Use the number in milliseconds (ms)'
            ]
          },
          garmin: {
            title: 'Where to find your HRV (Garmin)',
            steps: [
              'Open Garmin Connect app',
              'Go to Health Stats → Heart Rate Variability',
              'Check your morning HRV Status reading',
              'Use the number in milliseconds (ms)'
            ]
          },
          oura: {
            title: 'Where to find your HRV (Oura)',
            steps: [
              'Open the Oura app',
              'Tap on Readiness tab',
              'Scroll to "HRV Balance"',
              'Tap to see your average HRV in milliseconds'
            ]
          },
          fitbit: {
            title: 'Where to find your HRV (Fitbit)',
            steps: [
              'Open the Fitbit app',
              'Tap the Health Metrics tile',
              'Find "Heart Rate Variability"',
              'Use your daily average in milliseconds'
            ]
          },
          polar: {
            title: 'Where to find your HRV (Polar)',
            steps: [
              'Open Polar Flow app',
              'Go to your Nightly Recharge report',
              'Find "ANS Charge" which includes HRV',
              'Use the RMSSD value in milliseconds'
            ]
          },
          samsung: {
            title: 'Where to find your HRV (Samsung)',
            steps: [
              'Open Samsung Health app',
              'Go to Home → Stress measurement',
              'Take a stress reading (includes HRV)',
              'Use the HRV value in milliseconds'
            ]
          },
          custom: {
            title: `Where to find your HRV (${deviceLabel})`,
            steps: [
              `Please check the ${deviceLabel} app or website`,
              'Look for Heart Rate Variability or HRV',
              'Find your most recent morning reading',
              'Use the number in milliseconds (ms)'
            ]
          }
        };
        
        return instructions[deviceId] || instructions.custom;
      };
      
      const hrvInstructions = getHrvInstructions();
      
      return (
      <div className="fixed inset-0 z-50 flex items-center justify-center p-4">
        <div className="absolute inset-0 bg-black/70 backdrop-blur-sm" onClick={onClose}></div>
        <div className="glass rounded-3xl p-6 max-w-sm w-full relative z-10 max-h-[85vh] overflow-y-auto space-y-5">
          <div className="flex justify-between items-start">
            <h2 className="text-white text-lg font-medium">How GENYSYS Works</h2>
            <button onClick={onClose} className="text-white/40 hover:text-white text-xl">×</button>
          </div>
          
          <p className="text-white/60 text-sm leading-relaxed">
            Your nervous system tells us how recovered you are. We read it. We tell you what to do.
          </p>
          
          <div className="space-y-2">
            <div className="flex items-start gap-3">
              <span className="text-[#e8b89d] font-bold text-sm">REST</span>
              <span className="text-white/50 text-sm">Light movement only. System needs recovery.</span>
            </div>
            <div className="flex items-start gap-3">
              <span className="text-[#c9b896] font-bold text-sm">BUILD</span>
              <span className="text-white/50 text-sm">Standard training. Execute your program.</span>
            </div>
            <div className="flex items-start gap-3">
              <span className="text-[#9dc4a8] font-bold text-sm">PERFORM</span>
              <span className="text-white/50 text-sm">System primed. Push hard. Chase PRs.</span>
            </div>
          </div>
          
          <div className="border-t border-white/10 pt-4 space-y-2">
            <h3 className="text-white/80 text-sm font-medium">What is HRV?</h3>
            <p className="text-white/50 text-xs leading-relaxed">
              Heart Rate Variability — the time variation between heartbeats, measured in milliseconds (ms). Higher usually means more recovered. Most people range from 20-100ms.
            </p>
          </div>
          
          <div className="border-t border-white/10 pt-4 space-y-2">
            <h3 className="text-white/80 text-sm font-medium">{hrvInstructions.title}</h3>
            <ol className="text-white/50 text-xs leading-relaxed space-y-1 list-decimal list-inside">
              {hrvInstructions.steps.map((step, i) => (
                <li key={i}>{step}</li>
              ))}
            </ol>
          </div>
          
          <div className="border-t border-white/10 pt-4 space-y-2">
            <h3 className="text-white/80 text-sm font-medium">The Process</h3>
            <ol className="text-white/50 text-xs leading-relaxed space-y-1 list-decimal list-inside">
              <li>Log your morning HRV from your device</li>
              <li>After 3 days: Preview commands begin</li>
              <li>After 7 days: Full personalized baseline</li>
            </ol>
          </div>
          
          <div className="border-t border-white/10 pt-4 space-y-2">
            <h3 className="text-white/80 text-sm font-medium">No Wearable?</h3>
            <p className="text-white/50 text-xs leading-relaxed mb-2">
              Download Welltory (free). Take a 1-minute reading with your phone camera each morning.
            </p>
            <div className="flex gap-2">
              <a 
                href="https://apps.apple.com/app/welltory-heart-rate-monitor/id1074367771" 
                target="_blank" 
                rel="noopener noreferrer"
                className="glass-light rounded-lg px-3 py-1.5 text-xs text-white/60 hover:text-white transition-all"
              >
                iOS App Store
              </a>
              <a 
                href="https://play.google.com/store/apps/details?id=com.welltory.client.android" 
                target="_blank" 
                rel="noopener noreferrer"
                className="glass-light rounded-lg px-3 py-1.5 text-xs text-white/60 hover:text-white transition-all"
              >
                Google Play
              </a>
            </div>
          </div>
          
          <div className="bg-amber-500/10 border border-amber-500/20 rounded-xl p-3">
            <p className="text-amber-400/80 text-xs leading-relaxed">
              <span className="font-medium">⚠️ Use the Same Device</span><br/>
              Your data is stored locally on this device only. It won't transfer to other phones or computers. Always log from the same device.
            </p>
          </div>
          
          <p className="text-white/30 text-xs text-center pt-2">
            GENYSYS Private Beta — Your feedback shapes what we build next.
          </p>
        </div>
      </div>
    )};

    // ============================================
    // TEST DATA GENERATORS
    // ============================================
    const generateTestData = (days, scenario = 'normal') => {
      const history = [];
      const compliance = [];
      const today = new Date();
      
      // Base HRV around 55 with natural variation
      let baseHRV = 55;
      
      for (let i = days - 1; i >= 0; i--) {
        const date = new Date(today);
        date.setDate(date.getDate() - i);
        const dateStr = getLocalDateString(date);
        
        let hrv;
        if (scenario === 'crashing') {
          // Simulates someone who ignores REST and crashes
          hrv = baseHRV + (Math.random() * 20 - 10) - (i < 3 ? 15 : 0);
        } else if (scenario === 'recovering') {
          // Simulates someone coming out of a low period
          hrv = baseHRV + (Math.random() * 10) + (days - i) * 0.5;
        } else if (scenario === 'volatile') {
          // Big swings
          hrv = baseHRV + (Math.random() * 40 - 20);
        } else if (scenario === 'stable') {
          // Very consistent
          hrv = baseHRV + (Math.random() * 6 - 3);
        } else {
          // Normal variation
          hrv = baseHRV + (Math.random() * 16 - 8);
        }
        
        history.push({ date: dateStr, value: Math.round(hrv) });
        
        // Add some compliance data
        if (i > 0 && Math.random() > 0.3) {
          const values = history.slice(0, -1).map(h => h.value);
          if (values.length >= 3) {
            const median = calculateMedian(values);
            const mad = calculateMAD(values, median);
            const z = (hrv - median) / mad;
            const command = getCommandKey(z);
            
            compliance.push({
              date: dateStr,
              command,
              followed: Math.random() > 0.3 ? 'yes' : 'no'
            });
          }
        }
      }
      
      return { history, compliance };
    };

    // ============================================
    // MAIN APP
    // ============================================
    const App = () => {
      // Core state
      const [hrvHistory, setHrvHistory] = useState([]);
      const [complianceLog, setComplianceLog] = useState([]);
      const [firstUseDate, setFirstUseDate] = useState(null);
      const [hrvSource, setHrvSource] = useState(null);
      const [userName, setUserName] = useState('');
      const [isLoading, setIsLoading] = useState(true);
      
      // UI state
      const [todayHRV, setTodayHRV] = useState('');
      const [result, setResult] = useState(null);
      const [showAddHistory, setShowAddHistory] = useState(false);
      const [customDevice, setCustomDevice] = useState('');
      const [showInfoModal, setShowInfoModal] = useState(false);
      const [newEntry, setNewEntry] = useState('');
      const [newEntryDate, setNewEntryDate] = useState(getYesterdayLocal());
      
      // Observation tracking
      const [lastObservationType, setLastObservationType] = useState(null);
      const [lastObservationDate, setLastObservationDate] = useState(null);

      // Feedback state
      const [showFeedback, setShowFeedback] = useState(false);
      const [feedbackRound, setFeedbackRound] = useState(1);
      const [feedbackStep, setFeedbackStep] = useState(1);
      const [feedbackResponse, setFeedbackResponse] = useState(null);
      const [feedbackText, setFeedbackText] = useState('');
      const [feedbackEmail, setFeedbackEmail] = useState('');
      const [feedbackRound1Complete, setFeedbackRound1Complete] = useState(false);
      const [feedbackRound1Response, setFeedbackRound1Response] = useState(null);
      const [feedbackRound1DismissedAt, setFeedbackRound1DismissedAt] = useState(null);
      const [feedbackRound2Complete, setFeedbackRound2Complete] = useState(false);

      // TEST MODE state
      const [showDebug, setShowDebug] = useState(false);
      const [simulatedDaysOnApp, setSimulatedDaysOnApp] = useState(null);

      // Load from localStorage
      useEffect(() => {
        try {
          const saved = localStorage.getItem('genysys_v2_test_data');
          if (saved) {
            const data = JSON.parse(saved);
            setHrvHistory(data.hrvHistory || []);
            setComplianceLog(data.complianceLog || []);
            setFirstUseDate(data.firstUseDate || null);
            setHrvSource(data.hrvSource || null);
            setUserName(data.userName || '');
            setLastObservationType(data.lastObservationType || null);
            setLastObservationDate(data.lastObservationDate || null);
            setFeedbackRound1Complete(data.feedbackRound1Complete || false);
            setFeedbackRound1Response(data.feedbackRound1Response || null);
            setFeedbackRound1DismissedAt(data.feedbackRound1DismissedAt || null);
            setFeedbackRound2Complete(data.feedbackRound2Complete || false);
          }
        } catch (e) { 
          console.log('No saved data'); 
        }
        setIsLoading(false);
      }, []);

      // Save to localStorage
      useEffect(() => {
        if (isLoading) return;
        localStorage.setItem('genysys_v2_test_data', JSON.stringify({
          hrvHistory, complianceLog, firstUseDate, hrvSource, userName,
          lastObservationType, lastObservationDate,
          feedbackRound1Complete, feedbackRound1Response, feedbackRound1DismissedAt, feedbackRound2Complete
        }));
      }, [hrvHistory, complianceLog, firstUseDate, hrvSource, userName, lastObservationType, lastObservationDate, feedbackRound1Complete, feedbackRound1Response, feedbackRound1DismissedAt, feedbackRound2Complete, isLoading]);

      // Set firstUseDate when they start
      useEffect(() => {
        if (hrvSource && !firstUseDate) {
          setFirstUseDate(getTodayLocal());
        }
      }, [hrvSource, firstUseDate]);

      // Calculate days on app (or use simulated) - handle timezone properly
      const daysOnApp = useMemo(() => {
        if (simulatedDaysOnApp !== null) return simulatedDaysOnApp;
        if (!firstUseDate) return 1;
        const start = new Date(firstUseDate + 'T00:00:00');
        const now = new Date();
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        const startDay = new Date(start.getFullYear(), start.getMonth(), start.getDate());
        return Math.max(1, Math.floor((today - startDay) / (1000 * 60 * 60 * 24)) + 1);
      }, [firstUseDate, simulatedDaysOnApp]);

      // Auto-calculate if today's data exists
      useEffect(() => {
        if (isLoading || !hrvSource) return;
        const todayDate = getTodayLocal();
        const todayEntry = hrvHistory.find(h => h.date === todayDate);
        if (todayEntry) {
          setTodayHRV(todayEntry.value.toString());
          calculateResult(todayEntry.value, hrvHistory);
        }
      }, [isLoading, hrvHistory, hrvSource]);

      const calculateResult = (hrv, history) => {
        const todayDate = getTodayLocal();
        const historyWithoutToday = history.filter(h => h.date !== todayDate);
        const values = historyWithoutToday.map(h => h.value);
        
        const isPreview = values.length >= THRESHOLDS.MIN_PREVIEW_DAYS && values.length < THRESHOLDS.MIN_DAYS;
        
        if (values.length < THRESHOLDS.MIN_PREVIEW_DAYS) {
          setResult({ 
            commandKey: 'LEARNING', 
            daysNeeded: THRESHOLDS.MIN_PREVIEW_DAYS - values.length,
            isPreview: false 
          });
          return;
        }
        
        const median = calculateMedian(values);
        const mad = calculateMAD(values, median);
        const zScore = (hrv - median) / mad;
        const commandKey = getCommandKey(zScore);
        
        // Use total entries (including today) for countdown to match user expectation
        const totalEntries = history.length;
        const daysUntilFull = isPreview ? Math.max(0, THRESHOLDS.MIN_DAYS - totalEntries) : 0;
        
        setResult({ 
          commandKey, 
          baseline: median, 
          mad, 
          zScore, 
          todayValue: hrv,
          isPreview: daysUntilFull > 0, // Only show preview if there are still days remaining
          daysUntilFull
        });

        const existingLog = complianceLog.findIndex(c => c.date === todayDate);
        if (existingLog >= 0) {
          setComplianceLog(complianceLog.map((c, i) => i === existingLog ? { ...c, command: commandKey } : c));
        } else {
          setComplianceLog([...complianceLog, { date: todayDate, command: commandKey, followed: null }]);
        }
      };

      const handleSubmitHRV = () => {
        const hrv = parseFloat(todayHRV);
        if (isNaN(hrv) || hrv <= 0) return;
        
        const todayDate = getTodayLocal();
        let newHistory = [...hrvHistory];
        const existingIndex = newHistory.findIndex(h => h.date === todayDate);
        
        if (existingIndex >= 0) {
          newHistory[existingIndex] = { value: hrv, date: todayDate };
        } else {
          newHistory.push({ value: hrv, date: todayDate });
        }
        
        newHistory.sort((a, b) => new Date(a.date) - new Date(b.date));
        setHrvHistory(newHistory);
        calculateResult(hrv, newHistory);

        if (lastObservationDate !== todayDate) {
          setLastObservationType(null);
          setLastObservationDate(todayDate);
        }
      };

      const addHistoricalEntry = () => {
        const val = parseFloat(newEntry);
        if (isNaN(val) || val <= 0) return;
        
        let newHistory = [...hrvHistory];
        const existingIndex = newHistory.findIndex(h => h.date === newEntryDate);
        
        if (existingIndex >= 0) {
          newHistory[existingIndex] = { value: val, date: newEntryDate };
        } else {
          newHistory.push({ value: val, date: newEntryDate });
        }
        
        newHistory.sort((a, b) => new Date(a.date) - new Date(b.date));
        setHrvHistory(newHistory);
        setNewEntry('');
        
        // Immediately recalculate result if today's entry exists (keeps bullets in sync)
        const todayDate = getTodayLocal();
        const todayEntry = newHistory.find(h => h.date === todayDate);
        if (todayEntry) {
          calculateResult(todayEntry.value, newHistory);
        }
        
        // Move date back by one day for next entry (use noon to avoid timezone/DST issues)
        const prevDate = new Date(newEntryDate + 'T12:00:00');
        prevDate.setDate(prevDate.getDate() - 1);
        setNewEntryDate(getLocalDateString(prevDate));
      };

      const deleteHistoricalEntry = (dateToDelete) => {
        const newHistory = hrvHistory.filter(h => h.date !== dateToDelete);
        setHrvHistory(newHistory);
        
        // Also remove any compliance log for that date
        setComplianceLog(complianceLog.filter(c => c.date !== dateToDelete));
        
        // If we deleted today's entry, clear the result
        if (dateToDelete === getTodayLocal()) {
          setResult(null);
        }
      };

      // Yesterday compliance
      const yesterdayDate = getYesterdayLocal();
      const yesterdayLog = complianceLog.find(c => c.date === yesterdayDate);
      const needsYesterdayCompliance = yesterdayLog?.command && 
        yesterdayLog.command !== 'LEARNING' && 
        yesterdayLog.followed === null;

      const recordCompliance = (followed) => {
        setComplianceLog(complianceLog.map(c => 
          c.date === yesterdayDate ? { ...c, followed } : c
        ));
      };

      // Pattern analysis
      const patterns = useMemo(() => 
        analyzePatterns(hrvHistory, complianceLog, firstUseDate),
        [hrvHistory, complianceLog, firstUseDate]
      );

      // Store observation in state to prevent recalculation loops
      const [currentObservation, setCurrentObservation] = useState(null);
      const lastCommandRef = useRef(null);

      // Generate observation only when command changes
      useEffect(() => {
        if (!result) {
          setCurrentObservation(null);
          return;
        }
        
        // During learning phase, always regenerate when hrvHistory changes
        const commandKey = result.commandKey;
        const isLearning = commandKey === 'LEARNING';
        
        // Only skip regeneration if command unchanged AND not in learning phase
        if (commandKey === lastCommandRef.current && !isLearning) return;
        
        lastCommandRef.current = commandKey;
        
        const obs = generateObservation(
          commandKey, 
          patterns, 
          daysOnApp, 
          lastObservationType,
          hrvHistory
        );
        
        setCurrentObservation(obs);
        
        if (obs && obs.type !== lastObservationType) {
          setLastObservationType(obs.type);
        }
      }, [result?.commandKey, patterns, daysOnApp, hrvHistory.length]);

      // Use currentObservation instead of computed observation
      const observation = currentObservation;

      // Generate action system
      const actions = useMemo(() => {
        if (!result) return null;
        return generateActions(result.commandKey, patterns, hrvHistory, complianceLog);
      }, [result, patterns, hrvHistory, complianceLog]);

      const hasTodayHRV = hrvHistory.some(h => h.date === getTodayLocal());
      const styles = result ? COMMAND_STYLES[result.commandKey] : COMMAND_STYLES.LEARNING;

      // ============================================
      // FEEDBACK SYSTEM
      // ============================================
      const shouldShowFeedback = () => {
        if (!feedbackRound1Complete && !feedbackRound1DismissedAt && daysOnApp >= 10 && daysOnApp <= 14) return 1;
        if (!feedbackRound2Complete && daysOnApp >= 35 && daysOnApp <= 45) {
          if (feedbackRound1Response === 'yes' || feedbackRound1Complete || daysOnApp >= 35) return 2;
        }
        return 0;
      };

      useEffect(() => {
        if (result && result.commandKey && result.commandKey !== 'LEARNING') {
          const round = shouldShowFeedback();
          if (round > 0) {
            const timer = setTimeout(() => {
              setFeedbackRound(round);
              setFeedbackStep(1);
              setFeedbackResponse(null);
              setFeedbackText('');
              setShowFeedback(true);
            }, 2000);
            return () => clearTimeout(timer);
          }
        }
      }, [result?.commandKey, daysOnApp]);

      const sendFeedback = () => {
        if (feedbackRound === 1) {
          setFeedbackRound1Complete(true);
          setFeedbackRound1Response(feedbackResponse);
        } else if (feedbackRound === 2) {
          setFeedbackRound2Complete(true);
        }
        setShowFeedback(false);
        setFeedbackStep(1);
        setFeedbackText('');
        setFeedbackEmail('');
      };

      const dismissFeedback = (dontAskAgain) => {
        if (feedbackRound === 1) {
          if (dontAskAgain) setFeedbackRound1Complete(true);
          else setFeedbackRound1DismissedAt(getTodayLocal());
        } else if (feedbackRound === 2) {
          setFeedbackRound2Complete(true);
        }
        setShowFeedback(false);
        setFeedbackStep(1);
      };

      // Reset function
      const resetAll = () => {
        localStorage.removeItem('genysys_v2_test_data');
        setHrvHistory([]);
        setComplianceLog([]);
        setFirstUseDate(null);
        setHrvSource(null);
        setUserName('');
        setResult(null);
        setTodayHRV('');
        setLastObservationType(null);
        setLastObservationDate(null);
        setSimulatedDaysOnApp(null);
        setFeedbackRound1Complete(false);
        setFeedbackRound1Response(null);
        setFeedbackRound1DismissedAt(null);
        setFeedbackRound2Complete(false);
      };

      // Load test scenario
      const loadTestScenario = (days, scenario) => {
        const { history, compliance } = generateTestData(days, scenario);
        setHrvHistory(history);
        setComplianceLog(compliance);
        setHrvSource({ id: 'test', label: 'Test Mode' });
        
        // Set first use date to simulate correct days on app
        const firstDate = new Date();
        firstDate.setDate(firstDate.getDate() - days + 1);
        setFirstUseDate(getLocalDateString(firstDate));
        
        // Calculate result for today
        const today = history.find(h => h.date === getTodayLocal());
        if (today) {
          setTodayHRV(today.value.toString());
          calculateResult(today.value, history);
        }
      };

      if (isLoading) {
        return (
          <div className="min-h-screen text-white flex items-center justify-center">
            <div className="mist-overlay"></div>
            <div className="content-layer text-white/40 pulse-slow">...</div>
          </div>
        );
      }

      // ============================================
      // DEBUG PANEL
      // ============================================
      const DebugPanel = () => (
        <div className="fixed bottom-0 left-0 right-0 bg-zinc-900 border-t border-zinc-800 p-4 z-50">
          <div className="max-w-lg mx-auto space-y-4">
            <div className="flex justify-between items-center">
              <span className="text-xs text-zinc-500 font-mono">TEST MODE</span>
              <button onClick={() => setShowDebug(false)} className="text-zinc-500 text-lg">×</button>
            </div>
            
            {/* Quick load scenarios */}
            <div className="space-y-2">
              <div className="text-xs text-zinc-600">Load Test Scenario:</div>
              <div className="flex flex-wrap gap-2">
                <button onClick={() => loadTestScenario(7, 'normal')} className="bg-zinc-800 px-3 py-1 rounded text-xs">Day 7 Normal</button>
                <button onClick={() => loadTestScenario(30, 'normal')} className="bg-zinc-800 px-3 py-1 rounded text-xs">Day 30 Normal</button>
                <button onClick={() => loadTestScenario(60, 'normal')} className="bg-zinc-800 px-3 py-1 rounded text-xs">Day 60 Normal</button>
                <button onClick={() => loadTestScenario(90, 'normal')} className="bg-zinc-800 px-3 py-1 rounded text-xs">Day 90 Normal</button>
                <button onClick={() => loadTestScenario(14, 'crashing')} className="bg-red-900/50 px-3 py-1 rounded text-xs">Crashing</button>
                <button onClick={() => loadTestScenario(14, 'recovering')} className="bg-green-900/50 px-3 py-1 rounded text-xs">Recovering</button>
                <button onClick={() => loadTestScenario(14, 'volatile')} className="bg-amber-900/50 px-3 py-1 rounded text-xs">Volatile</button>
              </div>
            </div>

            {/* Simulate days */}
            <div className="flex items-center gap-2">
              <span className="text-xs text-zinc-600">Simulate Day:</span>
              <input
                type="number"
                value={simulatedDaysOnApp || ''}
                onChange={(e) => setSimulatedDaysOnApp(e.target.value ? parseInt(e.target.value) : null)}
                placeholder="actual"
                className="w-20 bg-zinc-800 rounded px-2 py-1 text-xs"
              />
              <button 
                onClick={() => setSimulatedDaysOnApp(null)}
                className="text-xs text-zinc-500"
              >
                reset
              </button>
            </div>

            {/* Current state */}
            <div className="text-xs font-mono text-zinc-600 space-y-1">
              <div>Days: {daysOnApp} | HRV entries: {hrvHistory.length} | Compliance: {complianceLog.length}</div>
              <div>Command: {result?.commandKey || 'none'} | Z: {result?.zScore?.toFixed(2) || 'N/A'}</div>
              <div>Observation type: {observation?.type || 'none'}</div>
              <div>Patterns: trend={patterns?.trend || 'N/A'}, below={patterns?.consecutiveBelowBaseline || 0}, crashes={patterns?.crashesAfterIgnoredRest?.length || 0}</div>
              <div>Feedback: R1={feedbackRound1Complete ? 'done' : 'pending'} ({feedbackRound1Response || '-'}) | R2={feedbackRound2Complete ? 'done' : 'pending'}</div>
            </div>

            {/* Actions */}
            <div className="flex flex-wrap gap-2">
              <button onClick={resetAll} className="bg-red-900 px-3 py-1 rounded text-xs">Reset All</button>
              <button 
                onClick={() => setLastObservationType(null)} 
                className="bg-zinc-800 px-3 py-1 rounded text-xs"
              >
                Reset Observation
              </button>
              <button 
                onClick={() => { setFeedbackRound(1); setFeedbackStep(1); setShowFeedback(true); }} 
                className="bg-blue-900/50 px-3 py-1 rounded text-xs"
              >
                Test Feedback R1
              </button>
              <button 
                onClick={() => { setFeedbackRound(2); setFeedbackStep(1); setShowFeedback(true); }} 
                className="bg-blue-900/50 px-3 py-1 rounded text-xs"
              >
                Test Feedback R2
              </button>
              <button 
                onClick={() => { setFeedbackRound1Complete(false); setFeedbackRound1Response(null); setFeedbackRound1DismissedAt(null); setFeedbackRound2Complete(false); }} 
                className="bg-zinc-800 px-3 py-1 rounded text-xs"
              >
                Reset Feedback
              </button>
            </div>
          </div>
        </div>
      );

      // ============================================
      // FIRST SCREEN
      // ============================================
      if (!hrvSource) {
        return (
          <div className="min-h-screen text-white p-6 flex flex-col justify-center">
            <div className="mist-overlay"></div>
            <div className="content-layer max-w-sm mx-auto space-y-10">
              
              {/* Info icon - top right */}
              <button 
                onClick={() => setShowInfoModal(true)}
                className="absolute top-6 right-6 text-white/30 hover:text-white/60 transition-all"
                style={{ position: 'fixed' }}
              >
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5">
                  <circle cx="12" cy="12" r="10"/>
                  <path d="M12 16v-4M12 8h.01"/>
                </svg>
              </button>
              
              <div className="space-y-3 text-center fade-in">
                <p className="text-white text-2xl font-light">
                  Your body is talking.
                </p>
                <p className="text-white/60 text-lg">
                  Now you know what it's asking for.
                </p>
              </div>

              <div className="space-y-4 text-center fade-in-delay-1">
                <p className="text-white/50">Give me a week — I'll find your baseline.</p>
                <p className="text-white/50">Give me a month — I'll recognize your rhythms.</p>
                <p className="text-white/40 leading-relaxed">Give me a year — I'll see what even you can't:<br/>what pushes you forward… and what sets you back.</p>
              </div>

              <div className="space-y-4 fade-in-delay-2">
                <p className="text-white/40 text-sm text-center">Where does your HRV come from?</p>
                <div className="grid grid-cols-2 gap-2">
                  {HRV_SOURCES.map(source => (
                    <button
                      key={source.id}
                      onClick={() => setHrvSource(source)}
                      className="glass hover:bg-white/10 rounded-2xl py-3 px-4 text-sm text-white/70 hover:text-white transition-all duration-300"
                    >
                      {source.label}
                    </button>
                  ))}
                </div>
                
                {/* Custom device input */}
                <div className="flex gap-2 mt-3">
                  <input
                    type="text"
                    value={customDevice}
                    onChange={(e) => setCustomDevice(e.target.value)}
                    placeholder="Other device..."
                    className="flex-1 glass rounded-2xl py-3 px-4 text-sm text-white placeholder-white/30 bg-transparent border-0 outline-none focus:ring-1 focus:ring-white/20"
                  />
                  {customDevice.trim() && (
                    <button
                      onClick={() => setHrvSource({ id: 'custom', label: customDevice.trim() })}
                      className="glass hover:bg-white/10 rounded-2xl py-3 px-4 text-sm text-white/70 hover:text-white transition-all duration-300"
                    >
                      →
                    </button>
                  )}
                </div>
              </div>

            </div>

            {/* Test mode button */}
            <button
              onClick={() => setShowDebug(true)}
              className="fixed bottom-4 right-4 bg-amber-600 text-black text-xs font-bold px-3 py-2 rounded-lg z-20"
            >
              ðŸ§ª TEST
            </button>
            {showDebug && <DebugPanel />}
            <Tagline />
            
            {/* Info Modal */}
            {showInfoModal && <InfoModal onClose={() => setShowInfoModal(false)} hrvSource={hrvSource} />}
          </div>
        );
      }

      // ============================================
      // HRV INPUT
      // ============================================
      if (!hasTodayHRV) {
        // Calculate countdown - updates when hrvHistory changes
        const daysRemaining = 4 - hrvHistory.length;
        const countdownText = daysRemaining > 0 
          ? `${daysRemaining} day${daysRemaining > 1 ? 's' : ''} until commands · Add history below to unlock today`
          : hrvHistory.length < 7 ? 'Personalized guidance unlocking...' : null;
        
        return (
          <div className="min-h-screen text-white p-4 flex flex-col overflow-y-auto">
            <div className="mist-overlay"></div>
            
            {/* Info icon - top right */}
            <button 
              onClick={() => setShowInfoModal(true)}
              className="fixed top-4 right-4 text-white/30 hover:text-white/60 transition-all z-20"
            >
              <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5">
                <circle cx="12" cy="12" r="10"/>
                <path d="M12 16v-4M12 8h.01"/>
              </svg>
            </button>
            
            <div className="content-layer max-w-sm mx-auto flex-1 flex flex-col justify-center space-y-6 py-12">
              
              {/* Day counter + countdown */}
              <div className="text-center fade-in space-y-1">
                <div className="text-white/30 text-sm tracking-wide">
                  {daysOnApp <= 1 ? "Day 1" : `Day ${daysOnApp}`}
                </div>
                {countdownText && (
                  <div className="text-white/20 text-xs">
                    {countdownText}
                  </div>
                )}
              </div>

              {needsYesterdayCompliance && (
                <div className="glass rounded-2xl p-4 space-y-3 fade-in">
                  <p className="text-white/60 text-center text-sm">
                    Yesterday I said <span style={{ color: COMMAND_STYLES[yesterdayLog.command].color }}>{yesterdayLog.command}</span>
                  </p>
                  <div className="flex gap-2">
                    <button
                      onClick={() => recordCompliance('yes')}
                      className="flex-1 glass-light hover:bg-white/10 rounded-xl py-2.5 text-sm text-white/80 transition-all duration-300"
                    >
                      I listened
                    </button>
                    <button
                      onClick={() => recordCompliance('no')}
                      className="flex-1 glass-light hover:bg-white/10 rounded-xl py-2.5 text-sm text-white/80 transition-all duration-300"
                    >
                      I didn't
                    </button>
                  </div>
                </div>
              )}

              <div className="space-y-3 fade-in-delay-1">
                <p className="text-white/60 text-center">
                  {daysOnApp <= 1 ? "What's your HRV this morning?" : "What's your HRV?"}
                </p>
                <div className="flex gap-2">
                  <input
                    type="number"
                    value={todayHRV}
                    onChange={(e) => setTodayHRV(e.target.value)}
                    onKeyDown={(e) => e.key === 'Enter' && handleSubmitHRV()}
                    placeholder="HRV"
                    className="flex-1 glass rounded-2xl px-4 py-3 text-xl text-center font-light text-white placeholder-white/30 focus:outline-none focus:ring-1 focus:ring-white/20 transition-all"
                    autoFocus
                  />
                  <button
                    onClick={handleSubmitHRV}
                    className="bg-white/90 text-black rounded-2xl px-5 py-3 font-medium hover:bg-white transition-all duration-300"
                  >
                    Go
                  </button>
                </div>
                <p className="text-white/20 text-xs text-center">
                  from {hrvSource.label}
                </p>
              </div>

              <button
                onClick={() => setShowAddHistory(true)}
                className="text-white/30 text-sm hover:text-white/50 transition-all"
              >
                + Add past days
              </button>

            </div>

            {/* Test button */}
            <button
              onClick={() => setShowDebug(true)}
              className="fixed bottom-4 right-4 bg-amber-600 text-black text-xs font-bold px-3 py-2 rounded-lg z-20"
            >
              ðŸ§ª TEST
            </button>
            {showDebug && <DebugPanel />}

            {showAddHistory && (
              <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-end justify-center z-50">
                <div className="glass-dark rounded-t-3xl p-6 w-full max-w-md space-y-6">
                  <div className="flex justify-between items-center">
                    <h3 className="text-lg font-medium text-white">Add Past HRV</h3>
                    <button 
                      onClick={() => setShowAddHistory(false)}
                      className="text-white/40 hover:text-white text-2xl"
                    >
                      ×
                    </button>
                  </div>
                  
                  <p className="text-white/40 text-sm">
                    The more history I have, the faster I learn you.
                  </p>
                  
                  <div className="flex gap-2">
                    <input
                      type="number"
                      value={newEntry}
                      onChange={(e) => setNewEntry(e.target.value)}
                      onKeyDown={(e) => e.key === 'Enter' && addHistoricalEntry()}
                      placeholder="HRV"
                      className="w-24 glass rounded-xl px-3 py-3 text-center text-white placeholder-white/30 focus:outline-none"
                      autoFocus
                    />
                    <input
                      type="date"
                      value={newEntryDate}
                      onChange={(e) => setNewEntryDate(e.target.value)}
                      className="flex-1 glass rounded-xl px-3 py-3 text-white/60 focus:outline-none"
                    />
                    <button
                      onClick={addHistoricalEntry}
                      className="glass-light hover:bg-white/10 rounded-xl px-4 py-3 text-white/80 transition-all"
                    >
                      Add
                    </button>
                  </div>

                  {hrvHistory.length > 0 && (
                    <div className="space-y-2 max-h-48 overflow-y-auto">
                      {[...hrvHistory].reverse().slice(0, 14).map((entry, i) => (
                        <div key={entry.date} className="flex justify-between items-center text-sm text-white/40 py-2 border-b border-white/5">
                          <span>{entry.date}</span>
                          <div className="flex items-center gap-3">
                            <span className="font-mono">{entry.value} ms</span>
                            <button
                              onClick={() => deleteHistoricalEntry(entry.date)}
                              className="text-white/20 hover:text-red-400 transition-colors text-lg leading-none"
                              title="Delete entry"
                            >
                              ×
                            </button>
                          </div>
                        </div>
                      ))}
                    </div>
                  )}

                  <button
                    onClick={() => setShowAddHistory(false)}
                    className="w-full glass-light hover:bg-white/10 rounded-xl py-3 text-white/80 transition-all"
                  >
                    Done — {hrvHistory.length} days logged
                  </button>
                </div>
              </div>
            )}
            
            {/* Info Modal */}
            {showInfoModal && <InfoModal onClose={() => setShowInfoModal(false)} hrvSource={hrvSource} />}
            
            <Tagline />
          </div>
        );
      }

      // ============================================
      // MAIN VIEW
      // ============================================
      return (
        <div className="min-h-screen text-white p-6 flex flex-col">
          <div className="mist-overlay"></div>
          
          {/* Info icon - top right */}
          <button 
            onClick={() => setShowInfoModal(true)}
            className="fixed top-6 right-6 text-white/30 hover:text-white/60 transition-all z-20"
          >
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5">
              <circle cx="12" cy="12" r="10"/>
              <path d="M12 16v-4M12 8h.01"/>
            </svg>
          </button>
          
          <div className="content-layer max-w-sm mx-auto flex-1 flex flex-col justify-center space-y-6">
            
            <div className="text-center">
              <span className="text-white/30 text-sm tracking-wide">Day {daysOnApp}</span>
            </div>

            {/* Pattern Name - if detected */}
            {patterns?.patternName && (
              <div className="text-center fade-in">
                <span className="text-white/40 text-xs uppercase tracking-widest">
                  {patterns.patternName === 'recovery_arc' && "You're in a recovery arc"}
                  {patterns.patternName === 'back_to_back_crash' && `You crash after back-to-back PERFORMs`}
                </span>
              </div>
            )}

            {/* Day-of-week pattern */}
            {patterns?.todayDowPattern && !patterns?.patternName && (
              <div className="text-center fade-in">
                <span className="text-white/40 text-xs uppercase tracking-widest">
                  {patterns.todayDowPattern.tendency === 'low' 
                    ? `Your ${patterns.todayDowPattern.day}s tend to be low`
                    : `${patterns.todayDowPattern.day}s are usually your strong day`}
                </span>
              </div>
            )}

            {observation && (
              <div className="text-center fade-in">
                <p className="text-white/60 text-sm leading-snug px-2 line-clamp-2">
                  "<Typewriter 
                    key={observation.type + observation.text.substring(0, 20)} 
                    text={observation.text} 
                    speed={60} 
                  />"
                </p>
              </div>
            )}

            {/* IMPOSSIBLE INSIGHT - when detected */}
            {patterns?.impossibleInsight && (
              <div className="text-center fade-in">
                <p className="text-amber-400/70 text-xs font-medium">
                  ⚠ {patterns.impossibleInsight.text}
                </p>
              </div>
            )}

            <div 
              className="glass rounded-3xl py-8 px-6 text-center fade-in-delay-1"
              style={{ 
                boxShadow: `0 8px 32px ${styles.glow || 'rgba(0,0,0,0.2)'}`,
                borderColor: styles.border
              }}
            >
              <div 
                className="text-5xl font-bold tracking-tight mb-4"
                style={{ color: styles.color }}
              >
                {result?.commandKey || 'LEARNING'}
              </div>
              
              {/* Stats - right under command */}
              {patterns && daysOnApp >= 7 && (
                <p className="text-white/25 text-xs mb-5">
                  {patterns.performDays} peaks · {patterns.restDays} protected · {patterns.totalDays} days
                </p>
              )}
              
              {/* Action System inside card */}
              {actions && (
                <div className="space-y-3 text-left border-t border-white/10 pt-4 mt-2">
                  <div className="flex items-start gap-2">
                    <span className="text-white/30 text-xs font-medium uppercase tracking-wide w-16 shrink-0 mt-0.5">Action</span>
                    <p className="text-white/60 text-xs leading-relaxed">{actions.primaryAction}</p>
                  </div>
                  <div className="flex items-start gap-2">
                    <span className="text-white/30 text-xs font-medium uppercase tracking-wide w-16 shrink-0 mt-0.5">Effort</span>
                    <p className="text-white/50 text-xs leading-relaxed">{actions.effortBoundary}</p>
                  </div>
                  <div className="flex items-start gap-2">
                    <span className="text-white/30 text-xs font-medium uppercase tracking-wide w-16 shrink-0 mt-0.5">Recovery</span>
                    <p className="text-white/50 text-xs leading-relaxed">{actions.recoveryLever}</p>
                  </div>
                </div>
              )}
            </div>

            {/* Guardrail - below the card */}
            {actions?.guardrail && (
              <div className="text-center fade-in-delay-2">
                <p className="text-amber-400/60 text-xs">
                  ⚠️ {actions.guardrail}
                </p>
              </div>
            )}

            {result?.isPreview && (
              <div className="text-center space-y-1">
                <p className="text-white/50 text-xs">
                  {result.daysUntilFull} day{result.daysUntilFull > 1 ? 's' : ''} until personalized guidance unlocks.
                </p>
                <p className="text-white/30 text-xs">
                  We don't guess. We learn you first.
                </p>
              </div>
            )}

          </div>

          <div className="content-layer max-w-sm mx-auto w-full pt-8 pb-16 flex justify-between text-white/40 text-xs">
            <button 
              onClick={() => setShowAddHistory(true)}
              className="hover:text-white/70 transition-all"
            >
              + Add history
            </button>
            <button 
              onClick={resetAll}
              className="hover:text-white/70 transition-all"
            >
              Reset
            </button>
          </div>

          {/* Test button */}
          <button
            onClick={() => setShowDebug(true)}
            className="fixed bottom-4 right-4 bg-amber-600 text-black text-xs font-bold px-3 py-2 rounded-lg z-20"
          >
            ðŸ§ª TEST
          </button>
          {showDebug && <DebugPanel />}

          {showAddHistory && (
            <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-end justify-center z-50">
              <div className="glass-dark rounded-t-3xl p-6 w-full max-w-md space-y-6">
                <div className="flex justify-between items-center">
                  <h3 className="text-lg font-medium text-white">Add Past HRV</h3>
                  <div className="flex items-center gap-4">
                    <span className="text-white/40 text-sm">{hrvHistory.length} {hrvHistory.length === 1 ? 'entry' : 'entries'}</span>
                    <button 
                      onClick={() => setShowAddHistory(false)}
                      className="text-white/40 hover:text-white text-2xl"
                    >
                      ×
                    </button>
                  </div>
                </div>
                
                <div className="flex gap-2">
                  <input
                    type="number"
                    value={newEntry}
                    onChange={(e) => setNewEntry(e.target.value)}
                    onKeyDown={(e) => e.key === 'Enter' && addHistoricalEntry()}
                    placeholder="HRV"
                    className="w-24 glass rounded-xl px-3 py-3 text-center text-white placeholder-white/30 focus:outline-none"
                    autoFocus
                  />
                  <input
                    type="date"
                    value={newEntryDate}
                    onChange={(e) => setNewEntryDate(e.target.value)}
                    className="flex-1 glass rounded-xl px-3 py-3 text-white/60 focus:outline-none"
                  />
                  <button
                    onClick={addHistoricalEntry}
                    className="glass-light hover:bg-white/10 rounded-xl px-4 py-3 text-white/80 transition-all"
                  >
                    Add
                  </button>
                </div>

                {hrvHistory.length > 0 && (
                  <div className="space-y-2 max-h-48 overflow-y-auto">
                    {[...hrvHistory].reverse().slice(0, 14).map((entry, i) => (
                      <div key={entry.date} className="flex justify-between items-center text-sm text-white/40 py-2 border-b border-white/5">
                        <span>{entry.date}</span>
                        <div className="flex items-center gap-3">
                          <span className="font-mono">{entry.value} ms</span>
                          <button
                            onClick={() => deleteHistoricalEntry(entry.date)}
                            className="text-white/20 hover:text-red-400 transition-colors text-lg leading-none"
                            title="Delete entry"
                          >
                            ×
                          </button>
                        </div>
                      </div>
                    ))}
                  </div>
                )}

                <button
                  onClick={() => setShowAddHistory(false)}
                  className="w-full glass-light hover:bg-white/10 rounded-xl py-3 text-white/80 transition-all"
                >
                  Done
                </button>
              </div>
            </div>
          )}

          {/* Feedback Modal */}
          {showFeedback && (
            <FeedbackModal
              round={feedbackRound}
              daysOnApp={daysOnApp}
              step={feedbackStep}
              setStep={setFeedbackStep}
              response={feedbackResponse}
              setResponse={setFeedbackResponse}
              text={feedbackText}
              setText={setFeedbackText}
              email={feedbackEmail}
              setEmail={setFeedbackEmail}
              onSend={sendFeedback}
              onDismiss={dismissFeedback}
            />
          )}
          
          {/* Info Modal */}
          {showInfoModal && <InfoModal onClose={() => setShowInfoModal(false)} hrvSource={hrvSource} />}
          
          <Tagline />
        </div>
      );
    };

    ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
