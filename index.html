<!DOCTYPE html>
<html lang="en">
<head>
 <meta charset="UTF-8">
 <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
 <meta name="apple-mobile-web-app-capable" content="yes">
 <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
 <meta name="theme-color" content="#1a2f1a">
 <title>GENYSYS</title>
 <script src="https://cdn.tailwindcss.com"></script>
 <script src="https://unpkg.com/react@18.2.0/umd/react.production.min.js" crossorigin="anonymous"></script>
 <script src="https://unpkg.com/react-dom@18.2.0/umd/react-dom.production.min.js" crossorigin="anonymous"></script>
 <script src="https://unpkg.com/@babel/standalone@7.23.5/babel.min.js" crossorigin="anonymous"></script>
 <style>
 /* Nature gradient background */
 body { 
 background: linear-gradient(180deg, 
 #2d3b2d 0%, 
 #3d4f3d 20%, 
 #4a5d4a 40%, 
 #5a6b5a 60%, 
 #6b7b6b 80%, 
 #8a9a8a 100%
 );
 background-attachment: fixed;
 min-height: 100vh;
 }
 
 /* Glassmorphism base */
 .glass {
 background: rgba(40, 50, 40, 0.6);
 backdrop-filter: blur(20px);
 -webkit-backdrop-filter: blur(20px);
 border: 1px solid rgba(255, 255, 255, 0.08);
 }
 
 .glass-light {
 background: rgba(60, 75, 60, 0.5);
 backdrop-filter: blur(16px);
 -webkit-backdrop-filter: blur(16px);
 border: 1px solid rgba(255, 255, 255, 0.06);
 }
 
 .glass-dark {
 background: rgba(20, 30, 20, 0.7);
 backdrop-filter: blur(24px);
 -webkit-backdrop-filter: blur(24px);
 border: 1px solid rgba(255, 255, 255, 0.05);
 }
 
 /* Subtle mist overlay */
 .mist-overlay {
 position: fixed;
 top: 0;
 left: 0;
 right: 0;
 bottom: 0;
 background: linear-gradient(180deg, 
 rgba(180, 190, 180, 0.1) 0%, 
 rgba(180, 190, 180, 0) 30%,
 rgba(180, 190, 180, 0) 70%,
 rgba(180, 190, 180, 0.05) 100%
 );
 pointer-events: none;
 z-index: 1;
 }
 
 /* Content layer */
 .content-layer {
 position: relative;
 z-index: 2;
 }
 
 input[type="date"]::-webkit-calendar-picker-indicator { filter: invert(0.7); }
 input[type="number"]::-webkit-inner-spin-button,
 input[type="number"]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
 input[type="number"] { -moz-appearance: textfield; }
 
 @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
 @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }
 @keyframes float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-3px); } }
 
 .fade-in { animation: fadeIn 0.6s ease-out forwards; }
 .fade-in-delay-1 { animation: fadeIn 0.6s ease-out 0.2s forwards; opacity: 0; }
 .fade-in-delay-2 { animation: fadeIn 0.6s ease-out 0.4s forwards; opacity: 0; }
 .fade-in-delay-3 { animation: fadeIn 0.6s ease-out 0.6s forwards; opacity: 0; }
 .pulse-slow { animation: pulse 3s ease-in-out infinite; }
 .float { animation: float 4s ease-in-out infinite; }
 
 /* Line clamp utility */
 .line-clamp-2 {
 display: -webkit-box;
 -webkit-line-clamp: 2;
 -webkit-box-orient: vertical;
 overflow: hidden;
 }
 
 /* Soft text rendering */
 * {
 -webkit-font-smoothing: antialiased;
 -moz-osx-font-smoothing: grayscale;
 }
 
 /* Custom scrollbar */
 ::-webkit-scrollbar { width: 4px; }
 ::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); }
 ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 2px; }
 </style>
</head>
<body>
 <div id="root"></div>
 
 <script type="text/babel">
 const { useState, useEffect, useMemo, useRef } = React;

 // ============================================
 // ANALYTICS CONFIGURATION
 // ============================================
 // Replace with your Google Apps Script Web App URL
 const ANALYTICS_ENDPOINT = 'https://script.google.com/macros/s/AKfycbxP8OImAXDl8fwUG1ksGSTvlFID9wZQ90es4f4Ry1FWQAVqcDa27rXeeyd19JBH_eBG/exec';
 
 // Allowed events (must match server allowlist)
 const ALLOWED_EVENTS = [
 'session_start', 'onboarding_complete', 'first_hrv_logged', 'hrv_logged',
 'hrv_backfilled', 'command_generated', 'compliance_recorded',
 'day_3_active', 'day_7_active', 'day_14_active', 'day_30_active', 'day_60_active', 'day_90_active',
 'milestone_reached', 'observation_shown',
 'feedback_round1_submitted', 'feedback_round1_dismissed', 
 'feedback_round2_submitted', 'feedback_round2_dismissed',
 'data_exported', 'data_reset', 'legacy_user_migrated'
 ];

 // Generate UUID v4
 const generateUUID = () => {
 return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
 const r = Math.random() * 16 | 0;
 const v = c === 'x' ? r : (r & 0x3 | 0x8);
 return v.toString(16);
 });
 };

 // Get timezone (privacy-friendly region detection)
 const getTimezone = () => {
 try {
 return Intl.DateTimeFormat().resolvedOptions().timeZone;
 } catch (e) {
 return 'Unknown';
 }
 };

 // Analytics tracker
 const Analytics = {
 userId: null,
 timezone: null,
 device: null,
 firstUseDate: null,

 init() {
 let stored = localStorage.getItem('genysys_analytics');
 if (stored) {
 const data = JSON.parse(stored);
 this.userId = data.userId;
 this.timezone = data.timezone || getTimezone();
 this.firstUseDate = data.firstUseDate;
 } else {
 this.userId = generateUUID();
 this.timezone = getTimezone();
 
 // Check for existing app data (legacy user)
 const appData = localStorage.getItem('genysys_v2_data');
 if (appData) {
 try {
 const parsed = JSON.parse(appData);
 this.firstUseDate = parsed.firstUseDate || this.getTodayLocal();
 setTimeout(() => this.track('legacy_user_migrated', { 
 device: parsed.hrvSource?.label || 'unknown',
 daysLogged: parsed.hrvHistory?.length || 0
 }), 100);
 } catch (e) {
 this.firstUseDate = this.getTodayLocal();
 }
 } else {
 this.firstUseDate = this.getTodayLocal();
 }
 
 this.save();
 }
 },

 getTodayLocal() {
 const date = new Date();
 const year = date.getFullYear();
 const month = String(date.getMonth() + 1).padStart(2, '0');
 const day = String(date.getDate()).padStart(2, '0');
 return `${year}-${month}-${day}`;
 },

 save() {
 localStorage.setItem('genysys_analytics', JSON.stringify({
 userId: this.userId,
 timezone: this.timezone,
 firstUseDate: this.firstUseDate
 }));
 },

 setDevice(device) {
 this.device = device;
 },

 getDaysActive() {
 if (!this.firstUseDate) return 0;
 const first = new Date(this.firstUseDate);
 const now = new Date();
 return Math.floor((now - first) / (1000 * 60 * 60 * 24));
 },

 track(eventName, properties = {}) {
 if (!ALLOWED_EVENTS.includes(eventName)) {
 console.warn('[Analytics] Unknown event:', eventName);
 return;
 }
 
 if (!this.userId) {
 console.warn('[Analytics] No userId, skipping');
 return;
 }
 
 const payload = {
 timestamp: new Date().toISOString(),
 userId: this.userId,
 event: eventName,
 device: this.device || properties.device || 'unknown',
 daysActive: this.getDaysActive(),
 region: this.timezone,
 ...properties
 };

 console.log('[Analytics]', eventName, payload);

 if (ANALYTICS_ENDPOINT && ANALYTICS_ENDPOINT !== 'YOUR_GOOGLE_APPS_SCRIPT_URL_HERE') {
 fetch(ANALYTICS_ENDPOINT, {
 method: 'POST',
 mode: 'no-cors',
 headers: { 'Content-Type': 'application/json' },
 body: JSON.stringify(payload)
 }).catch(err => console.log('Analytics error:', err));
 }
 }
 };

 // Initialize analytics
 Analytics.init();

 // ============================================
 // UTILITIES
 // ============================================
 const getLocalDateString = (date = new Date()) => {
 const year = date.getFullYear();
 const month = String(date.getMonth() + 1).padStart(2, '0');
 const day = String(date.getDate()).padStart(2, '0');
 return `${year}-${month}-${day}`;
 };

 const getTodayLocal = () => getLocalDateString();
 
 const getYesterdayLocal = () => {
 const yesterday = new Date();
 yesterday.setDate(yesterday.getDate() - 1);
 return getLocalDateString(yesterday);
 };

 const getDayName = (dateStr) => {
 const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
 return days[new Date(dateStr).getDay()];
 };

 const getRelativeDay = (dateStr) => {
 const today = new Date(getTodayLocal());
 const target = new Date(dateStr);
 const diffDays = Math.floor((today - target) / (1000 * 60 * 60 * 24));
 if (diffDays === 0) return 'today';
 if (diffDays === 1) return 'yesterday';
 if (diffDays < 7) return getDayName(dateStr);
 if (diffDays < 14) return 'last ' + getDayName(dateStr);
 return `${diffDays} days ago`;
 };

 // ============================================
 // ALGORITHM (unchanged from validated version)
 // ============================================
 const THRESHOLDS = { REST: -1.0, PERFORM: 0.5, MIN_DAYS: 7, MIN_PREVIEW_DAYS: 4, MAD_FLOOR: 3.0 };

 const calculateMedian = (arr) => {
 const sorted = [...arr].sort((a, b) => a - b);
 const mid = Math.floor(sorted.length / 2);
 return sorted.length % 2 ? sorted[mid] : (sorted[mid - 1] + sorted[mid]) / 2;
 };

 const calculateMAD = (arr, median) => {
 const deviations = arr.map(v => Math.abs(v - median)).sort((a, b) => a - b);
 return Math.max(calculateMedian(deviations) * 1.4826, THRESHOLDS.MAD_FLOOR);
 };

 const getCommandKey = (zScore) => {
 if (zScore === null) return 'LEARNING';
 if (zScore < THRESHOLDS.REST) return 'REST';
 if (zScore >= THRESHOLDS.PERFORM) return 'PERFORM';
 return 'BUILD';
 };

 // ============================================
 // PATTERN ENGINE
 // ============================================
 const analyzePatterns = (hrvHistory, complianceLog, firstUseDate) => {
 if (hrvHistory.length < 3) return null;

 const values = hrvHistory.map(h => h.value);
 const median = calculateMedian(values);
 const mad = calculateMAD(values, median);

 // Calculate z-scores for all entries
 const withZScores = hrvHistory.map(h => ({
 ...h,
 zScore: (h.value - median) / mad,
 command: getCommandKey((h.value - median) / mad)
 })).sort((a, b) => new Date(a.date) - new Date(b.date));

 // Find patterns
 const patterns = {
 baseline: median,
 mad,
 totalDays: hrvHistory.length,
 
 // Command distribution
 restDays: withZScores.filter(h => h.command === 'REST').length,
 buildDays: withZScores.filter(h => h.command === 'BUILD').length,
 performDays: withZScores.filter(h => h.command === 'PERFORM').length,
 
 // Crash analysis
 crashes: [],
 crashesAfterIgnoredRest: [],
 recoveriesAfterRest: [],
 
 // Trend
 trend: null,
 consecutiveBelowBaseline: 0,
 consecutiveAboveBaseline: 0,
 
 // Historical comparisons
 nearestMatch: null,
 lastPerformDate: null,
 daysSincePerform: null,
 
 // Volatility
 isVolatile: false,
 isStable: false,
 };

 // Analyze trend (last 3-5 days)
 const recent = withZScores.slice(-5);
 if (recent.length >= 3) {
 let rising = 0, falling = 0;
 for (let i = 1; i < recent.length; i++) {
 if (recent[i].zScore > recent[i-1].zScore) rising++;
 else if (recent[i].zScore < recent[i-1].zScore) falling++;
 }
 if (rising >= 3) patterns.trend = 'rising';
 else if (falling >= 3) patterns.trend = 'falling';
 else patterns.trend = 'stable';
 }

 // Count consecutive days below/above baseline
 const reversed = [...withZScores].reverse();
 for (const h of reversed) {
 if (h.zScore < 0) patterns.consecutiveBelowBaseline++;
 else break;
 }
 for (const h of reversed) {
 if (h.zScore > 0) patterns.consecutiveAboveBaseline++;
 else break;
 }

 // Find last PERFORM day
 const performDays = withZScores.filter(h => h.command === 'PERFORM');
 if (performDays.length > 0) {
 const lastPerform = performDays[performDays.length - 1];
 patterns.lastPerformDate = lastPerform.date;
 patterns.daysSincePerform = Math.floor(
 (new Date(getTodayLocal()) - new Date(lastPerform.date)) / (1000 * 60 * 60 * 24)
 );
 }

 // Find last REST day
 const restDaysHistory = withZScores.filter(h => h.command === 'REST');
 if (restDaysHistory.length > 0) {
 const lastRest = restDaysHistory[restDaysHistory.length - 1];
 patterns.lastRestDate = lastRest.date;
 patterns.daysSinceRest = Math.floor(
 (new Date(getTodayLocal()) - new Date(lastRest.date)) / (1000 * 60 * 60 * 24)
 );
 }

 // Analyze compliance outcomes
 if (complianceLog && complianceLog.length > 0) {
 complianceLog.forEach(log => {
 if (!log.command || !log.followed) return;
 
 const nextDate = new Date(log.date);
 nextDate.setDate(nextDate.getDate() + 1);
 const nextDateStr = getLocalDateString(nextDate);
 const nextDay = withZScores.find(h => h.date === nextDateStr);
 
 if (!nextDay) return;
 
 // REST ignored → crashed?
 if (log.command === 'REST' && log.followed === 'no') {
 if (nextDay.zScore < THRESHOLDS.REST) {
 patterns.crashesAfterIgnoredRest.push({
 ignoredDate: log.date,
 crashDate: nextDateStr,
 daysLost: 1 // Could calculate more precisely
 });
 }
 }
 
 // REST followed → recovered?
 if (log.command === 'REST' && log.followed === 'yes') {
 if (nextDay.zScore >= THRESHOLDS.REST) {
 patterns.recoveriesAfterRest.push({
 restDate: log.date,
 readyDate: nextDateStr
 });
 }
 }
 });
 }

 // Calculate volatility
 const zScoreStd = Math.sqrt(
 withZScores.reduce((sum, h) => sum + Math.pow(h.zScore, 2), 0) / withZScores.length
 );
 patterns.isVolatile = zScoreStd > 1.5;
 patterns.isStable = zScoreStd < 0.8;

 // === PATTERN NAMES ===
 
 // Recovery arc: 3+ days of rising from REST
 if (patterns.trend === 'rising' && patterns.consecutiveAboveBaseline >= 2) {
 const recentRest = withZScores.slice(-7).find(h => h.command === 'REST');
 if (recentRest) {
 patterns.patternName = 'recovery_arc';
 }
 }
 
 // Back-to-back PERFORM crash pattern
 const performIndices = withZScores.map((h, i) => h.command === 'PERFORM' ? i : -1).filter(i => i >= 0);
 let backToBackCrashes = 0;
 for (let i = 1; i < performIndices.length; i++) {
 if (performIndices[i] - performIndices[i-1] === 1) {
 // Back-to-back PERFORMs
 const dayAfter = withZScores[performIndices[i] + 1];
 if (dayAfter && dayAfter.command === 'REST') {
 backToBackCrashes++;
 }
 }
 }
 if (backToBackCrashes >= 2) {
 patterns.patternName = 'back_to_back_crash';
 patterns.backToBackCrashes = backToBackCrashes;
 }
 
 // Day-of-week pattern detection
 const dayOfWeekStats = {};
 withZScores.forEach(h => {
 const dow = new Date(h.date).getDay();
 if (!dayOfWeekStats[dow]) dayOfWeekStats[dow] = { sum: 0, count: 0 };
 dayOfWeekStats[dow].sum += h.zScore;
 dayOfWeekStats[dow].count++;
 });
 
 const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
 let worstDay = null, worstAvg = Infinity;
 let bestDay = null, bestAvg = -Infinity;
 
 Object.entries(dayOfWeekStats).forEach(([dow, stats]) => {
 if (stats.count >= 3) { // Need at least 3 samples
 const avg = stats.sum / stats.count;
 if (avg < worstAvg) { worstAvg = avg; worstDay = parseInt(dow); }
 if (avg > bestAvg) { bestAvg = avg; bestDay = parseInt(dow); }
 }
 });
 
 if (worstDay !== null && worstAvg < -0.5) {
 patterns.weakDay = { day: dayNames[worstDay], avgZ: worstAvg };
 }
 if (bestDay !== null && bestAvg > 0.5) {
 patterns.strongDay = { day: dayNames[bestDay], avgZ: bestAvg };
 }
 
 // Today's day of week pattern
 const todayDow = new Date().getDay();
 if (dayOfWeekStats[todayDow] && dayOfWeekStats[todayDow].count >= 3) {
 const todayDowAvg = dayOfWeekStats[todayDow].sum / dayOfWeekStats[todayDow].count;
 if (todayDowAvg < -0.3) {
 patterns.todayDowPattern = { day: dayNames[todayDow], tendency: 'low', avgZ: todayDowAvg };
 } else if (todayDowAvg > 0.3) {
 patterns.todayDowPattern = { day: dayNames[todayDow], tendency: 'high', avgZ: todayDowAvg };
 }
 }

 // === IMPOSSIBLE INSIGHT: "You feel fine but you're about to crash" ===
 // Conditions: Today is PERFORM or BUILD, but hidden warning signs
 const todayEntry = hrvHistory.find(h => h.date === getTodayLocal());
 if (todayEntry) {
 const todayZ = (todayEntry.value - median) / mad;
 const todayCommand = getCommandKey(todayZ);
 
 // Warning sign 1: High HRV today but falling trend (often precedes crash)
 if (todayCommand === 'PERFORM' && patterns.trend === 'falling') {
 patterns.impossibleInsight = {
 type: 'false_peak',
 text: "Your HRV is high but your trend is falling. This peak may not hold."
 };
 }
 
 // Warning sign 2: Above baseline but volatile week (unstable foundation)
 if (todayZ > 0 && patterns.isVolatile) {
 patterns.impossibleInsight = {
 type: 'unstable_high',
 text: "You're above baseline but your week has been erratic. Tread carefully."
 };
 }
 
 // Warning sign 3: PERFORM after multiple BUILD days without REST
 if (todayCommand === 'PERFORM' && patterns.daysSinceRest >= 5) {
 patterns.impossibleInsight = {
 type: 'no_rest_perform',
 text: `${patterns.daysSinceRest} days without REST. This PERFORM is borrowed time.`
 };
 }
 
 // Warning sign 4: Historical pattern match predicts crash
 if (patterns.nearestMatch?.nextDayCrashed && todayCommand !== 'REST') {
 patterns.impossibleInsight = {
 type: 'historical_warning',
 text: "Last time you looked like this, you crashed the next day."
 };
 }
 }

 // Find nearest historical match to today
 const today = hrvHistory.find(h => h.date === getTodayLocal());
 if (today) {
 const todayZ = (today.value - median) / mad;
 let nearest = null;
 let nearestDiff = Infinity;
 
 withZScores.forEach(h => {
 if (h.date === getTodayLocal()) return;
 const diff = Math.abs(h.zScore - todayZ);
 if (diff < nearestDiff && diff < 0.5) {
 nearestDiff = diff;
 nearest = h;
 }
 });
 
 if (nearest) {
 // Check what happened next
 const nextDate = new Date(nearest.date);
 nextDate.setDate(nextDate.getDate() + 1);
 const nextDateStr = getLocalDateString(nextDate);
 const compliance = complianceLog?.find(c => c.date === nearest.date);
 const nextDay = withZScores.find(h => h.date === nextDateStr);
 
 patterns.nearestMatch = {
 date: nearest.date,
 zScore: nearest.zScore,
 command: nearest.command,
 pushed: compliance?.followed === 'no',
 rested: compliance?.followed === 'yes',
 nextDayCrashed: nextDay ? nextDay.zScore < THRESHOLDS.REST : null,
 nextDayRecovered: nextDay ? nextDay.zScore >= 0 : null
 };
 }
 }

 return patterns;
 };

 // ============================================
 // CONFIDENCE CALCULATION SYSTEM
 // Hidden driver for language and action selection
 // Never shown to user - operates in background
 // ============================================
 
 // Scoring: Signal (45%) + Quality (35%) + Support (20%) = 0-100
 // Buckets: High (≥75), Medium (50-74), Low (<50)
 // Hard overrides: Travel, <14 days, inconsistent timing → Low
 
 const calculateConfidence = (hrvHistory, patterns, complianceLog = []) => {
 // Early return: not enough data = always Low
 if (!patterns || hrvHistory.length < 14) {
 return { 
 level: 'low', 
 score: 30,
 reason: hrvHistory.length < 14 ? 'early_onboarding' : 'no_patterns',
 components: { signal: 15, quality: 10, support: 5 }
 };
 }
 
 // ========== 1. SIGNAL STRENGTH (45 points max) ==========
 // Based on robust z-score: how meaningful is today's reading?
 const todayEntry = hrvHistory.find(h => h.date === getTodayLocal());
 let signalScore = 15; // weak default
 
 if (todayEntry && patterns.baseline && patterns.mad) {
 const robustZ = Math.abs((todayEntry.value - patterns.baseline) / patterns.mad);
 
 if (robustZ < 0.7) signalScore = 15; // weak signal
 else if (robustZ < 1.5) signalScore = 30; // medium signal
 else if (robustZ < 2.5) signalScore = 45; // strong signal
 else signalScore = 45; // very strong (capped)
 }
 
 // ========== 2. MEASUREMENT QUALITY (35 points max) ==========
 // Based on data consistency and completeness
 let qualityScore = 10; // low default
 
 // Check days of data
 const totalDays = hrvHistory.length;
 if (totalDays >= 30) qualityScore = 25;
 else if (totalDays >= 21) qualityScore = 20;
 else if (totalDays >= 14) qualityScore = 15;
 else qualityScore = 10;
 
 // Penalty: Missing yesterday's HRV (less context)
 const yesterday = getYesterdayLocal();
 const hasYesterday = hrvHistory.some(h => h.date === yesterday);
 if (!hasYesterday) qualityScore = Math.max(10, qualityScore - 10);
 
 // Bonus: Consistent daily logging (check last 7 days)
 const recentDates = [];
 for (let i = 0; i < 7; i++) {
 const d = new Date();
 d.setDate(d.getDate() - i);
 recentDates.push(getLocalDateString(d));
 }
 const recentLogged = recentDates.filter(d => hrvHistory.some(h => h.date === d)).length;
 if (recentLogged >= 6) qualityScore = Math.min(35, qualityScore + 10);
 else if (recentLogged <= 3) qualityScore = Math.max(10, qualityScore - 5);
 
 // ========== 3. HISTORICAL SUPPORT (20 points max) ==========
 // Based on situation fingerprint matching
 let supportScore = 5; // weak default
 
 if (patterns.nearestMatch) {
 // We have a historical match - check how many similar situations exist
 const today = hrvHistory.find(h => h.date === getTodayLocal());
 if (today) {
 const todayZ = (today.value - patterns.baseline) / patterns.mad;
 const todayCommand = getCommandKey(todayZ);
 
 // Count similar fingerprints: same command + similar trend
 const withZScores = hrvHistory.map(h => ({
 ...h,
 zScore: (h.value - patterns.baseline) / patterns.mad,
 command: getCommandKey((h.value - patterns.baseline) / patterns.mad)
 })).filter(h => h.date !== getTodayLocal());
 
 const similarDays = withZScores.filter(h => {
 const zDiff = Math.abs(h.zScore - todayZ);
 return h.command === todayCommand && zDiff < 0.8;
 });
 
 if (similarDays.length >= 4) supportScore = 20; // strong support
 else if (similarDays.length >= 2) supportScore = 12; // medium support
 else supportScore = 5; // weak support
 }
 }
 
 // ========== COMPUTE TOTAL & BUCKET ==========
 const totalScore = signalScore + qualityScore + supportScore;
 
 let level = 'low';
 if (totalScore >= 75) level = 'high';
 else if (totalScore >= 50) level = 'medium';
 
 // ========== HARD OVERRIDES ==========
 // These force Low confidence regardless of score
 
 // Check for volatile week (indicates unstable measurement conditions)
 if (patterns.isVolatile && level === 'high') {
 level = 'medium';
 }
 
 // First day back after travel-like pattern (big swing after stability)
 // This is a proxy for timezone change detection
 const recent3 = hrvHistory.slice(-3);
 if (recent3.length >= 3) {
 const recent3Zs = recent3.map(h => (h.value - patterns.baseline) / patterns.mad);
 const range = Math.max(...recent3Zs) - Math.min(...recent3Zs);
 if (range > 2.5) {
 level = 'low';
 }
 }
 
 return {
 level,
 score: totalScore,
 reason: level === 'low' ? 'insufficient_evidence' : level === 'medium' ? 'moderate_evidence' : 'strong_evidence',
 components: { signal: signalScore, quality: qualityScore, support: supportScore }
 };
 };

 // ============================================
 // THREE-MODE SYSTEM (Deterministic)
 // DIRECTIVE: Listeners (follow commands)
 // PROTECTIVE: Fighters (override history)
 // UNCERTAIN: Low confidence / early days
 // ============================================
 
 const getMode = (confidence, complianceLog, daysOnApp) => {
 // UNCERTAIN: Low confidence or early days
 if (confidence.level === 'low' || daysOnApp < 14) {
 return 'UNCERTAIN';
 }
 
 // Count recent overrides (last 7 days)
 const sevenDaysAgo = new Date();
 sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);
 const recentOverrides = complianceLog.filter(log => {
 const logDate = new Date(log.date);
 return logDate >= sevenDaysAgo && log.followed === 'no';
 }).length;
 
 // Check if yesterday's REST was ignored
 const yesterday = getYesterdayLocal();
 const yesterdayLog = complianceLog.find(c => c.date === yesterday);
 const ignoredYesterdayRest = yesterdayLog?.command === 'REST' && yesterdayLog?.followed === 'no';
 
 // PROTECTIVE: Recent override behavior
 if (recentOverrides >= 2 || ignoredYesterdayRest) {
 return 'PROTECTIVE';
 }
 
 // DIRECTIVE: Default for listeners
 return 'DIRECTIVE';
 };

 // ============================================
 // RECEIPT SYSTEM - Yesterday's outcome
 // Shown before today's command
 // ============================================
 
 const generateReceipt = (hrvHistory, complianceLog, patterns) => {
 if (!patterns || hrvHistory.length < 2) return null;
 
 const yesterday = getYesterdayLocal();
 const yesterdayLog = complianceLog.find(c => c.date === yesterday);
 if (!yesterdayLog) return null;
 
 const todayEntry = hrvHistory.find(h => h.date === getTodayLocal());
 const yesterdayEntry = hrvHistory.find(h => h.date === yesterday);
 if (!todayEntry || !yesterdayEntry) return null;
 
 const todayZ = (todayEntry.value - patterns.baseline) / patterns.mad;
 const yesterdayZ = (yesterdayEntry.value - patterns.baseline) / patterns.mad;
 const improved = todayZ > yesterdayZ + 0.3;
 const declined = todayZ < yesterdayZ - 0.3;
 const stable = !improved && !declined;
 
 const wasRestOrWarning = yesterdayLog.command === 'REST' || yesterdayLog.isWarning;
 const followed = yesterdayLog.followed === 'yes';
 
 if (wasRestOrWarning) {
 if (followed) {
 if (improved) return { text: "That discipline showed up.", type: 'validated' };
 if (stable) return { text: "Right call. Still processing.", type: 'neutral' };
 return { text: "Body is catching up. You did your part.", type: 'neutral' };
 } else {
 if (declined) return { text: "Yesterday's push is here.", type: 'consequence' };
 return { text: "Got away with it this time.", type: 'lucky' };
 }
 }
 
 if (yesterdayLog.command === 'PERFORM') {
 if (followed) {
 return { text: "You stopped at one peak. That's why you're not wrecked.", type: 'validated' };
 } else {
 if (declined) return { text: "That extra work showed up.", type: 'consequence' };
 }
 }
 
 return null;
 };

 // ============================================
 // CONTEXT DETECTION (includes mode)
 // ============================================
 const getContext = (command, patterns, complianceLog, hrvHistory = [], daysOnApp = 0) => {
 const context = { 
 type: 'default', 
 mode: 'UNCERTAIN',
 isWarning: false, 
 isConsecutive: false, 
 isAfterRest: false,
 confidence: { level: 'low', score: 30 }
 };
 if (!patterns) return context;
 
 // Calculate confidence
 context.confidence = calculateConfidence(hrvHistory, patterns, complianceLog);
 
 // Determine mode (DIRECTIVE / PROTECTIVE / UNCERTAIN)
 context.mode = getMode(context.confidence, complianceLog, daysOnApp);
 
 // PROTECTIVE and UNCERTAIN modes trigger warning state
 if (context.mode !== 'DIRECTIVE') {
 context.isWarning = true;
 }
 
 // Trend-based warning
 if (patterns.trend === 'falling' || patterns.consecutiveBelowBaseline >= 2) {
 context.isWarning = true;
 context.type = 'warning';
 }
 
 // After rest context
 if (command === 'BUILD' && patterns.daysSinceRest === 1) {
 const yesterday = getYesterdayLocal();
 const yesterdayLog = complianceLog.find(c => c.date === yesterday);
 if (yesterdayLog?.followed === 'yes') {
 context.isAfterRest = true;
 if (context.mode === 'DIRECTIVE') context.type = 'after_rest';
 }
 }
 
 // PERFORM context
 if (command === 'PERFORM') {
 const yesterday = getYesterdayLocal();
 const yesterdayLog = complianceLog?.find(c => c.date === yesterday);
 if (yesterdayLog?.command === 'PERFORM') {
 context.isConsecutive = true;
 context.type = 'consecutive';
 }
 if (patterns.totalDays >= 14 && patterns.crashesAfterIgnoredRest?.length >= 2) {
 context.isWarning = true;
 if (!context.isConsecutive) context.type = 'warning';
 }
 }
 
 return context;
 };

 // ============================================
 // THE VOICE - Three-Mode Communication System
 // + Personalization Layer (rarity, proof, date anchors)
 // + Streak-aware observations
 // Expanded library: 15 phrases per mode/command
 // ============================================
 const generateObservation = (command, patterns, daysOnApp, lastObservationType, hrvHistory, complianceLog = []) => {
 const today = new Date();
 const seed = today.getFullYear() * 10000 + (today.getMonth() + 1) * 100 + today.getDate();
 const pick = (arr) => arr.length > 0 ? arr[seed % arr.length] : null;
 
 if (!patterns) {
 const daysRemaining = 4 - hrvHistory.length;
 if (daysRemaining > 0) return { text: `${daysRemaining} day${daysRemaining > 1 ? 's' : ''} until commands. Add history below to unlock today.`, type: 'learning_countdown' };
 return { text: "Your baseline is forming.", type: 'learning_forming' };
 }

 // Get context with mode
 const context = getContext(command, patterns, complianceLog, hrvHistory, daysOnApp);
 const mode = context.mode;
 const confidence = context.confidence;
 
 // === PERSONALIZATION DATA ===
 const daysSincePerform = patterns.daysSincePerform || 0;
 const daysSinceRest = patterns.daysSinceRest || 0;
 const crashCount = patterns.crashesAfterIgnoredRest?.length || 0;
 const consecutiveCrashes = patterns.consecutivePerformCrashes || 0;
 
 // Compliance streak calculation
 const getComplianceStreak = () => {
 let streak = 0;
 const sorted = [...complianceLog].sort((a, b) => new Date(b.date) - new Date(a.date));
 for (const log of sorted) {
 if (log.followed === 'yes') streak++;
 else break;
 }
 return streak;
 };
 const complianceStreak = getComplianceStreak();
 
 // Date anchor helper (format: "January 15th")
 const formatDateAnchor = (dateStr) => {
 if (!dateStr) return null;
 const date = new Date(dateStr + 'T12:00:00');
 const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
 const day = date.getDate();
 const suffix = day === 1 || day === 21 || day === 31 ? 'st' : day === 2 || day === 22 ? 'nd' : day === 3 || day === 23 ? 'rd' : 'th';
 return `${months[date.getMonth()]} ${day}${suffix}`;
 };
 
 // Gates for personalization
 const canUsePersonalization = daysOnApp >= 14 && confidence.level !== 'low';
 const canUseDateAnchors = canUsePersonalization && confidence.level === 'high';
 
 // Milestones (override everything)
 const milestones = { 
 7: "A week. Now we build.", 
 14: "Two weeks. I know your patterns.", 
 30: "Most people quit by now. You didn't.", 
 60: "Two months. Your data tells a real story now.",
 90: "Three months. The patterns are undeniable.",
 100: "100 entries. That's commitment."
 };
 if (milestones[daysOnApp]) return { text: milestones[daysOnApp], type: `milestone_${daysOnApp}` };

 // === STREAK-AWARE OBSERVATIONS (rare) ===
 if (canUsePersonalization && complianceStreak >= 10 && seed % 7 === 0) {
 return { text: `${complianceStreak} days listening. That's rare. That's real.`, type: 'streak_wow' };
 }
 if (canUsePersonalization && complianceStreak >= 5 && complianceStreak < 10 && seed % 5 === 0) {
 return { text: "You've been following. The numbers reflect it.", type: 'streak_building' };
 }

 // ========== REST OBSERVATIONS ==========
 if (command === 'REST') {
 // PERSONALIZATION: Date anchor warning (highest priority)
 if (canUseDateAnchors && patterns.nearestMatch?.nextDayCrashed) {
 const anchor = formatDateAnchor(patterns.nearestMatch.date);
 if (anchor) return { text: `This looks like ${anchor}. That day cost you.`, type: 'rest_date_anchor' };
 }
 
 // PERSONALIZATION: Small-number proof
 if (canUsePersonalization && crashCount >= 2) {
 return { text: `${crashCount} times you've pushed through REST. ${crashCount} times you paid.`, type: 'rest_proof' };
 }
 
 // MODE-BASED (expanded)
 if (mode === 'DIRECTIVE') {
 return pick([
 { text: "Rest today. Train Thursday.", type: 'rest_directive' },
 { text: "Recovery day. The work is already done.", type: 'rest_directive' },
 { text: "Not today. Tomorrow.", type: 'rest_directive' },
 { text: "Off day. Full stop.", type: 'rest_directive' },
 { text: "No training today.", type: 'rest_directive' },
 { text: "The adaptation happens now. Don't interrupt it.", type: 'rest_directive' },
 { text: "You stressed the system. Now it rebuilds.", type: 'rest_directive' },
 { text: "The stimulus is in. The response takes time.", type: 'rest_directive' },
 { text: "Thursday is the day. Protect it.", type: 'rest_directive' },
 { text: "Tomorrow's capacity is being built right now.", type: 'rest_directive' },
 { text: "What you skip today, you gain back double.", type: 'rest_directive' },
 { text: "You've been listening. Keep going.", type: 'rest_directive' },
 { text: "The pattern is holding. Stay patient.", type: 'rest_directive' }
 ]);
 }
 if (mode === 'PROTECTIVE') {
 return pick([
 { text: "You want to move. I get it. Still: REST.", type: 'rest_protective' },
 { text: "The itch is loud. The signal says wait.", type: 'rest_protective' },
 { text: "I know you feel fine. The numbers don't agree.", type: 'rest_protective' },
 { text: "I get why you want to go. Today's job is restraint.", type: 'rest_protective' },
 { text: "The urge is real. So is the data.", type: 'rest_protective' },
 { text: "This is where you usually push. Don't.", type: 'rest_protective' },
 { text: "I've seen this setup before. You pushed and paid.", type: 'rest_protective' },
 { text: "Same setup. Different choice this time.", type: 'rest_protective' },
 { text: "You're not losing a day. You're buying two.", type: 'rest_protective' },
 { text: "Skip today, win Thursday. That's the trade.", type: 'rest_protective' },
 { text: "This is the part where you usually overspend. Not today.", type: 'rest_protective' },
 { text: "I'm not saying you can't. I'm saying it'll cost you.", type: 'rest_protective' },
 { text: "You could train. You'd survive. Tomorrow is the question.", type: 'rest_protective' }
 ]);
 }
 // UNCERTAIN
 return pick([
 { text: "Signal is unclear. Default to less.", type: 'rest_uncertain' },
 { text: "Not enough data to push. Tomorrow will tell us more.", type: 'rest_uncertain' },
 { text: "Something's off in the readings. Stay conservative.", type: 'rest_uncertain' },
 { text: "Travel threw off the signal. Give it 48 hours.", type: 'rest_uncertain' },
 { text: "The data is noisy. Play it safe.", type: 'rest_uncertain' },
 { text: "When in doubt, do less.", type: 'rest_uncertain' },
 { text: "Unclear signal means conservative play.", type: 'rest_uncertain' },
 { text: "Can't be certain. Going cautious.", type: 'rest_uncertain' },
 { text: "Tomorrow's reading will be cleaner.", type: 'rest_uncertain' },
 { text: "Give me one more day of data.", type: 'rest_uncertain' }
 ]);
 }

 // ========== BUILD OBSERVATIONS ==========
 if (command === 'BUILD') {
 // PERSONALIZATION: Rarity callout (long time since PERFORM)
 if (canUsePersonalization && daysSincePerform >= 10) {
 return { text: `${daysSincePerform} days since green. BUILD is building toward it.`, type: 'build_rarity' };
 }
 
 // After rest (special case)
 if (context.isAfterRest && mode === 'DIRECTIVE') {
 return pick([
 { text: "Yesterday's rest bought this. Execute the plan.", type: 'build_after_rest' },
 { text: "That rest is showing up. Use it, don't spend it.", type: 'build_after_rest' },
 { text: "The investment is maturing. Solid work today.", type: 'build_after_rest' },
 { text: "You rested. This is the dividend. Collect it.", type: 'build_after_rest' },
 { text: "Execute completely. You've earned full capacity.", type: 'build_after_rest' }
 ]);
 }
 
 // MODE-BASED (expanded)
 if (mode === 'DIRECTIVE') {
 return pick([
 { text: "Work available. Execute the plan.", type: 'build_directive' },
 { text: "Solid day. Do what's written.", type: 'build_directive' },
 { text: "Room to work. Not room to add.", type: 'build_directive' },
 { text: "Standard capacity. Execute.", type: 'build_directive' },
 { text: "Good day for work. Not for testing limits.", type: 'build_directive' },
 { text: "Climbing. Don't change anything.", type: 'build_directive' },
 { text: "Something's working. Stick to it.", type: 'build_directive' },
 { text: "Trend is up. Keep doing what you're doing.", type: 'build_directive' },
 { text: "Middle of the range. Execute your program.", type: 'build_directive' },
 { text: "Nothing special. That's the point.", type: 'build_directive' },
 { text: "Boring is good. Boring compounds.", type: 'build_directive' }
 ]);
 }
 if (mode === 'PROTECTIVE') {
 return pick([
 { text: "You want to push. The trend says don't.", type: 'build_protective' },
 { text: "Work is available. The margin is smaller than it looks.", type: 'build_protective' },
 { text: "BUILD, not PERFORM. The trend is tilting.", type: 'build_protective' },
 { text: "I know you want more. Today isn't the day.", type: 'build_protective' },
 { text: "I almost gave you REST. Respect that.", type: 'build_protective' },
 { text: "This is BUILD with a flag. Eyes open.", type: 'build_protective' },
 { text: "Yellow light. Proceed with caution.", type: 'build_protective' },
 { text: "Full workout, but no extras. No finisher.", type: 'build_protective' },
 { text: "Execute the plan. Then leave. That's it.", type: 'build_protective' },
 { text: "A controlled BUILD keeps the streak alive.", type: 'build_protective' },
 { text: "Smart today, strong Saturday. Your choice.", type: 'build_protective' }
 ]);
 }
 // UNCERTAIN
 return pick([
 { text: "Signal is forming. Stay controlled.", type: 'build_uncertain' },
 { text: "Do what's programmed. Nothing extra.", type: 'build_uncertain' },
 { text: "Uncertain signal means conservative play.", type: 'build_uncertain' },
 { text: "Execute. Don't experiment.", type: 'build_uncertain' },
 { text: "Standard session. Stay controlled.", type: 'build_uncertain' },
 { text: "The data is noisy. Keep it moderate.", type: 'build_uncertain' },
 { text: "Tomorrow will be clearer. Don't overcommit today.", type: 'build_uncertain' }
 ]);
 }

 // ========== PERFORM OBSERVATIONS ==========
 if (command === 'PERFORM') {
 // PERSONALIZATION: Consecutive crash proof (highest priority for PERFORM)
 if (canUsePersonalization && context.isConsecutive && consecutiveCrashes >= 2) {
 const total = consecutiveCrashes + 1;
 return { text: `${consecutiveCrashes} of ${total} back-to-backs cost you. One peak, then done.`, type: 'perform_consecutive_proof' };
 }
 
 // PERSONALIZATION: Date anchor (similar pattern warning)
 if (canUseDateAnchors && patterns.nearestMatch?.pushed && patterns.nearestMatch?.nextDayCrashed) {
 const anchor = formatDateAnchor(patterns.nearestMatch.date);
 if (anchor) return { text: `You were here on ${anchor}. One peak—then leave.`, type: 'perform_date_anchor' };
 }
 
 // PERSONALIZATION: Rarity callout
 if (canUsePersonalization && daysSincePerform >= 7) {
 return { text: `First green in ${daysSincePerform} days. Make it count.`, type: 'perform_rarity' };
 }
 
 // Consecutive (standard)
 if (context.isConsecutive) {
 return pick([
 { text: "Back-to-back green is rare. Today's skill is restraint.", type: 'perform_consecutive' },
 { text: "Second straight day. Don't chase the hat trick.", type: 'perform_consecutive' },
 { text: "Day 2 is the discipline. Day 3 is where egos get hurt.", type: 'perform_consecutive' },
 { text: "Consecutive greens are a gift. Don't turn the gift into a curse.", type: 'perform_consecutive' }
 ]);
 }
 
 // MODE-BASED (expanded)
 if (mode === 'DIRECTIVE') {
 return pick([
 { text: "Green light. One peak.", type: 'perform_directive' },
 { text: "The tank is full. Use it.", type: 'perform_directive' },
 { text: "Go. Then stop.", type: 'perform_directive' },
 { text: "Today is the day. Make it count.", type: 'perform_directive' },
 { text: "All systems go. One effort.", type: 'perform_directive' },
 { text: "You rested when I said rest. This is what that buys.", type: 'perform_directive' },
 { text: "That patience paid off. Here's your green light.", type: 'perform_directive' },
 { text: "You trusted the system. This is the reward.", type: 'perform_directive' },
 { text: "Everything is aligned. Go.", type: 'perform_directive' },
 { text: "No caveats today. Full send, then stop.", type: 'perform_directive' },
 { text: "Clear signal. One peak effort.", type: 'perform_directive' }
 ]);
 }
 if (mode === 'PROTECTIVE') {
 return pick([
 { text: "Green light. But you've been here before and paid for it.", type: 'perform_protective' },
 { text: "Yes means yes. It doesn't mean reckless.", type: 'perform_protective' },
 { text: "The numbers say go. History says be smart about it.", type: 'perform_protective' },
 { text: "You earned this. Don't waste it by overdoing it.", type: 'perform_protective' },
 { text: "Last time you saw green, you cooked yourself. One peak.", type: 'perform_protective' },
 { text: "One effort. Then coast. No negotiations.", type: 'perform_protective' },
 { text: "Peak early. Leave early. That's the discipline.", type: 'perform_protective' },
 { text: "Attack, retreat, leave. Three steps. Done.", type: 'perform_protective' },
 { text: "This green light leads to the next one—if you're smart.", type: 'perform_protective' },
 { text: "You want another green Friday? Leave something in the tank.", type: 'perform_protective' },
 { text: "The encore is where you always pay. Skip it.", type: 'perform_protective' }
 ]);
 }
 // UNCERTAIN
 return pick([
 { text: "Green, but signal is noisy. Keep it controlled.", type: 'perform_uncertain' },
 { text: "Capacity is there. Don't outrun the data.", type: 'perform_uncertain' },
 { text: "Green with a flag. Eyes open.", type: 'perform_uncertain' },
 { text: "The signal says yes. Stay controlled anyway.", type: 'perform_uncertain' },
 { text: "One good effort. Save the heroics for when we're sure.", type: 'perform_uncertain' },
 { text: "Execute. Don't explore.", type: 'perform_uncertain' }
 ]);
 }
 
 return { text: "Baseline forming.", type: 'learning' };
 };

 // ============================================
 // THE ACTION SYSTEM - Three-Mode Architecture
 // Expanded library: 8 options per field
 // Forward loss frames in every recovery lever
 // No HR guidance - nasal breathing, talk test, RPE only
 // ============================================
 const generateActions = (command, patterns, hrvHistory, complianceLog = [], daysOnApp = 0) => {
 if (!patterns || hrvHistory.length < 7) return null;
 const today = new Date();
 const seed = today.getFullYear() * 10000 + (today.getMonth() + 1) * 100 + today.getDate() + (command?.charCodeAt(0) || 0);
 const pick = (arr) => arr.length > 0 ? arr[seed % arr.length] : null;
 
 // Get context with mode
 const context = getContext(command, patterns, complianceLog, hrvHistory, daysOnApp);
 const mode = context.mode;

 // ========== REST ACTIONS ==========
 if (command === 'REST') {
 if (mode === 'DIRECTIVE') {
 return {
 primaryAction: pick([
 "Rest today. Train Thursday.",
 "Sleep is the session. Protect 8 hours.",
 "20 minutes walk + mobility. That's the whole day.",
 "No training. Recovery is the work.",
 "Stay out of the gym. One walk, one stretch. Done.",
 "Active recovery only: walk, stretch, foam roll. 20 minutes max.",
 "The prescription is rest. Not 'light training.' Rest.",
 "Off day. Sleep, eat, hydrate. That's the program."
 ]),
 effortBoundary: pick([
 "Nose breathing only. Mouth opens, you're working too hard.",
 "RPE 2. You should feel under-challenged.",
 "Conversation pace. Full sentences, no gasping.",
 "If it feels like exercise, you've gone too far.",
 "You should be bored. That's the point.",
 "Easy enough to do while talking on the phone.",
 "If you break a sweat, you've overdone it.",
 "Finish feeling the same or better than when you started."
 ]),
 recoveryLever: pick([
 "Thursday's session is on the line tonight.",
 "What you do tonight determines what you can do this weekend.",
 "8 hours sleep. That's the down payment on your next green light.",
 "Tonight's recovery is tomorrow's capacity. Protect it.",
 "You're building Thursday's strength right now. Don't interrupt.",
 "The next PERFORM day is being assembled. Sleep is the factory.",
 "Skip the late night. It costs you Saturday.",
 "Every hour of sleep tonight is a rep you'll have Thursday."
 ]),
 guardrail: pick([
 "No intensity today.",
 "Don't test how you feel with a workout.",
 "The gym costs more than it gives today.",
 "No lifting. No intervals. No 'just a quick one.'",
 "Stay out of the gym. Period.",
 "No sweat. No soreness. No heavy breathing.",
 "If you're tempted to 'see how you feel'—don't.",
 "The only acceptable movement is walking pace or slower."
 ])
 };
 }
 if (mode === 'PROTECTIVE') {
 return {
 primaryAction: pick([
 "You want to move. I get it. 20 minutes walk, then done.",
 "The itch is real. Scratch it with mobility, not intensity.",
 "If you need a win: end the day with more energy than you started.",
 "Walk. Stretch. Leave it there.",
 "I know you want more. 20 minutes gentle movement is the ceiling.",
 "The gym isn't the answer today. A walk might be.",
 "Movement is fine. Training is not. Know the difference.",
 "Your body wants activity. Give it a walk, not a workout."
 ]),
 effortBoundary: pick([
 "Nasal breathing the entire time. Mouth opens, you stop.",
 "RPE 2. If it feels like exercise, you've gone too far.",
 "Talk test: full sentences without pausing for breath.",
 "If you're tempted to speed up, that's the signal to stop.",
 "You should finish feeling the same as when you started.",
 "No music. No pace goals. No tracking the walk.",
 "Easy enough to do indefinitely. You're not going indefinitely.",
 "Finish feeling the same or better. Not tired."
 ]),
 recoveryLever: pick([
 "You're choosing between today's sweat and Saturday's session. Saturday matters more.",
 "Every bit of intensity today comes out of Thursday's tank.",
 "The workout you want today costs the workout you need this weekend.",
 "Push now, pay Friday. That's the trade and it's not close.",
 "You're trading a real session for a fake one. Don't.",
 "The itch goes away in an hour. The cost lasts three days.",
 "Is today worth giving up two days? It's not.",
 "That gym session you're craving? It costs Saturday AND Sunday."
 ]),
 guardrail: pick([
 "No intensity. If you override: 15 minutes technique work, nasal breathing, leave before you sweat.",
 "No training. If you must move: 20-minute walk, conversation pace, that's the ceiling.",
 "No gym. If you can't stay away: mobility only, 15 minutes, RPE 2, then leave.",
 "If you absolutely must: walk outside. 20 minutes. No music, no goals.",
 "Override option: yoga or stretching. Nothing that makes you breathe hard.",
 "If you go anyway: bodyweight only, no load, 15 minutes, leave feeling fresh.",
 "Last resort: technique practice, empty barbell, 10 minutes, that's it.",
 "If you can't rest: walk to a coffee shop. That's the workout."
 ])
 };
 }
 // UNCERTAIN
 return {
 primaryAction: pick([
 "Signal is unclear. Default to less.",
 "When in doubt, walk. 20 minutes, easy pace.",
 "Not enough data to push. Tomorrow will tell us more.",
 "Uncertain signal means rest is the safe play.",
 "I can't read the signal clearly. Play it conservative.",
 "Give me one more day of clean data before we push."
 ]),
 effortBoundary: pick([
 "Easy enough to hold a conversation the whole time.",
 "If you're not sure it's easy enough, it's not.",
 "Nasal breathing. No exceptions today.",
 "RPE 2 max. Boring is the goal.",
 "If you have to think about whether it's too hard, stop.",
 "Movement should feel optional, not necessary."
 ]),
 recoveryLever: pick([
 "Unclear signal means conservative play. We'll reassess tomorrow.",
 "When the data is noisy, rest is never wrong.",
 "Tomorrow's reading will be more useful. Don't outrun the information.",
 "Give me clean data tomorrow. That's worth more than today's workout.",
 "One more rest day clarifies everything.",
 "Patience today buys clarity tomorrow."
 ]),
 guardrail: pick([
 "Keep it minimal. When the signal is unclear, less is always right.",
 "If you train, keep it short and easy. You'll know more tomorrow.",
 "Default to nothing. A missed day costs less than a wrong day.",
 "Uncertain = automatic rest. No negotiations.",
 "When I'm not sure, you shouldn't be aggressive.",
 "The safe play when blind: don't move."
 ])
 };
 }

 // ========== BUILD ACTIONS ==========
 if (command === 'BUILD') {
 if (context.isAfterRest && mode === 'DIRECTIVE') {
 return {
 primaryAction: pick([
 "Yesterday's rest bought this. Execute the plan fully.",
 "Full session. No additions. Bank it.",
 "Do what's written. Leave with fuel in the tank.",
 "You rested. This is the dividend. Collect it.",
 "Execute completely. You've earned full capacity.",
 "Standard program, full effort. That rest is showing.",
 "The investment matured. Reinvest wisely.",
 "Full workout. You have the gas. Use it—don't abuse it."
 ]),
 effortBoundary: pick([
 "RPE 7. Finish with something left. That's how you string good days together.",
 "Quality reps. Stop before form degrades.",
 "If you're tempted to add, that's the signal to leave.",
 "Full effort doesn't mean maximum effort. Know the difference.",
 "Push to 7. Not 8. Not 9. Seven.",
 "Leave wanting more. That's the skill.",
 "Strong finish, not exhausted finish.",
 "The temptation to do more is strongest after rest. Resist it."
 ]),
 recoveryLever: pick([
 "Two good days in a row is the goal. Tonight's sleep protects the streak.",
 "Don't undo yesterday's investment with tonight's choices.",
 "This is compound interest. Keep the deposits coming.",
 "One good day leads to another—if you protect it tonight.",
 "Yesterday's rest + today's work + tonight's sleep = momentum.",
 "The streak is fragile. Tonight is where it breaks or holds.",
 "You're building something. Don't burn it down tonight.",
 "Three good days in a row changes everything. Tonight is day two."
 ]),
 guardrail: pick([
 "Don't spend yesterday's rest in one session.",
 "Feeling good isn't permission. It's a resource.",
 "One rest day doesn't clear all debt. Stay patient.",
 "The bounce back isn't a blank check. It's a down payment.",
 "Good day ≠ go crazy day.",
 "You feel better. That doesn't mean 'test your limits.'",
 "Rest restored capacity, not invincibility.",
 "The trap: feeling good leads to doing too much. Avoid the trap."
 ])
 };
 }
 if (mode === 'DIRECTIVE') {
 return {
 primaryAction: pick([
 "Do what's programmed. Nothing extra.",
 "Full workout. Leave 10 minutes before you normally would.",
 "Main work. Skip the finisher.",
 "Execute the plan. Walk out with something left.",
 "Programmed work only. No additions.",
 "Standard session. Nothing special—that's the point.",
 "Full workout, moderate intensity. Leave before you have to.",
 "Do the work. Don't do more than the work."
 ]),
 effortBoundary: pick([
 "RPE 7 cap. Finish feeling like you could do more—then don't.",
 "When form breaks, rack it. No grind reps.",
 "Stop while it still looks good.",
 "If you're questioning whether to add another set, don't.",
 "Leave the gym wanting slightly more. That's the target.",
 "Quality reps only. When they get ugly, you're done.",
 "RPE 6-7. No redlining. No heroics.",
 "If it turns into a fight, stop. You've gone too far."
 ]),
 recoveryLever: pick([
 "Tonight's sleep is tomorrow's capacity.",
 "Protein within 2 hours. That's the reload.",
 "What you do after determines whether this session compounds or costs.",
 "Recovery starts when you leave. Treat it like part of the workout.",
 "Tonight's choices show up in tomorrow's numbers. Choose wisely.",
 "The work is done. The building happens while you sleep.",
 "8 hours tonight or 80% tomorrow. Pick one.",
 "Every late night costs you a rep tomorrow."
 ]),
 guardrail: pick([
 "Don't turn BUILD into PERFORM.",
 "Today is for deposits, not withdrawals.",
 "Finish with something left. That's the whole point.",
 "No testing maxes. No PR attempts. Not today.",
 "Execute. Don't explore.",
 "The extra set isn't worth it. Leave.",
 "If you're eyeing the heavy weights, look away.",
 "BUILD means build. It doesn't mean break."
 ])
 };
 }
 if (mode === 'PROTECTIVE') {
 return {
 primaryAction: pick([
 "Same session. Pull one lever back 20%: load, reps, or time. Pick one.",
 "80% of what's programmed. Cut the last movement.",
 "Main work only. Skip accessories entirely.",
 "Abbreviated session. In and out in 40 minutes.",
 "Whatever you planned, do 75% of it.",
 "Standard workout minus one movement. Your choice which.",
 "Full session structure, reduced intensity across the board.",
 "Execute, but dial everything down one notch."
 ]),
 effortBoundary: pick([
 "RPE 6 ceiling. When form slips, you're done.",
 "If it becomes survival, stop. A short session beats a crash.",
 "45 minute cap. Leave before you want to.",
 "The moment it feels hard, start wrapping up.",
 "No grind sets. Nothing that requires a pep talk.",
 "If you need to rest longer between sets, that's the signal to leave.",
 "Stop at 'good enough.' Don't chase 'great.'",
 "First sign of struggle = last set of the day."
 ]),
 recoveryLever: pick([
 "The trend is tilting. Tonight decides if this week recovers or spirals.",
 "Sleep 30 minutes earlier than usual. That's the circuit breaker.",
 "You're 48 hours from this being a bad week or a reset. Tonight is the difference.",
 "Extra recovery tonight or extended hole this week. Choose now.",
 "What you do in the next 12 hours determines if this is a blip or a slide.",
 "The warning is real. Tonight's sleep is the medicine.",
 "One good night can reverse this. One bad night confirms it.",
 "Protect tonight like Friday depends on it. Because it does."
 ]),
 guardrail: pick([
 "No digging deep. If you override: main work only, RPE 6 cap, 40 minute hard stop.",
 "No finishers. If you ignore this: leave immediately after the main lift.",
 "No volume adds. If you must 'do more': add mobility, not sets.",
 "If you push: cut 20% off everything. Load, reps, or time. Pick one.",
 "Override rule: whatever you planned, do 75% of it.",
 "If you go heavy: one working set per movement. That's it.",
 "Safe override: main movement, 3 sets, moderate weight, done in 30.",
 "If you can't hold back: drop all accessory work. Main lifts only."
 ])
 };
 }
 // UNCERTAIN
 return {
 primaryAction: pick([
 "Do what's programmed. Nothing extra.",
 "Standard session. Stay controlled.",
 "Execute. Don't experiment.",
 "Uncertain signal means conservative play.",
 "Standard workout. Nothing ambitious.",
 "Execute the plan. Leave the extras."
 ]),
 effortBoundary: pick([
 "RPE 6-7. Stop before form breaks.",
 "If it feels hard early, cut it short.",
 "Quality over quantity today.",
 "Stop before you have to.",
 "No grind reps on unclear days.",
 "If warm-up feels off, scale back."
 ]),
 recoveryLever: pick([
 "We'll know more tomorrow. Don't outrun the data.",
 "Conservative is never wrong when signal is noisy.",
 "Tomorrow's reading will tell the real story.",
 "Give me clean data tomorrow.",
 "One cautious day clears up a lot.",
 "Patience today, clarity tomorrow."
 ]),
 guardrail: pick([
 "Keep it moderate. When the signal is unclear, less is always right.",
 "No heroics when the data is noisy.",
 "Uncertain = automatic scale-back.",
 "Don't push into fog.",
 "When I'm not sure, you shouldn't be aggressive.",
 "Safe play: finish under-challenged, not over-extended."
 ])
 };
 }

 // ========== PERFORM ACTIONS ==========
 if (command === 'PERFORM') {
 if (context.isConsecutive) {
 return {
 primaryAction: pick([
 "Shorter session than yesterday. 75% duration, 85% intensity.",
 "Main work only. Cut accessories. Be out in 40 minutes.",
 "One moderate-high effort. No true max attempts.",
 "Abbreviated everything. Quality over quantity.",
 "Yesterday's session, minus 25%. That's today.",
 "Main lift, reduced volume, early exit.",
 "Half the time, three-quarters the intensity.",
 "Compact session. In by :00, out by :35."
 ]),
 effortBoundary: pick([
 "RPE 7-8 ceiling. Lower than yesterday.",
 "If warm-up feels off, convert to BUILD. No questions.",
 "Quality over quantity. Every rep should look like rep one.",
 "Stop before yesterday's stopping point.",
 "No grind sets. If it's a fight, you're done.",
 "The moment you feel yesterday, stop.",
 "First sign of accumulated fatigue = wrap it up.",
 "Warm-up is the test. If it's heavy, convert to BUILD."
 ]),
 recoveryLever: pick([
 "This is probably your last green for a while. Plan for REST tomorrow.",
 "Tonight is critical. 8+ hours, extra protein, full hydration.",
 "Recovery starts the moment you leave. Everything else is secondary.",
 "Tomorrow is REST. Accept it now. Plan for it tonight.",
 "Two big days need two big nights. Tonight is the second.",
 "You pushed twice. You recover twice. Non-negotiable.",
 "The bill is coming. Pay it tonight with sleep and food.",
 "Back-to-back intensity requires back-to-back recovery. Start now."
 ]),
 guardrail: pick([
 "Don't chase the hat trick. That's where people break.",
 "Tomorrow's REST is already scheduled. Accept it now.",
 "Two in a row is rare. Three almost never ends well.",
 "Day 2 is the discipline. Day 3 is where egos get hurt.",
 "The third day is a trap. Don't fall for it.",
 "You've used your bullets. Don't click on an empty chamber.",
 "Consecutive greens are a gift. Don't turn the gift into a curse.",
 "Stop while you're ahead. The streak ends here by choice, not injury."
 ])
 };
 }
 if (mode === 'DIRECTIVE') {
 return {
 primaryAction: pick([
 "Hardest work in the first 15-20 minutes.",
 "One peak effort. Put it early.",
 "The tank is full. Empty the part that matters, then coast.",
 "Go hard early. Then cruise to the finish.",
 "Front-load the intensity. Coast home.",
 "Hit your peak in the first half. Ride it out.",
 "Maximum effort, minimum duration. One shot.",
 "Attack early. The rest is maintenance."
 ]),
 effortBoundary: pick([
 "RPE 9 once. Then drop to 6-7 and stay there.",
 "Leave a rep in reserve even on the hardest set.",
 "45-60 minutes total. Then leave.",
 "One true max effort. Everything else is moderate.",
 "Hit 90%, not 100%. That 10% is tomorrow's margin.",
 "Peak effort, then active recovery. No second peaks.",
 "Push hard, but stop before failure. Leave something.",
 "RPE 8-9 for the main work. RPE 6 for everything else."
 ]),
 recoveryLever: pick([
 "Refuel within 60 minutes. Sleep locks in the gain.",
 "Tonight decides if this peak compounds or costs.",
 "Tomorrow's command depends on tonight's recovery.",
 "You spent capacity. Now you restore it. Non-negotiable.",
 "This was a withdrawal. The deposit happens tonight.",
 "Protein + sleep = you get to do this again. Skip either, you don't.",
 "What you do in the next 8 hours determines if this compounds or costs.",
 "Tonight's sleep is the ROI on today's effort. Don't skip it."
 ]),
 guardrail: pick([
 "One peak. You're trading tomorrow for every rep after that.",
 "Don't turn a great day into a two-day hangover.",
 "No second wind. That's where injuries live.",
 "No encore. The show is over when the peak is done.",
 "One more set = one more day recovering. Not worth it.",
 "The best decision after a great effort: leave.",
 "Don't chase the dragon. You peaked. Go home.",
 "The extra 10 minutes you want costs 48 hours you need."
 ])
 };
 }
 if (mode === 'PROTECTIVE') {
 return {
 primaryAction: pick([
 "One hard effort in the first 15 minutes. Then coast.",
 "Hit your main work at RPE 8. Skip accessories.",
 "Attack, then retreat. No lingering.",
 "One big effort, then downshift hard.",
 "Peak quick. Exit quicker.",
 "Front-load everything. Back-load nothing.",
 "Do the work. Skip the extra.",
 "Intensity first, then active recovery. That's the whole session."
 ]),
 effortBoundary: pick([
 "RPE 8 once. Then immediately drop to 6. Hard stop.",
 "45 minutes including warm-up. Then leave.",
 "One solid effort. Whether it's a PR or not, move on.",
 "Don't search for the perfect set. Take what you get.",
 "No second attempts on anything. Hit it or move on.",
 "Cap intensity at 85%. No redlining today.",
 "Shorter than you want. Better than you need.",
 "When the clock hits 40, start packing up."
 ]),
 recoveryLever: pick([
 "You've paid for overdoing this before. Tonight is the insurance.",
 "What you do in the next 12 hours matters more than what you did in the gym.",
 "Protein within 30 minutes. Sleep 30 minutes earlier than usual.",
 "You have a history here. Break it tonight with actual recovery.",
 "Last time you overdid a green light, you lost days. Remember that tonight.",
 "The pattern is: go hard, skip recovery, crash. Break it.",
 "Tonight's sleep is the difference between a good day and a good week.",
 "You know how this ends if you don't recover. Choose differently."
 ]),
 guardrail: pick([
 "One peak only. If you override: RPE 6 for 10 minutes max after, then done.",
 "No chasing. If you must keep going: technique work only, no load.",
 "No second attempts. You've seen how this ends.",
 "If you want more after the peak: 10 minutes easy movement, then leave.",
 "Override limit: one accessory movement, light weight, done in 10 minutes.",
 "If you can't leave: mobility work only. No weights. No cardio.",
 "Safe escape: cool down, stretch, go home. That's the only option.",
 "If the gym is calling you back: walk out. Come back tomorrow."
 ])
 };
 }
 // UNCERTAIN
 return {
 primaryAction: pick([
 "One controlled effort. Don't go searching for your ceiling.",
 "Main work at moderate-high intensity. Skip the extras.",
 "Execute. Don't explore.",
 "One good effort. Don't chase greatness on unclear signal.",
 "Standard peak effort. Nothing ambitious.",
 "Execute the plan. Leave the extras."
 ]),
 effortBoundary: pick([
 "RPE 7-8. Not the day for true max attempts.",
 "Stop while it still feels good.",
 "Quality is the priority when signal is unclear.",
 "No grinding. Take what's there.",
 "If it feels like work early, scale back.",
 "One peak, moderate intensity, done."
 ]),
 recoveryLever: pick([
 "Conservative is never wrong when data is noisy.",
 "Tomorrow will tell us if this was right. Don't compound uncertainty.",
 "Recover like it was a hard day. Better safe.",
 "Unclear signal = extra recovery tonight.",
 "Sleep well. Tomorrow's data will be cleaner.",
 "Don't stack uncertainty. Recover fully."
 ]),
 guardrail: pick([
 "Don't max out on an unclear signal.",
 "One good effort. Save the heroics for when we're sure.",
 "Uncertain = automatic restraint.",
 "No pushing into fog.",
 "When I'm not sure, you shouldn't be aggressive.",
 "Safe play: peak once, leave early, recover fully."
 ])
 };
 }
 return null;
 };

 // ============================================
 // FEEDBACK MODAL - The Invitation (not a survey)
 // ============================================
 const FeedbackModal = ({ 
 round, daysOnApp,
 step, setStep, 
 response, setResponse, 
 text, setText, 
 email, setEmail, 
 onSend, onDismiss 
 }) => (
 <div className="fixed inset-0 bg-black/70 backdrop-blur-md flex items-center justify-center p-6 z-50">
 <div className="max-w-sm w-full space-y-8">
 
 {/* ===== ROUND 1 (Day 10-14): The Commitment ===== */}
 {round === 1 && (
 <>
 {/* Step 1: Acknowledge */}
 {step === 1 && (
 <div className="text-center space-y-8 fade-in">
 <div className="space-y-4">
 <p className="text-white/30 text-sm tracking-wide">Day {daysOnApp}</p>
 <p className="text-white text-xl leading-relaxed">
 Most people quit by now.
 </p>
 <p className="text-white/60">
 You didn't.
 </p>
 </div>
 
 <button
 onClick={() => setStep(2)}
 className="text-white/40 hover:text-white text-sm transition"
 >
 Continue →
 </button>
 </div>
 )}

 {/* Step 2: What are you building toward? */}
 {step === 2 && (
 <div className="text-center space-y-6 fade-in">
 <p className="text-white text-lg">
 What are you building toward?
 </p>
 
 <div className="space-y-2">
 {[
 { key: 'competition', label: 'Competition' },
 { key: 'longevity', label: 'Longevity' },
 { key: 'consistency', label: 'Staying consistent' },
 { key: 'feeling', label: 'Feeling better' },
 { key: 'other', label: 'Something else' },
 ].map(opt => (
 <button
 key={opt.key}
 onClick={() => { setResponse(opt.key); setStep(opt.key === 'other' ? 3 : 4); }}
 className="w-full glass hover:bg-white/10 text-white/70 hover:text-white py-3 px-4 rounded-2xl text-sm transition-all duration-300"
 >
 {opt.label}
 </button>
 ))}
 </div>
 
 <button 
 onClick={() => onDismiss(false)} 
 className="text-white/20 hover:text-white/40 text-xs transition"
 >
 Skip
 </button>
 </div>
 )}

 {/* Step 3: Something else (free text) */}
 {step === 3 && (
 <div className="text-center space-y-6 fade-in">
 <p className="text-white text-lg">
 Tell me more.
 </p>
 
 <textarea
 value={text}
 onChange={(e) => setText(e.target.value)}
 placeholder="What are you working toward..."
 className="w-full glass rounded-2xl px-4 py-3 text-white text-sm placeholder-white/30 focus:outline-none focus:ring-1 focus:ring-white/20 resize-none h-24"
 autoFocus
 />

 <button
 onClick={() => setStep(4)}
 className="w-full bg-white/90 text-black font-medium py-3 rounded-2xl hover:bg-white transition-all duration-300"
 >
 Continue
 </button>
 </div>
 )}

 {/* Step 4: Early access invitation */}
 {step === 4 && (
 <div className="text-center space-y-6 fade-in">
 <div className="space-y-3">
 <p className="text-white text-lg">
 I'm building something too.
 </p>
 <p className="text-white/40 text-sm leading-relaxed">
 Auto-sync. Deeper patterns.<br/>
 Predictions before you feel them.
 </p>
 </div>
 
 <div className="space-y-3 pt-2">
 <p className="text-white/50 text-sm">Want early access?</p>
 <input
 type="email"
 value={email}
 onChange={(e) => setEmail(e.target.value)}
 placeholder="Email"
 className="w-full glass rounded-2xl px-4 py-3 text-white text-sm text-center placeholder-white/30 focus:outline-none focus:ring-1 focus:ring-white/20"
 />
 </div>

 <div className="space-y-2">
 <button
 onClick={onSend}
 className="w-full bg-white/90 text-black font-medium py-3 rounded-2xl hover:bg-white transition-all duration-300"
 >
 I'm in
 </button>
 <button 
 onClick={onSend}
 className="w-full text-white/40 hover:text-white/60 text-sm py-2 transition"
 >
 Just keep going
 </button>
 </div>
 </div>
 )}
 </>
 )}

 {/* ===== ROUND 2 (Day 35-45): The Inner Circle ===== */}
 {round === 2 && (
 <>
 {/* Step 1: Acknowledge */}
 {step === 1 && (
 <div className="text-center space-y-8 fade-in">
 <div className="space-y-4">
 <p className="text-white/30 text-sm tracking-wide">Day {daysOnApp}</p>
 <p className="text-white text-xl leading-relaxed">
 You're still here.
 </p>
 <p className="text-white/40 text-sm leading-relaxed">
 That puts you ahead of 95% of people<br/>
 who try to train smarter.
 </p>
 </div>
 
 <button
 onClick={() => setStep(2)}
 className="text-white/40 hover:text-white text-sm transition"
 >
 Continue →
 </button>
 </div>
 )}

 {/* Step 2: What would make it better */}
 {step === 2 && (
 <div className="text-center space-y-6 fade-in">
 <div className="space-y-2">
 <p className="text-white text-lg">
 I'm building the next version.
 </p>
 <p className="text-white/40 text-sm">
 What would make this twice as valuable?
 </p>
 </div>
 
 <textarea
 value={text}
 onChange={(e) => setText(e.target.value)}
 placeholder="The one thing..."
 className="w-full glass rounded-2xl px-4 py-3 text-white text-sm placeholder-white/30 focus:outline-none focus:ring-1 focus:ring-white/20 resize-none h-24"
 autoFocus
 />

 <button
 onClick={() => setStep(3)}
 className="w-full bg-white/90 text-black font-medium py-3 rounded-2xl hover:bg-white transition-all duration-300"
 >
 Continue
 </button>
 
 <button 
 onClick={() => setStep(3)} 
 className="text-white/20 hover:text-white/40 text-xs transition"
 >
 Skip
 </button>
 </div>
 )}

 {/* Step 3: Referral */}
 {step === 3 && (
 <div className="text-center space-y-6 fade-in">
 <div className="space-y-3">
 <p className="text-white text-lg">
 One more thing.
 </p>
 <p className="text-white/40 text-sm leading-relaxed">
 Anyone in your life who needs this?
 </p>
 <p className="text-white/25 text-xs">
 A training partner. Someone who never rests.<br/>
 A friend who's always overtrained.
 </p>
 </div>

 <div className="space-y-2">
 <button
 onClick={() => { setResponse('yes'); setStep(4); }}
 className="w-full glass hover:bg-white/10 text-white/70 hover:text-white py-3 rounded-2xl text-sm transition-all duration-300"
 >
 Yes, I know someone
 </button>
 <button
 onClick={() => { setResponse('no'); onSend(); }}
 className="w-full text-white/40 hover:text-white/60 text-sm py-2 transition"
 >
 Not right now
 </button>
 </div>
 </div>
 )}

 {/* Step 4: Get referral contact */}
 {step === 4 && (
 <div className="text-center space-y-6 fade-in">
 <p className="text-white text-lg">
 I'll make sure they get in.
 </p>
 
 <input
 type="text"
 value={email}
 onChange={(e) => setEmail(e.target.value)}
 placeholder="Their email or name"
 className="w-full glass rounded-2xl px-4 py-3 text-white text-sm text-center placeholder-white/30 focus:outline-none focus:ring-1 focus:ring-white/20"
 autoFocus
 />

 <button
 onClick={onSend}
 className="w-full bg-white/90 text-black font-medium py-3 rounded-2xl hover:bg-white transition-all duration-300"
 >
 Done
 </button>
 
 <button 
 onClick={onSend}
 className="text-white/20 hover:text-white/40 text-xs transition"
 >
 Skip
 </button>
 </div>
 )}
 </>
 )}
 </div>
 </div>
 );

 // ============================================
 // COLORS - Earthy, organic palette
 // ============================================
 const COMMAND_STYLES = {
 REST: { 
 color: '#e8b89d', 
 bg: 'rgba(232, 184, 157, 0.12)', 
 border: 'rgba(232, 184, 157, 0.2)',
 glow: 'rgba(232, 184, 157, 0.1)'
 },
 BUILD: { 
 color: '#c9b896', 
 bg: 'rgba(201, 184, 150, 0.12)', 
 border: 'rgba(201, 184, 150, 0.2)',
 glow: 'rgba(201, 184, 150, 0.1)'
 },
 PERFORM: { 
 color: '#9dc4a8', 
 bg: 'rgba(157, 196, 168, 0.12)', 
 border: 'rgba(157, 196, 168, 0.2)',
 glow: 'rgba(157, 196, 168, 0.1)'
 },
 LEARNING: { 
 color: '#a8b5a8', 
 bg: 'rgba(168, 181, 168, 0.12)', 
 border: 'rgba(168, 181, 168, 0.2)',
 glow: 'rgba(168, 181, 168, 0.1)'
 },
 };

 // ============================================
 // TYPEWRITER COMPONENT - Word by word reveal
 // ============================================
 const Typewriter = ({ text, speed = 80, onComplete, className = '' }) => {
 const [displayedWords, setDisplayedWords] = useState(0);
 const [isComplete, setIsComplete] = useState(false);
 const words = text ? text.split(' ') : [];
 
 useEffect(() => {
 if (!text) return;
 setDisplayedWords(0);
 setIsComplete(false);
 }, [text]);
 
 useEffect(() => {
 if (displayedWords < words.length) {
 const timer = setTimeout(() => {
 setDisplayedWords(prev => prev + 1);
 }, speed);
 return () => clearTimeout(timer);
 } else if (words.length > 0 && !isComplete) {
 setIsComplete(true);
 onComplete?.();
 }
 }, [displayedWords, words.length, speed, isComplete, onComplete]);
 
 const visibleText = words.slice(0, displayedWords).join(' ');
 const showCursor = !isComplete && words.length > 0;
 
 return (
 <span className={className}>
 {visibleText}
 {showCursor && <span className="animate-pulse ml-0.5">|</span>}
 </span>
 );
 };

 // ============================================
 // TAGLINE COMPONENT - "Your body is talking."
 // ============================================
 const Tagline = () => (
 <div className="fixed bottom-6 left-0 right-0 text-center fade-in-delay-3" style={{ zIndex: 10, pointerEvents: 'none' }}>
 <p className="text-white/40 text-sm tracking-wide mb-2">Your body is talking.</p>
 <svg className="mx-auto float" width="24" height="24" viewBox="0 0 24 24" fill="none">
 <path d="M12 22C12 22 12 16 12 14C12 12 10 10 8 10C6 10 4 12 4 14C4 16 6 18 8 18" stroke="#8b9b7a" strokeWidth="1.5" strokeLinecap="round"/>
 <path d="M12 22C12 22 12 16 12 14C12 12 14 10 16 10C18 10 20 12 20 14C20 16 18 18 16 18" stroke="#a8b89a" strokeWidth="1.5" strokeLinecap="round"/>
 </svg>
 </div>
 );

 // ============================================
 // HRV SOURCE SELECTOR
 // ============================================
 const HRV_SOURCES = [
 { id: 'whoop', label: 'WHOOP' },
 { id: 'apple', label: 'Apple Watch' },
 { id: 'oura', label: 'Oura' },
 { id: 'garmin', label: 'Garmin' },
 { id: 'fitbit', label: 'Fitbit' },
 { id: 'samsung', label: 'Samsung Watch' },
 ];

 // ============================================
 // INFO MODAL - How GENYSYS Works
 // ============================================
 const InfoModal = ({ onClose, hrvSource }) => {
 // Device-specific HRV instructions
 const getHrvInstructions = () => {
 const deviceId = hrvSource?.id || 'apple';
 const deviceLabel = hrvSource?.label || 'Apple Watch';
 
 const instructions = {
 apple: {
 title: 'Where to find your HRV (Apple Watch)',
 steps: [
 'Open the Health app on your iPhone',
 'Tap Browse → Heart → Heart Rate Variability',
 'Look at your most recent morning reading',
 'Use the number in milliseconds (ms)'
 ]
 },
 whoop: {
 title: 'Where to find your HRV (WHOOP)',
 steps: [
 'Open the WHOOP app',
 'Tap on your daily Recovery score',
 'Scroll to "Heart Rate Variability"',
 'Use the number in milliseconds (ms)'
 ]
 },
 garmin: {
 title: 'Where to find your HRV (Garmin)',
 steps: [
 'Open Garmin Connect app',
 'Go to Health Stats → Heart Rate Variability',
 'Check your morning HRV Status reading',
 'Use the number in milliseconds (ms)'
 ]
 },
 oura: {
 title: 'Where to find your HRV (Oura)',
 steps: [
 'Open the Oura app',
 'Tap on Readiness tab',
 'Scroll to "HRV Balance"',
 'Tap to see your average HRV in milliseconds'
 ]
 },
 fitbit: {
 title: 'Where to find your HRV (Fitbit)',
 steps: [
 'Open the Fitbit app',
 'Tap the Health Metrics tile',
 'Find "Heart Rate Variability"',
 'Use your daily average in milliseconds'
 ]
 },
 polar: {
 title: 'Where to find your HRV (Polar)',
 steps: [
 'Open Polar Flow app',
 'Go to your Nightly Recharge report',
 'Find "ANS Charge" which includes HRV',
 'Use the RMSSD value in milliseconds'
 ]
 },
 samsung: {
 title: 'Where to find your HRV (Samsung Watch)',
 steps: [
 'Open Samsung Health app on your phone',
 'Tap Home → scroll to Heart Rate Variability',
 'Or: Tap Stress → view HRV from stress measurement',
 'Use the RMSSD value in milliseconds (ms)'
 ]
 },
 custom: {
 title: `Where to find your HRV (${deviceLabel})`,
 steps: [
 `Please check the ${deviceLabel} app or website`,
 'Look for Heart Rate Variability or HRV',
 'Find your most recent morning reading',
 'Use the number in milliseconds (ms)'
 ]
 }
 };
 
 return instructions[deviceId] || instructions.custom;
 };
 
 const hrvInstructions = getHrvInstructions();
 
 return (
 <div className="fixed inset-0 z-50 flex items-center justify-center p-4">
 <div className="absolute inset-0 bg-black/70 backdrop-blur-sm" onClick={onClose}></div>
 <div className="glass rounded-3xl p-6 max-w-sm w-full relative z-10 max-h-[85vh] overflow-y-auto space-y-5">
 <div className="flex justify-between items-start">
 <h2 className="text-white text-lg font-medium">How GENYSYS Works</h2>
 <button onClick={onClose} className="text-white/40 hover:text-white text-xl">×</button>
 </div>
 
 <p className="text-white/60 text-sm leading-relaxed">
 Your nervous system tells us how recovered you are. We read it. We tell you what to do.
 </p>
 
 <div className="space-y-2">
 <div className="flex items-start gap-3">
 <span className="text-[#e8b89d] font-bold text-sm">REST</span>
 <span className="text-white/50 text-sm">Light movement only. System needs recovery.</span>
 </div>
 <div className="flex items-start gap-3">
 <span className="text-[#c9b896] font-bold text-sm">BUILD</span>
 <span className="text-white/50 text-sm">Standard training. Execute your program.</span>
 </div>
 <div className="flex items-start gap-3">
 <span className="text-[#9dc4a8] font-bold text-sm">PERFORM</span>
 <span className="text-white/50 text-sm">System primed. Push hard. Chase PRs.</span>
 </div>
 </div>
 
 <div className="border-t border-white/10 pt-4 space-y-2">
 <h3 className="text-white/80 text-sm font-medium">What is HRV?</h3>
 <p className="text-white/50 text-xs leading-relaxed">
 Heart Rate Variability — the time variation between heartbeats, measured in milliseconds (ms). Higher usually means more recovered. Most people range from 20-100ms.
 </p>
 </div>
 
 <div className="border-t border-white/10 pt-4 space-y-2">
 <h3 className="text-white/80 text-sm font-medium">{hrvInstructions.title}</h3>
 <ol className="text-white/50 text-xs leading-relaxed space-y-1 list-decimal list-inside">
 {hrvInstructions.steps.map((step, i) => (
 <li key={i}>{step}</li>
 ))}
 </ol>
 </div>
 
 <div className="border-t border-white/10 pt-4 space-y-2">
 <h3 className="text-white/80 text-sm font-medium">The Process</h3>
 <ol className="text-white/50 text-xs leading-relaxed space-y-1 list-decimal list-inside">
 <li>Log your morning HRV from your device</li>
 <li>After 3 days: Preview commands begin</li>
 <li>After 7 days: Full personalized baseline</li>
 </ol>
 </div>
 
 <div className="border-t border-white/10 pt-4 space-y-2">
 <h3 className="text-white/80 text-sm font-medium">No Wearable?</h3>
 <p className="text-white/50 text-xs leading-relaxed mb-2">
 Download Welltory (free). Take a 1-minute reading with your phone camera each morning.
 </p>
 <div className="flex gap-2">
 <a 
 href="https://apps.apple.com/app/welltory-heart-rate-monitor/id1074367771" 
 target="_blank" 
 rel="noopener noreferrer"
 className="glass-light rounded-lg px-3 py-1.5 text-xs text-white/60 hover:text-white transition-all"
 >
 iOS App Store
 </a>
 <a 
 href="https://play.google.com/store/apps/details?id=com.welltory.client.android" 
 target="_blank" 
 rel="noopener noreferrer"
 className="glass-light rounded-lg px-3 py-1.5 text-xs text-white/60 hover:text-white transition-all"
 >
 Google Play
 </a>
 </div>
 </div>
 
 <div className="bg-amber-500/10 border border-amber-500/20 rounded-xl p-3">
 <p className="text-amber-400/80 text-xs leading-relaxed">
 <span className="font-medium">⚠️ Use the Same Device</span><br/>
 Your data is stored locally on this device only. It won't transfer to other phones or computers. Always log from the same device.
 </p>
 </div>
 
 <p className="text-white/30 text-xs text-center pt-2">
 GENYSYS Private Beta — Your feedback shapes what we build next.
 </p>
 </div>
 </div>
 )};

 // ============================================
 // MAIN APP
 // ============================================
 const App = () => {
 // Core state
 const [hrvHistory, setHrvHistory] = useState([]);
 const [complianceLog, setComplianceLog] = useState([]);
 const [firstUseDate, setFirstUseDate] = useState(null);
 const [hrvSource, setHrvSource] = useState(null);
 const [userName, setUserName] = useState('');
 const [isLoading, setIsLoading] = useState(true);
 
 // UI state
 const [todayHRV, setTodayHRV] = useState('');
 const [result, setResult] = useState(null);
 const [showAddHistory, setShowAddHistory] = useState(false);
 const [customDevice, setCustomDevice] = useState('');
 const [showInfoModal, setShowInfoModal] = useState(false);
 const [newEntry, setNewEntry] = useState('');
 const [newEntryDate, setNewEntryDate] = useState(getYesterdayLocal());
 
 // Observation tracking (to avoid repetition)
 const [lastObservationType, setLastObservationType] = useState(null);
 const [lastObservationDate, setLastObservationDate] = useState(null);

 // Feedback state
 const [showFeedback, setShowFeedback] = useState(false);
 const [feedbackRound, setFeedbackRound] = useState(1);
 const [feedbackStep, setFeedbackStep] = useState(1);
 const [feedbackResponse, setFeedbackResponse] = useState(null);
 const [feedbackText, setFeedbackText] = useState('');
 const [feedbackEmail, setFeedbackEmail] = useState('');
 const [feedbackRound1Complete, setFeedbackRound1Complete] = useState(false);
 const [feedbackRound1Response, setFeedbackRound1Response] = useState(null);
 const [feedbackRound1DismissedAt, setFeedbackRound1DismissedAt] = useState(null);
 const [feedbackRound2Complete, setFeedbackRound2Complete] = useState(false);

 // Track milestone achievements
 const trackedMilestones = useRef(new Set());

 // Load from localStorage
 useEffect(() => {
 try {
 const saved = localStorage.getItem('genysys_v2_data');
 if (saved) {
 const data = JSON.parse(saved);
 setHrvHistory(data.hrvHistory || []);
 setComplianceLog(data.complianceLog || []);
 setFirstUseDate(data.firstUseDate || null);
 setHrvSource(data.hrvSource || null);
 setUserName(data.userName || '');
 setLastObservationType(data.lastObservationType || null);
 setLastObservationDate(data.lastObservationDate || null);
 setFeedbackRound1Complete(data.feedbackRound1Complete || false);
 setFeedbackRound1Response(data.feedbackRound1Response || null);
 setFeedbackRound1DismissedAt(data.feedbackRound1DismissedAt || null);
 setFeedbackRound2Complete(data.feedbackRound2Complete || false);
 
 // Set device for analytics
 if (data.hrvSource) {
 Analytics.setDevice(data.hrvSource.label);
 Analytics.track('session_start', { returning: true, daysLogged: data.hrvHistory?.length || 0 });
 }
 } else {
 Analytics.track('session_start', { returning: false });
 }
 } catch (e) { 
 console.log('No saved data'); 
 }
 setIsLoading(false);
 }, []);

 // Save to localStorage
 useEffect(() => {
 if (isLoading) return;
 localStorage.setItem('genysys_v2_data', JSON.stringify({
 hrvHistory, complianceLog, firstUseDate, hrvSource, userName,
 lastObservationType, lastObservationDate,
 feedbackRound1Complete, feedbackRound1Response, feedbackRound1DismissedAt, feedbackRound2Complete
 }));
 }, [hrvHistory, complianceLog, firstUseDate, hrvSource, userName, lastObservationType, lastObservationDate, feedbackRound1Complete, feedbackRound1Response, feedbackRound1DismissedAt, feedbackRound2Complete, isLoading]);

 // Set firstUseDate when they start
 useEffect(() => {
 if (hrvSource && !firstUseDate) {
 setFirstUseDate(getTodayLocal());
 Analytics.setDevice(hrvSource.label);
 Analytics.track('onboarding_complete', { device: hrvSource.label });
 }
 }, [hrvSource, firstUseDate]);

 // Calculate days on app (handle timezone properly)
 const daysOnApp = useMemo(() => {
 if (!firstUseDate) return 1;
 const start = new Date(firstUseDate + 'T00:00:00');
 const now = new Date();
 const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
 const startDay = new Date(start.getFullYear(), start.getMonth(), start.getDate());
 return Math.max(1, Math.floor((today - startDay) / (1000 * 60 * 60 * 24)) + 1);
 }, [firstUseDate]);

 // Track retention milestones
 useEffect(() => {
 if (!hrvSource || isLoading) return;
 
 const milestones = [3, 7, 14, 30, 60, 90];
 milestones.forEach(milestone => {
 if (daysOnApp >= milestone && !trackedMilestones.current.has(milestone)) {
 trackedMilestones.current.add(milestone);
 Analytics.track(`day_${milestone}_active`, { daysLogged: hrvHistory.length });
 
 // Also track milestone_reached for special days
 if ([7, 30, 60, 90].includes(milestone)) {
 Analytics.track('milestone_reached', { milestone, daysLogged: hrvHistory.length });
 }
 }
 });
 }, [hrvSource, isLoading, daysOnApp, hrvHistory.length]);

 // Auto-calculate if today's data exists
 useEffect(() => {
 if (isLoading || !hrvSource) return;
 const todayDate = getTodayLocal();
 const todayEntry = hrvHistory.find(h => h.date === todayDate);
 if (todayEntry) {
 setTodayHRV(todayEntry.value.toString());
 calculateResult(todayEntry.value, hrvHistory);
 }
 }, [isLoading, hrvHistory, hrvSource]);

 const calculateResult = (hrv, history) => {
 const todayDate = getTodayLocal();
 const historyWithoutToday = history.filter(h => h.date !== todayDate);
 const values = historyWithoutToday.map(h => h.value);
 
 const isPreview = values.length >= THRESHOLDS.MIN_PREVIEW_DAYS && values.length < THRESHOLDS.MIN_DAYS;
 
 if (values.length < THRESHOLDS.MIN_PREVIEW_DAYS) {
 setResult({ 
 commandKey: 'LEARNING', 
 daysNeeded: THRESHOLDS.MIN_PREVIEW_DAYS - values.length,
 isPreview: false 
 });
 return;
 }
 
 const median = calculateMedian(values);
 const mad = calculateMAD(values, median);
 const zScore = (hrv - median) / mad;
 const commandKey = getCommandKey(zScore);
 
 // Use total entries (including today) for countdown to match user expectation
 const totalEntries = history.length;
 const daysUntilFull = isPreview ? Math.max(0, THRESHOLDS.MIN_DAYS - totalEntries) : 0;
 
 setResult({ 
 commandKey, 
 baseline: median, 
 mad, 
 zScore, 
 todayValue: hrv,
 isPreview: daysUntilFull > 0, // Only show preview if there are still days remaining
 daysUntilFull
 });

 // Log command
 const existingLog = complianceLog.findIndex(c => c.date === todayDate);
 if (existingLog >= 0) {
 setComplianceLog(complianceLog.map((c, i) => i === existingLog ? { ...c, command: commandKey } : c));
 } else {
 setComplianceLog([...complianceLog, { date: todayDate, command: commandKey, followed: null }]);
 }
 };

 const handleSubmitHRV = () => {
 const hrv = parseFloat(todayHRV);
 if (isNaN(hrv) || hrv <= 0) return;
 
 const todayDate = getTodayLocal();
 const isFirstHRV = hrvHistory.length === 0;
 let newHistory = [...hrvHistory];
 const existingIndex = newHistory.findIndex(h => h.date === todayDate);
 
 if (existingIndex >= 0) {
 newHistory[existingIndex] = { value: hrv, date: todayDate };
 } else {
 newHistory.push({ value: hrv, date: todayDate });
 }
 
 newHistory.sort((a, b) => new Date(a.date) - new Date(b.date));
 setHrvHistory(newHistory);
 calculateResult(hrv, newHistory);

 // Track HRV logging
 if (isFirstHRV) {
 Analytics.track('first_hrv_logged', { hrv, daysOnApp });
 } else {
 Analytics.track('hrv_logged', { hrv, daysLogged: newHistory.length, daysOnApp });
 }

 // Reset observation if it's a new day
 if (lastObservationDate !== todayDate) {
 setLastObservationType(null);
 setLastObservationDate(todayDate);
 }
 };

 const addHistoricalEntry = () => {
 const val = parseFloat(newEntry);
 if (isNaN(val) || val <= 0) return;
 
 let newHistory = [...hrvHistory];
 const existingIndex = newHistory.findIndex(h => h.date === newEntryDate);
 
 if (existingIndex >= 0) {
 newHistory[existingIndex] = { value: val, date: newEntryDate };
 } else {
 newHistory.push({ value: val, date: newEntryDate });
 }
 
 newHistory.sort((a, b) => new Date(a.date) - new Date(b.date));
 setHrvHistory(newHistory);
 setNewEntry('');
 
 // Track backfill
 Analytics.track('hrv_backfilled', { hrv: val, hrvDate: newEntryDate, daysLogged: newHistory.length });
 
 // Immediately recalculate result if today's entry exists (keeps bullets in sync)
 const todayDate = getTodayLocal();
 const todayEntry = newHistory.find(h => h.date === todayDate);
 if (todayEntry) {
 calculateResult(todayEntry.value, newHistory);
 }
 
 // Move date back by one day for next entry (use noon to avoid timezone/DST issues)
 const prevDate = new Date(newEntryDate + 'T12:00:00');
 prevDate.setDate(prevDate.getDate() - 1);
 setNewEntryDate(getLocalDateString(prevDate));
 };

 const deleteHistoricalEntry = (dateToDelete) => {
 const newHistory = hrvHistory.filter(h => h.date !== dateToDelete);
 setHrvHistory(newHistory);
 
 // Also remove any compliance log for that date
 setComplianceLog(complianceLog.filter(c => c.date !== dateToDelete));
 
 // If we deleted today's entry, clear the result
 if (dateToDelete === getTodayLocal()) {
 setResult(null);
 }
 };

 // Yesterday compliance
 const yesterdayDate = getYesterdayLocal();
 const yesterdayLog = complianceLog.find(c => c.date === yesterdayDate);
 const needsYesterdayCompliance = yesterdayLog?.command && 
 yesterdayLog.command !== 'LEARNING' && 
 yesterdayLog.followed === null;

 const recordCompliance = (followed) => {
 setComplianceLog(complianceLog.map(c => 
 c.date === yesterdayDate ? { ...c, followed } : c
 ));
 
 // Track compliance
 Analytics.track('compliance_recorded', { 
 command: yesterdayLog?.command, 
 followed,
 daysOnApp 
 });
 };

 // Pattern analysis
 const patterns = useMemo(() => 
 analyzePatterns(hrvHistory, complianceLog, firstUseDate),
 [hrvHistory, complianceLog, firstUseDate]
 );

 // Store observation in state to prevent recalculation loops
 const [currentObservation, setCurrentObservation] = useState(null);
 const lastCommandRef = useRef(null);

 // Generate observation only when command changes
 useEffect(() => {
 if (!result) {
 setCurrentObservation(null);
 return;
 }
 
 // During learning phase, always regenerate when hrvHistory changes
 const commandKey = result.commandKey;
 const isLearning = commandKey === 'LEARNING';
 
 // Only skip regeneration if command unchanged AND not in learning phase
 if (commandKey === lastCommandRef.current && !isLearning) return;
 
 lastCommandRef.current = commandKey;
 
 const obs = generateObservation(
 commandKey, 
 patterns, 
 daysOnApp, 
 lastObservationType,
 hrvHistory
 );
 
 setCurrentObservation(obs);
 
 if (obs && obs.type !== lastObservationType) {
 setLastObservationType(obs.type);
 
 // Track observation shown
 Analytics.track('observation_shown', { 
 type: obs.type, 
 command: commandKey,
 daysOnApp 
 });
 }
 }, [result?.commandKey, patterns, daysOnApp, hrvHistory.length]);

 // Use currentObservation instead of computed observation
 const observation = currentObservation;

 // Track command generation
 useEffect(() => {
 if (result && result.commandKey && result.commandKey !== 'LEARNING') {
 Analytics.track('command_generated', { 
 command: result.commandKey, 
 isPreview: result.isPreview,
 zScore: result.zScore?.toFixed(2),
 daysOnApp
 });
 }
 }, [result?.commandKey]);

 // Generate action system
 const actions = useMemo(() => {
 if (!result) return null;
 return generateActions(result.commandKey, patterns, hrvHistory, complianceLog);
 }, [result, patterns, hrvHistory, complianceLog]);

 const hasTodayHRV = hrvHistory.some(h => h.date === getTodayLocal());
 const styles = result ? COMMAND_STYLES[result.commandKey] : COMMAND_STYLES.LEARNING;

 // ============================================
 // FEEDBACK SYSTEM - The relationship checking in
 // Round 1 (Day 10-14): "Is this landing?"
 // Round 2 (Day 35-45): "Who else needs this?"
 // ============================================
 const shouldShowFeedback = () => {
 // Round 1: Day 10-14
 if (!feedbackRound1Complete && !feedbackRound1DismissedAt && daysOnApp >= 10 && daysOnApp <= 14) {
 return 1;
 }
 
 // Round 2: Day 35-45
 // Show if: said "yes" in round 1 OR continued past day 30 without completing round 1
 if (!feedbackRound2Complete && daysOnApp >= 35 && daysOnApp <= 45) {
 if (feedbackRound1Response === 'yes' || feedbackRound1Complete || daysOnApp >= 35) {
 return 2;
 }
 }
 
 return 0;
 };

 // Check for feedback prompt after showing command
 useEffect(() => {
 if (result && result.commandKey && result.commandKey !== 'LEARNING') {
 const round = shouldShowFeedback();
 if (round > 0) {
 // Delay so they see their command first
 const timer = setTimeout(() => {
 setFeedbackRound(round);
 setFeedbackStep(1);
 setFeedbackResponse(null);
 setFeedbackText('');
 setShowFeedback(true);
 }, 2000);
 return () => clearTimeout(timer);
 }
 }
 }, [result?.commandKey, daysOnApp]);

 const sendFeedback = () => {
 if (feedbackRound === 1) {
 Analytics.track('feedback_round1_submitted', { 
 response: feedbackResponse,
 text: feedbackText.substring(0, 500) || '',
 email: feedbackEmail.trim().substring(0, 100) || '',
 daysOnApp,
 daysLogged: hrvHistory.length
 });
 setFeedbackRound1Complete(true);
 setFeedbackRound1Response(feedbackResponse);
 } else if (feedbackRound === 2) {
 Analytics.track('feedback_round2_submitted', { 
 response: feedbackResponse,
 text: feedbackText.substring(0, 500) || '',
 daysOnApp,
 daysLogged: hrvHistory.length
 });
 setFeedbackRound2Complete(true);
 }
 
 setShowFeedback(false);
 setFeedbackStep(1);
 setFeedbackText('');
 setFeedbackEmail('');
 };

 const dismissFeedback = (dontAskAgain) => {
 if (feedbackRound === 1) {
 if (dontAskAgain) {
 setFeedbackRound1Complete(true);
 } else {
 setFeedbackRound1DismissedAt(getTodayLocal());
 }
 Analytics.track('feedback_round1_dismissed', { dontAskAgain, daysOnApp });
 } else if (feedbackRound === 2) {
 setFeedbackRound2Complete(true);
 Analytics.track('feedback_round2_dismissed', { daysOnApp });
 }
 
 setShowFeedback(false);
 setFeedbackStep(1);
 };

 // Reset function
 const resetAll = () => {
 Analytics.track('data_reset', { daysLogged: hrvHistory.length, daysOnApp });
 
 localStorage.removeItem('genysys_v2_data');
 setHrvHistory([]);
 setComplianceLog([]);
 setFirstUseDate(null);
 setHrvSource(null);
 setUserName('');
 setResult(null);
 setTodayHRV('');
 setLastObservationType(null);
 setLastObservationDate(null);
 setFeedbackRound1Complete(false);
 setFeedbackRound1Response(null);
 setFeedbackRound1DismissedAt(null);
 setFeedbackRound2Complete(false);
 };

 if (isLoading) {
 return (
 <div className="min-h-screen text-white flex items-center justify-center">
 <div className="mist-overlay"></div>
 <div className="content-layer text-white/40 pulse-slow">...</div>
 </div>
 );
 }

 // ============================================
 // FIRST SCREEN - The Beginning
 // ============================================
 if (!hrvSource) {
 return (
 <div className="min-h-screen text-white p-6 flex flex-col justify-center">
 <div className="mist-overlay"></div>
 <div className="content-layer max-w-sm mx-auto space-y-10">
 
 {/* Info icon - top right */}
 <button 
 onClick={() => setShowInfoModal(true)}
 className="absolute top-6 right-6 text-white/30 hover:text-white/60 transition-all"
 style={{ position: 'fixed' }}
 >
 <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5">
 <circle cx="12" cy="12" r="10"/>
 <path d="M12 16v-4M12 8h.01"/>
 </svg>
 </button>
 
 <div className="space-y-3 text-center fade-in">
 <p className="text-white text-2xl font-light">
 Your body is talking.
 </p>
 <p className="text-white/60 text-lg">
 Now you know what it's asking for.
 </p>
 </div>

 <div className="space-y-4 text-center fade-in-delay-1">
 <p className="text-white/50">Give me a week — I'll find your baseline.</p>
 <p className="text-white/50">Give me a month — I'll recognize your rhythms.</p>
 <p className="text-white/40 leading-relaxed">Give me a year — I'll see what even you can't:<br/>what pushes you forward… and what sets you back.</p>
 </div>

 <div className="space-y-4 fade-in-delay-2">
 <p className="text-white/40 text-sm text-center">Where does your HRV come from?</p>
 <div className="grid grid-cols-2 gap-2">
 {HRV_SOURCES.map(source => (
 <button
 key={source.id}
 onClick={() => setHrvSource(source)}
 className="glass hover:bg-white/10 rounded-2xl py-3 px-4 text-sm text-white/70 hover:text-white transition-all duration-300"
 >
 {source.label}
 </button>
 ))}
 </div>
 
 {/* Custom device input */}
 <div className="flex gap-2 mt-3">
 <input
 type="text"
 value={customDevice}
 onChange={(e) => setCustomDevice(e.target.value)}
 placeholder="Other device..."
 className="flex-1 glass rounded-2xl py-3 px-4 text-sm text-white placeholder-white/30 bg-transparent border-0 outline-none focus:ring-1 focus:ring-white/20"
 />
 {customDevice.trim() && (
 <button
 onClick={() => setHrvSource({ id: 'custom', label: customDevice.trim() })}
 className="glass hover:bg-white/10 rounded-2xl py-3 px-4 text-sm text-white/70 hover:text-white transition-all duration-300"
 >
 →
 </button>
 )}
 </div>
 </div>

 </div>
 <Tagline />
 
 {/* Info Modal */}
 {showInfoModal && <InfoModal onClose={() => setShowInfoModal(false)} hrvSource={hrvSource} />}
 </div>
 );
 }

 // ============================================
 // HRV INPUT - Before Today's Entry
 // ============================================
 if (!hasTodayHRV) {
 // Calculate countdown - updates when hrvHistory changes
 const daysRemaining = 4 - hrvHistory.length;
 const countdownText = daysRemaining > 0 
 ? `${daysRemaining} day${daysRemaining > 1 ? 's' : ''} until commands · Add history below to unlock today`
 : hrvHistory.length < 7 ? 'Personalized guidance unlocking...' : null;
 
 return (
 <div className="min-h-screen text-white p-4 flex flex-col overflow-y-auto">
 <div className="mist-overlay"></div>
 
 {/* Info icon - top right */}
 <button 
 onClick={() => setShowInfoModal(true)}
 className="fixed top-4 right-4 text-white/30 hover:text-white/60 transition-all z-20"
 >
 <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5">
 <circle cx="12" cy="12" r="10"/>
 <path d="M12 16v-4M12 8h.01"/>
 </svg>
 </button>
 
 <div className="content-layer max-w-sm mx-auto flex-1 flex flex-col justify-center space-y-6 py-12">
 
 {/* Day counter + countdown */}
 <div className="text-center fade-in space-y-1">
 <div className="text-white/30 text-sm tracking-wide">
 {daysOnApp <= 1 ? "Day 1" : `Day ${daysOnApp}`}
 </div>
 {countdownText && (
 <div className="text-white/20 text-xs">
 {countdownText}
 </div>
 )}
 </div>

 {/* Yesterday compliance */}
 {needsYesterdayCompliance && (
 <div className="glass rounded-2xl p-4 space-y-3 fade-in">
 <p className="text-white/60 text-center text-sm">
 Yesterday I said <span style={{ color: COMMAND_STYLES[yesterdayLog.command].color }}>{yesterdayLog.command}</span>
 </p>
 <div className="flex gap-2">
 <button
 onClick={() => recordCompliance('yes')}
 className="flex-1 glass-light hover:bg-white/10 rounded-xl py-2.5 text-sm text-white/80 transition-all duration-300"
 >
 I listened
 </button>
 <button
 onClick={() => recordCompliance('no')}
 className="flex-1 glass-light hover:bg-white/10 rounded-xl py-2.5 text-sm text-white/80 transition-all duration-300"
 >
 I didn't
 </button>
 </div>
 </div>
 )}

 {/* HRV Input */}
 <div className="space-y-3 fade-in-delay-1">
 <p className="text-white/60 text-center">
 {daysOnApp <= 1 ? "What's your HRV this morning?" : "What's your HRV?"}
 </p>
 <div className="flex gap-2">
 <input
 type="number"
 value={todayHRV}
 onChange={(e) => setTodayHRV(e.target.value)}
 onKeyDown={(e) => e.key === 'Enter' && handleSubmitHRV()}
 placeholder="HRV"
 className="flex-1 glass rounded-2xl px-4 py-3 text-xl text-center font-light text-white placeholder-white/30 focus:outline-none focus:ring-1 focus:ring-white/20 transition-all"
 autoFocus
 />
 <button
 onClick={handleSubmitHRV}
 className="bg-white/90 text-black rounded-2xl px-5 py-3 font-medium hover:bg-white transition-all duration-300"
 >
 Go
 </button>
 </div>
 <p className="text-white/20 text-xs text-center">
 from {hrvSource.label}
 </p>
 </div>

 {/* Add history link */}
 <button
 onClick={() => setShowAddHistory(true)}
 className="text-white/30 text-sm hover:text-white/50 transition-all"
 >
 + Add past days
 </button>

 </div>

 {/* History Modal */}
 {showAddHistory && (
 <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-end justify-center z-50">
 <div className="glass-dark rounded-t-3xl p-6 w-full max-w-md space-y-6">
 <div className="flex justify-between items-center">
 <h3 className="text-lg font-medium text-white">Add Past HRV</h3>
 <button 
 onClick={() => setShowAddHistory(false)}
 className="text-white/40 hover:text-white text-2xl transition-colors"
 >×</button>
 </div>
 
 <p className="text-white/40 text-sm">
 The more history I have, the faster I learn you.
 </p>
 
 <div className="flex gap-2">
 <input
 type="number"
 value={newEntry}
 onChange={(e) => setNewEntry(e.target.value)}
 onKeyDown={(e) => e.key === 'Enter' && addHistoricalEntry()}
 placeholder="HRV"
 className="w-24 glass rounded-xl px-3 py-3 text-center text-white placeholder-white/30 focus:outline-none focus:ring-1 focus:ring-white/20"
 autoFocus
 />
 <input
 type="date"
 value={newEntryDate}
 onChange={(e) => setNewEntryDate(e.target.value)}
 className="flex-1 glass rounded-xl px-3 py-3 text-white/60 focus:outline-none"
 />
 <button
 onClick={addHistoricalEntry}
 className="glass-light hover:bg-white/10 rounded-xl px-4 py-3 text-white/80 transition-all"
 >
 Add
 </button>
 </div>

 {hrvHistory.length > 0 && (
 <div className="space-y-2 max-h-48 overflow-y-auto">
 {[...hrvHistory].reverse().slice(0, 14).map((entry, i) => (
 <div key={entry.date} className="flex justify-between items-center text-sm text-white/40 py-2 border-b border-white/5">
 <span>{entry.date}</span>
 <div className="flex items-center gap-3">
 <span className="font-mono">{entry.value} ms</span>
 <button
 onClick={() => deleteHistoricalEntry(entry.date)}
 className="text-white/20 hover:text-red-400 transition-colors text-lg leading-none"
 title="Delete entry"
 >×</button>
 </div>
 </div>
 ))}
 </div>
 )}

 <button
 onClick={() => setShowAddHistory(false)}
 className="w-full glass-light hover:bg-white/10 rounded-xl py-3 text-white/80 transition-all"
 >
 Done — {hrvHistory.length} days logged
 </button>
 </div>
 </div>
 )}
 
 {/* Info Modal */}
 {showInfoModal && <InfoModal onClose={() => setShowInfoModal(false)} hrvSource={hrvSource} />}
 
 <Tagline />
 </div>
 );
 }

 // ============================================
 // MAIN VIEW - The Daily Experience
 // ============================================
 return (
 <div className="min-h-screen text-white p-6 flex flex-col">
 <div className="mist-overlay"></div>
 
 {/* Info icon - top right */}
 <button 
 onClick={() => setShowInfoModal(true)}
 className="fixed top-6 right-6 text-white/30 hover:text-white/60 transition-all z-20"
 >
 <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5">
 <circle cx="12" cy="12" r="10"/>
 <path d="M12 16v-4M12 8h.01"/>
 </svg>
 </button>
 
 <div className="content-layer max-w-sm mx-auto flex-1 flex flex-col justify-center space-y-8">
 
 {/* Day indicator */}
 <div className="text-center">
 <span className="text-white/30 text-sm tracking-wide">Day {daysOnApp}</span>
 </div>

 {/* Pattern Name - if detected */}
 {patterns?.patternName && (
 <div className="text-center fade-in">
 <span className="text-white/40 text-xs uppercase tracking-widest">
 {patterns.patternName === 'recovery_arc' && "You're in a recovery arc"}
 {patterns.patternName === 'back_to_back_crash' && `You crash after back-to-back PERFORMs`}
 </span>
 </div>
 )}

 {/* Day-of-week pattern */}
 {patterns?.todayDowPattern && !patterns?.patternName && (
 <div className="text-center fade-in">
 <span className="text-white/40 text-xs uppercase tracking-widest">
 {patterns.todayDowPattern.tendency === 'low' 
 ? `Your ${patterns.todayDowPattern.day}s tend to be low`
 : `${patterns.todayDowPattern.day}s are usually your strong day`}
 </span>
 </div>
 )}

 {/* The Observation - typewriter effect */}
 {observation && (
 <div className="text-center fade-in">
 <p className="text-white/60 text-sm leading-snug px-2 line-clamp-2">
 "<Typewriter 
 key={observation.type + observation.text.substring(0, 20)} 
 text={observation.text} 
 speed={60} 
 />"
 </p>
 </div>
 )}

 {/* IMPOSSIBLE INSIGHT - when detected */}
 {patterns?.impossibleInsight && (
 <div className="text-center fade-in">
 <p className="text-amber-400/70 text-xs font-medium">
 ⚠ {patterns.impossibleInsight.text}
 </p>
 </div>
 )}

 {/* The Command - Glass card with bullets inside */}
 <div 
 className="glass rounded-3xl py-8 px-6 text-center fade-in-delay-1"
 style={{ 
 boxShadow: `0 8px 32px ${styles.glow || 'rgba(0,0,0,0.2)'}`,
 borderColor: styles.border
 }}
 >
 <div 
 className="text-5xl font-bold tracking-tight mb-4"
 style={{ color: styles.color }}
 >
 {result?.commandKey || 'LEARNING'}
 </div>
 
 {/* Stats - right under command */}
 {patterns && daysOnApp >= 7 && (
 <p className="text-white/25 text-xs mb-5">
 {patterns.performDays} peaks · {patterns.restDays} protected · {patterns.totalDays} days
 </p>
 )}
 
 {/* Action System inside card */}
 {actions && (
 <div className="space-y-3 text-left border-t border-white/10 pt-4 mt-2">
 <div className="flex items-start gap-2">
 <span className="text-white/30 text-xs font-medium uppercase tracking-wide w-16 shrink-0 mt-0.5">Action</span>
 <p className="text-white/60 text-xs leading-relaxed">{actions.primaryAction}</p>
 </div>
 <div className="flex items-start gap-2">
 <span className="text-white/30 text-xs font-medium uppercase tracking-wide w-16 shrink-0 mt-0.5">Effort</span>
 <p className="text-white/50 text-xs leading-relaxed">{actions.effortBoundary}</p>
 </div>
 <div className="flex items-start gap-2">
 <span className="text-white/30 text-xs font-medium uppercase tracking-wide w-16 shrink-0 mt-0.5">Recovery</span>
 <p className="text-white/50 text-xs leading-relaxed">{actions.recoveryLever}</p>
 </div>
 </div>
 )}
 </div>

 {/* Guardrail - below the card */}
 {actions?.guardrail && (
 <div className="text-center fade-in-delay-2">
 <p className="text-amber-400/60 text-xs">
 ⚠️ {actions.guardrail}
 </p>
 </div>
 )}

 {/* Preview indicator */}
 {result?.isPreview && (
 <div className="text-center space-y-1">
 <p className="text-white/50 text-xs">
 {result.daysUntilFull} day{result.daysUntilFull > 1 ? 's' : ''} until personalized guidance unlocks.
 </p>
 <p className="text-white/30 text-xs">
 We don't guess. We learn you first.
 </p>
 </div>
 )}

 </div>

 {/* Settings */}
 <div className="content-layer max-w-sm mx-auto w-full pt-8 pb-16 flex justify-between text-white/40 text-xs">
 <button 
 onClick={() => setShowAddHistory(true)}
 className="hover:text-white/70 transition-all"
 >
 + Add history
 </button>
 <button 
 onClick={resetAll}
 className="hover:text-white/70 transition-all"
 >
 Reset
 </button>
 </div>

 {/* History Modal */}
 {showAddHistory && (
 <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-end justify-center z-50">
 <div className="glass-dark rounded-t-3xl p-6 w-full max-w-md space-y-6">
 <div className="flex justify-between items-center">
 <h3 className="text-lg font-medium text-white">Add Past HRV</h3>
 <div className="flex items-center gap-4">
 <span className="text-white/40 text-sm">{hrvHistory.length} {hrvHistory.length === 1 ? 'entry' : 'entries'}</span>
 <button 
 onClick={() => setShowAddHistory(false)}
 className="text-white/40 hover:text-white text-2xl transition-colors"
 >×</button>
 </div>
 </div>
 
 <div className="flex gap-2">
 <input
 type="number"
 value={newEntry}
 onChange={(e) => setNewEntry(e.target.value)}
 onKeyDown={(e) => e.key === 'Enter' && addHistoricalEntry()}
 placeholder="HRV"
 className="w-24 glass rounded-xl px-3 py-3 text-center text-white placeholder-white/30 focus:outline-none focus:ring-1 focus:ring-white/20"
 autoFocus
 />
 <input
 type="date"
 value={newEntryDate}
 onChange={(e) => setNewEntryDate(e.target.value)}
 className="flex-1 glass rounded-xl px-3 py-3 text-white/60 focus:outline-none"
 />
 <button
 onClick={addHistoricalEntry}
 className="glass-light hover:bg-white/10 rounded-xl px-4 py-3 text-white/80 transition-all"
 >
 Add
 </button>
 </div>

 {hrvHistory.length > 0 && (
 <div className="space-y-2 max-h-48 overflow-y-auto">
 {[...hrvHistory].reverse().slice(0, 14).map((entry, i) => (
 <div key={entry.date} className="flex justify-between items-center text-sm text-white/40 py-2 border-b border-white/5">
 <span>{entry.date}</span>
 <div className="flex items-center gap-3">
 <span className="font-mono">{entry.value} ms</span>
 <button
 onClick={() => deleteHistoricalEntry(entry.date)}
 className="text-white/20 hover:text-red-400 transition-colors text-lg leading-none"
 title="Delete entry"
 >×</button>
 </div>
 </div>
 ))}
 </div>
 )}

 <button
 onClick={() => setShowAddHistory(false)}
 className="w-full glass-light hover:bg-white/10 rounded-xl py-3 text-white/80 transition-all"
 >
 Done
 </button>
 </div>
 </div>
 )}

 {/* Feedback Modal */}
 {showFeedback && (
 <FeedbackModal
 round={feedbackRound}
 daysOnApp={daysOnApp}
 step={feedbackStep}
 setStep={setFeedbackStep}
 response={feedbackResponse}
 setResponse={setFeedbackResponse}
 text={feedbackText}
 setText={setFeedbackText}
 email={feedbackEmail}
 setEmail={setFeedbackEmail}
 onSend={sendFeedback}
 onDismiss={dismissFeedback}
 />
 )}
 
 {/* Info Modal */}
 {showInfoModal && <InfoModal onClose={() => setShowInfoModal(false)} hrvSource={hrvSource} />}
 
 <Tagline />
 </div>
 );
 };

 ReactDOM.createRoot(document.getElementById('root')).render(<App />);
 </script>
</body>
</html>
